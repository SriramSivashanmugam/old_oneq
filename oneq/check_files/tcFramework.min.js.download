var __webpack_exports__ = {};
var Inq = (function (siteFcnStr, rulesEngineDataStr, loadedMbuRuleDataFuns, programRulesConf) {
	/**
	 * This config object is only available in JSSDK mode
	 * It is the parsed JSON response that comes from a call to /tagserver/v1/jssdkApi/all?siteID=xxxx which is generated
	 * by `siteDefaultData_conf.jsp`
	 * @type {?Object}
	 */
	var jsonAPIData = v3Lander.jsonAPIData;

	var isInqInitialized = false;
	var jsSDKEnabled = v3Lander.isJSSDK;
	var startedTime = Date.now();

	if (jsSDKEnabled) {
		var initSiteData = siteFcnStr;
	} else {
		// Re-evaluate because some variables only available here
		eval("var initSiteData = " + siteFcnStr.toString());
		eval("var programRulesConfig = " + programRulesConf.toString());
	}

	var site = initSiteData();

	/** @type {string} we need to save initial value of vanity URL because
	 * it can be overridden (see overRideDomainsIfAny())
	 */
	var vanityUrl = site.vanityDomainName;
	var one2ManyChatrouterDomain = site.oneToManyChatrouterDomain || "api.inq.com";
	var one2ManyChat = false;
	var isConversationActive = false;
	var isWebSDK = v3Lander.isWebSDK;

	function getConversationActive () {
		return isConversationActive;
	}

	function setConversationActive (value) {
		isConversationActive = value;
	}

	function isFireC2cRulesOnChatClose () {
		return site.fireC2CRulesOnChatClose;
	}

	var JSLoggingDisabled = site.JSLoggingDisabled;
	var disableLogToServer = site.disableLogToServer;
	try {
		if (JSLoggingDisabled) {
			JSLoggingDisabled = !window.localStorage.getItem("enableJSLogging");
		}
	} catch (e) {
		//ignore browser access denied issue
	}

	var dataReady = false;
	var persistentCustomerID = null;
	var authenticatedUser = null;
	var secureWithCustToken = false;
	var win, doc;
	if (isWebSDK) {
		win = self;
		site.noJSHosting = false;
	} else {
		win = self.parent;
	}
	doc = win.document;
	var domObserver;
	var initRule = {};
	var openerData = {};
	var isChatProgressInSDK = false;
	var deviceDetails = null;
	var evaluateLegacySettingsWarnNeeded = true;

	var KEY_ENGAGEMENT_ID_STRING = "engagementID";
	var KEY_CUSTOMER_ID_STRING = "customerID";
	var KEY_WINDOW_ID_STRING = "windowId";
	var COOKIE_PC_NAME = "inqPc";
	var COOKIE_COBROWSE = "cobrowse";
	var DEFERRED_START_OF_MANAGERS_KEY = "DEFERRED_START_OF_MANAGERS";
	var DEFAULT_INITIAL_TIMEOUT = 120;
	var RIGHT = "r";
	var BOTTOM = "b";
	var PERSISTENT_COOKIE_ALLOWED = "pc";

	(function initializeFacade () {
		window.getParentElByIDTFacade = function (id) {
			if (isWebSDK) {
				return window.document.getElementById(id);
			}
			return window.parent.document.getElementById(id);
		};

		window.getParentElsByTNTFacade = function (tname) {
			if (isWebSDK) {
				return window.document.getElementsByTagName(tname);
			}
			return window.parent.document.getElementsByTagName(tname);
		}

		window.buildNuanceModalWindow = function () {
		}

		window.toggleNuanceModalWindow = function (isModal) {
		}

		window.removeNuanceModalWindow = function () {
		}
	}());

	(function overRideDomainsIfAny () {
		var v3Config = v3LanderConfig;
		/**
		 * According to the logic of constructing the v3LanderConfig object (see inqChatLaunch.jsp),
		 * only one config can e9 (either config from current window, or from parent window, or from opener window).
		 * If v3LanderConfig.parent e9, we definitely know that v3LanderConfig is missed in the current window.
		 * Then, if v3LanderConfig.parent.opener e9, we know that v3LanderConfig is missed in the parent window.
		 */
		if (isWebSDK) {
			return;
		} else if (v3LanderConfig.parent) {
			if (v3LanderConfig.parent.opener) {
				v3Config = v3LanderConfig.parent.opener;
			} else {
				v3Config = v3LanderConfig.parent;
			}
		}
		site.chatRouterVanityDomain = (v3Config.crVanityDomain || site.chatRouterVanityDomain).replace(/(^\w+:|^)\/\//, '');
		site.vanityDomainName = v3Config.vanityDomain || site.vanityDomainName;
		site.cobrowseURL = v3Config.cbVanityDomain || site.cobrowseURL;
		site.clientStaticUrl = v3Config.clientStaticUrl || site.clientStaticUrl;
		site.mediaServer = v3Config.mediaUrl || site.mediaServer;
		site.xformsVanityDomain = (v3Config.xformsUrl || site.xformsVanityDomain).replace(/(^\w+:|^)\/\//, '');
		site.psHosturlList = v3Config.psHostedFileUrl || site.psHosturlList;
	}());

	/*
 * Original code (c) 2010 Nick Galbreath
 * http://code.google.com/p/stringencoders/source/browse/#svn/trunk/javascript
 *
 * jQuery port (c) 2010 Carlo Zottmann
 * http://github.com/carlo/jquery-k6ji
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* k6ji encode/decode compatible with window.btoa/atob
 *
 * window.atob/btoa is a Firefox extension to convert binary data (the "b")
 * to k6ji (ascii, the "a").
 *
 * It is also found in Safari and Chrome.  It is not available in IE.
 *
 * if (!window.btoa) window.btoa = $.k6ji.encode
 * if (!window.atob) window.atob = $.k6ji.decode
 *
 * The original spec's for atob/btoa are a bit lacking
 * https://developer.mozilla.org/en/DOM/window.atob
 * https://developer.mozilla.org/en/DOM/window.btoa
 *
 * window.btoa and $.k6ji.encode takes a string where charCodeAt is [0,255]
 * If any character is not [0,255], then an exception is thrown.
 *
 * window.atob and $.k6ji.decode take a k6ji-encoded string
 * If the input length is not a multiple of 4, or contains invalid characters
 *   then an exception is thrown.
 */

function Base64() {

	var _PADCHAR = "=",
		_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
		_VERSION = "1.0";


	function _getbyte64( s, i ) {
		// This is oddly fast, except on Chrome/V8.
		// Minimal or no improvement in performance by using a
		// object with properties mapping chars to value (eg. 'A': 0)

		var idx = _ALPHA.indexOf( s.charAt( i ) );

		if ( idx === -1 ) {
			throw "Cannot decode k6ji";
		}

		return idx;
	}


	function _decode( s ) {
		var pads = 0,
			i,
			b10,
			imax = s.length,
			x = [];

		s = String( s );

		if ( imax === 0 ) {
			return s;
		}

		if ( imax % 4 !== 0 ) {
			throw "Cannot decode k6ji";
		}

		if ( s.charAt( imax - 1 ) === _PADCHAR ) {
			pads = 1;

			if ( s.charAt( imax - 2 ) === _PADCHAR ) {
				pads = 2;
			}

			// either way, we want to ignore this last block
			imax -= 4;
		}

		for ( i = 0; i < imax; i += 4 ) {
			b10 = ( _getbyte64( s, i ) << 18 ) | ( _getbyte64( s, i + 1 ) << 12 ) | ( _getbyte64( s, i + 2 ) << 6 ) | _getbyte64( s, i + 3 );
			x.push( String.fromCharCode( b10 >> 16, ( b10 >> 8 ) & 0xff, b10 & 0xff ) );
		}

		switch ( pads ) {
			case 1:
				b10 = ( _getbyte64( s, i ) << 18 ) | ( _getbyte64( s, i + 1 ) << 12 ) | ( _getbyte64( s, i + 2 ) << 6 );
				x.push( String.fromCharCode( b10 >> 16, ( b10 >> 8 ) & 0xff ) );
				break;

			case 2:
				b10 = ( _getbyte64( s, i ) << 18) | ( _getbyte64( s, i + 1 ) << 12 );
				x.push( String.fromCharCode( b10 >> 16 ) );
				break;
		}

		return x.join( "" );
	}


	function _getbyte( s, i ) {
		var x = s.charCodeAt( i );

		if ( x > 255 ) {
			throw "INVALID_CHARACTER_ERR: DOM Exception 5";
		}

		return x;
	}


	function _encode( s ) {
		if ( arguments.length !== 1 ) {
			throw "SyntaxError: exactly one argument required";
		}

		s = String( s );

		var i,
			b10,
			x = [],
			imax = s.length - s.length % 3;

		if ( s.length === 0 ) {
			return s;
		}

		for ( i = 0; i < imax; i += 3 ) {
			b10 = ( _getbyte( s, i ) << 16 ) | ( _getbyte( s, i + 1 ) << 8 ) | _getbyte( s, i + 2 );
			x.push( _ALPHA.charAt( b10 >> 18 ) );
			x.push( _ALPHA.charAt( ( b10 >> 12 ) & 0x3F ) );
			x.push( _ALPHA.charAt( ( b10 >> 6 ) & 0x3f ) );
			x.push( _ALPHA.charAt( b10 & 0x3f ) );
		}

		switch ( s.length - imax ) {
			case 1:
				b10 = _getbyte( s, i ) << 16;
				x.push( _ALPHA.charAt( b10 >> 18 ) + _ALPHA.charAt( ( b10 >> 12 ) & 0x3F ) + _PADCHAR + _PADCHAR );
				break;

			case 2:
				b10 = ( _getbyte( s, i ) << 16 ) | ( _getbyte( s, i + 1 ) << 8 );
				x.push( _ALPHA.charAt( b10 >> 18 ) + _ALPHA.charAt( ( b10 >> 12 ) & 0x3F ) + _ALPHA.charAt( ( b10 >> 6 ) & 0x3f ) + _PADCHAR );
				break;
		}

		return x.join( "" );
	}


	return {
		TUY9: _decode,
		pN65: _encode,
		VERSION: _VERSION
	};
}

/*
* fingerprintJS 0.5.4 - Fast browser fingerprint library
* https://github.com/Valve/fingerprintjs
* Copyright (c) 2013 Valentin Vasilyev (valentin.vasilyev@outlook.com)
* Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function (name, context, definition) {
  /** removed the AMD and ES6 module loading because we does not use while retreiving the loaded object **/
	if (typeof context[name] != "undefined") {
		context[name + "Nuance"] = definition();
	}
	else {
		context[name] = definition();
	}

})('Fingerprint', this, function () {
  'use strict';

  var Fingerprint = function (options) {
    var nativeForEach, nativeMap;
    nativeForEach = Array.prototype.forEach;
    nativeMap = Array.prototype.map;

    this.each = function (obj, iterator, context) {
      if (obj === null) {
        return;
      }
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === {}) return;
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (iterator.call(context, obj[key], key, obj) === {}) return;
          }
        }
      }
    };

    this.map = function(obj, iterator, context) {
      var results = [];
      // Not using strict equality so that this acts as a
      // shortcut to checking for `null` and `undefined`.
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      this.each(obj, function(value, index, list) {
        results[results.length] = iterator.call(context, value, index, list);
      });
      return results;
    };

    if (typeof options == 'object'){
      this.hasher = options.hasher;
      this.screen_resolution = options.screen_resolution;
      this.screen_orientation = options.screen_orientation;
      this.canvas = options.canvas;
      this.ie_activex = options.ie_activex;
    } else if(typeof options == 'function'){
      this.hasher = options;
    }
  };

  Fingerprint.prototype = {
    get: function(){
      var keys = [];
      keys.push(navigator.userAgent);
      keys.push(navigator.language);
      keys.push(screen.colorDepth);
      if (this.screen_resolution) {
        var resolution = this.getScreenResolution();
        if (typeof resolution !== 'undefined'){ // headless browsers, such as phantomjs
          keys.push(resolution.join('x'));
        }
      }
      keys.push(new Date().getTimezoneOffset());
      keys.push(this.hasSessionStorage());
      keys.push(this.hasLocalStorage());
      keys.push(!!window.indexedDB);
      //body might not be defined at this point or removed programmatically
      if(document.body){
        keys.push(typeof(document.body.addBehavior));
      } else {
        keys.push(typeof undefined);
      }
      keys.push(typeof(window.openDatabase));
      keys.push(navigator.cpuClass);
      keys.push(navigator.platform);
      keys.push(navigator.doNotTrack);
      keys.push(this.getPluginsString());
      if(this.canvas && this.isCanvasSupported()){
        keys.push(this.getCanvasFingerprint());
      }
      if(this.hasher){
        return this.hasher(keys.join('###'), 31);
      } else {
        return this.murmurhash3_32_gc(keys.join('###'), 31);
      }
    },

    /**
     * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {string} key ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */

    murmurhash3_32_gc: function(key, seed) {
      var remainder, bytes, h1, h1b, c1, c2, k1, i;

      remainder = key.length & 3; // key.length % 4
      bytes = key.length - remainder;
      h1 = seed;
      c1 = 0xcc9e2d51;
      c2 = 0x1b873593;
      i = 0;

      while (i < bytes) {
          k1 =
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;

        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
            h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
      }

      k1 = 0;

      switch (remainder) {
        case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1: k1 ^= (key.charCodeAt(i) & 0xff);

        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
        h1 ^= k1;
      }

      h1 ^= key.length;

      h1 ^= h1 >>> 16;
      h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= h1 >>> 13;
      h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
      h1 ^= h1 >>> 16;

      return h1 >>> 0;
    },

    // https://bugzilla.mozilla.org/show_bug.cgi?id=781447
    hasLocalStorage: function () {
      try{
        return !!window.localStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it e9
      }
    },

    hasSessionStorage: function () {
      try{
        return !!window.sessionStorage;
      } catch(e) {
        return true; // SecurityError when referencing it means it e9
      }
    },

    isCanvasSupported: function () {
      var elem = document.createElement('canvas');
      return !!(elem.getContext && elem.getContext('2d'));
    },

    isIE: function () {
      if(navigator.appName === 'Microsoft Internet Explorer') {
        return true;
      } else if(navigator.appName === 'Netscape' && /Trident/.test(navigator.userAgent)){// IE 11
        return true;
      }
      return false;
    },

    getPluginsString: function () {
      if(this.isIE() && this.ie_activex){
        return this.getIEPluginsString();
      } else {
        return this.getRegularPluginsString();
      }
    },

    getRegularPluginsString: function () {
      return this.map(navigator.plugins, function (p) {
        var mimeTypes = this.map(p, function(mt){
          return [mt.type, mt.suffixes].join('~');
        }).join(',');
        return [p.name, p.description, mimeTypes].join('::');
      }, this).join(';');
    },

    getIEPluginsString: function () {
      if(window.ActiveXObject){
        var names = ['ShockwaveFlash.ShockwaveFlash',//flash plugin
          'AcroPDF.PDF', // Adobe PDF reader 7+
          'PDF.PdfCtrl', // Adobe PDF reader 6 and earlier, brrr
          'QuickTime.QuickTime', // QuickTime
          // 5 versions of real players
          'rmocx.RealPlayer G2 Control',
          'rmocx.RealPlayer G2 Control.1',
          'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)',
          'RealVideo.RealVideo(tm) ActiveX Control (32-bit)',
          'RealPlayer',
          'SWCtl.SWCtl', // ShockWave player
          'WMPlayer.OCX', // Windows media player
          'AgControl.AgControl', // Silverlight
          'Skype.Detection'];

        // starting to detect plugins in IE
        return this.map(names, function(name){
          try{
            new ActiveXObject(name);
            return name;
          } catch(e){
            return null;
          }
        }).join(';');
      } else {
        return ""; // behavior prior version 0.5.0, not breaking backwards compat.
      }
    },

    getScreenResolution: function () {
      var resolution;
       if(this.screen_orientation){
         resolution = (screen.height > screen.width) ? [screen.height, screen.width] : [screen.width, screen.height];
       }else{
         resolution = [screen.height, screen.width];
       }
       return resolution;
    },

    getCanvasFingerprint: function () {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      // https://www.browserleaks.com/canvas#how-does-it-work
      var txt = 'http://valve.github.io';
      ctx.textBaseline = "top";
      ctx.font = "14px 'Arial'";
      ctx.textBaseline = "alphabetic";
      ctx.fillStyle = "#f60";
      ctx.fillRect(125,1,62,20);
      ctx.fillStyle = "#069";
      ctx.fillText(txt, 2, 15);
      ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
      ctx.fillText(txt, 4, 17);
      return canvas.toDataURL();
    }
  };


  return Fingerprint;

});

/**
 * DOM polyfills
 * {@link https://github.com/inexorabletash/polyfill Is used the polyfills from this repo on gihub}
 */
/**
 * Document.querySelectorAll method
 * http://ajaxian.com/archives/creating-a-queryselector-for-ie-that-runs-at-native-speed
 * Needed for: IE7-
 */
if (!document.querySelectorAll) {
	document.querySelectorAll = function(selectors) {
		var style = document.createElement('style'), elements = [], element;
		document.documentElement.firstChild.appendChild(style);
		document._qsa = [];

		style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';
		window.scrollBy(0, 0);
		style.parentNode.removeChild(style);

		while (document._qsa.length) {
			element = document._qsa.shift();
			element.style.removeAttribute('x-qsa');
			elements.push(element);
		}
		document._qsa = null;
		return elements;
	};
}

/**
 * Document.querySelector method
 * Needed for: IE7-
 */
if (!document.querySelector) {
	document.querySelector = function(selectors) {
		var elements = document.querySelectorAll(selectors);
		return (elements.length) ? elements[0] : null;
	};
}


/**
 * ES-6 polyfills
 */
/**
 * Function.prototype.bind
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill}
 * Needed for: IE8-
 */
if (!Function.prototype.bind) {
	Object.defineProperty(Function.prototype, "bind", {
		value: function(oThis) {
			if (typeof this !== 'function') {
				// closest thing possible to the ECMAScript 5
				// internal IsCallable function
				throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
			}

			var aArgs   = Array.prototype.slice.call(arguments, 1),
				fToBind = this,
				fNOP    = function() {},
				fBound  = function() {
					return fToBind.apply(this instanceof fNOP
							? this
							: oThis,
						aArgs.concat(Array.prototype.slice.call(arguments)));
				};

			if (this.prototype) {
				// Function.prototype doesn't have a prototype property
				fNOP.prototype = this.prototype;
			}
			fBound.prototype = new fNOP();

			return fBound;
		},
		enumerable :false
	});
}

/**
 * Array.filter() method
 * Needed for IE8.
 */
if (!Array.prototype.filter) {
	Object.defineProperty(Array.prototype, "filter", {
		value: function (fun/*, thisArg*/) {
			'use strict';

			if (this === void 0 || this === null) {
				throw new TypeError();
			}

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun !== 'function') {
				throw new TypeError();
			}

			var res = [];
			var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
			for (var i = 0; i < len; i++) {
				if (i in t) {
					var val = t[i];

					// NOTE: Technically this should Object.defineProperty at
					//       the next index, as push can be affected by
					//       properties on Object.prototype and Array.prototype.
					//       But that method's new, and collisions should be
					//       rare, so use the more-compatible alternative.
					if (fun.call(thisArg, val, i, t)) {
						res.push(val);
					}
				}
			}

			return res;
		},
		enumerable :false
	});
}

/**
 * Array.forEach() method
 * Needed for IE8.
 */
if (!Array.prototype.forEach) {
	Object.defineProperty(Array.prototype, "forEach", {
		value: function (callback, thisArg) {
			var T, k;
			if (this == null) {
				throw new TypeError(' this is null or not defined');
			}
			var O = Object(this);
			var len = O.length >>> 0;

			if (typeof callback !== 'function') {
				throw new TypeError(callback + ' is not a function');
			}
			if (arguments.length > 1) {
				T = thisArg;
			}
			k = 0;
			while (k < len) {
				var kValue;
				if (k in O) {
					kValue = O[k];
					callback.call(T, kValue, k, O);
				}
				k++;
			}
		},
		enumerable :false
	});
}


/**
 * Array.isArray
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Polyfill}
 * Needed for: IE8-
 */
if (!Array.isArray) {
	Array.isArray = function(arg) {
		return Object.prototype.toString.call(arg) === "[object Array]";
	};
}

/**
 * Date.now
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Polyfill}
 * Needed for old browsers.
 */
if (!Date.now) {
	Date.now = function now() {
		return new Date().getTime();
	};
}

if (!String.prototype.includes) {
	Object.defineProperty(String.prototype, "includes", {
		value:function() {
			'use strict';
			return String.prototype.indexOf.apply(this, arguments) !== -1;
		},
		enumerable :false
	});
}

// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
	Object.defineProperty(Array.prototype, "includes", {
		value:function (searchElement, fromIndex) {
			// 1. Let O be ? ToObject(this value).
			if (this == null) {
				throw new TypeError('"this" is null or not defined');
			}

			var o = Object(this);

			// 2. Let len be ? ToLength(? Get(O, "length")).
			var len = o.length >>> 0;

			// 3. If len is 0, return false.
			if (len === 0) {
				return false;
			}

			// 4. Let n be ? ToInteger(fromIndex).
			//    (If fromIndex is undefined, this step produces the value 0.)
			var n = fromIndex | 0;

			// 5. If n â‰¥ 0, then
			//  a. Let k be n.
			// 6. Else n < 0,
			//  a. Let k be len + n.
			//  b. If k < 0, let k be 0.
			var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

			function sameValueZero(x, y) {
				return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
			}

			// 7. Repeat, while k < len
			while (k < len) {
				// a. Let elementK be the result of ? Get(O, ! ToString(k)).
				// b. If SameValueZero(searchElement, elementK) is true, return true.
				// c. Increase k by 1.
				if (sameValueZero(o[k], searchElement)) {
					return true;
				}
				k++;
			}

			// 8. Return false
			return false;
		},
		enumerable :false
	});
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

	Object.defineProperty(Array.prototype, "map", {
		value:function(callback/*, thisArg*/) {

			var T, A, k;

			if (this == null) {
				throw new TypeError('this is null or not defined');
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			//    value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal
			//    method of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0;

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if (typeof callback !== 'function') {
				throw new TypeError(callback + ' is not a function');
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
			if (arguments.length > 1) {
				T = arguments[1];
			}

			// 6. Let A be a new array created as if by the expression new Array(len)
			//    where Array is the standard built-in constructor with that name and
			//    len is the value of len.
			A = new Array(len);

			// 7. Let k be 0
			k = 0;

			// 8. Repeat, while k < len
			while (k < len) {

				var kValue, mappedValue;

				// a. Let Pk be ToString(k).
				//   This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty internal
				//    method of O with argument Pk.
				//   This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					//    method of O with argument Pk.
					kValue = O[k];

					// ii. Let mappedValue be the result of calling the Call internal
					//     method of callback with T as the this value and argument
					//     list containing kValue, k, and O.
					mappedValue = callback.call(T, kValue, k, O);

					// iii. Call the DefineOwnProperty internal method of A with arguments
					// Pk, Property Descriptor
					// { Value: mappedValue,
					//   Writable: true,
					//   Enumerable: true,
					//   Configurable: true },
					// and false.

					// In browsers that support Object.defineProperty, use the following:
					// Object.defineProperty(A, k, {
					//   value: mappedValue,
					//   writable: true,
					//   enumerable: true,
					//   configurable: true
					// });

					// For best browser support, use the following:
					A[k] = mappedValue;
				}
				// d. Increase k by 1.
				k++;
			}

			// 9. return A
			return A;
		},
		enumerable :false
	});
}
// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
	Object.keys = (function() {
		'use strict';
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function(obj) {
			if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [], prop, i;

			for (prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (i = 0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	}());
}

/**
 *  Unified method to get element from parent document
 * @param {String} Id of the  dom element
 * @param {*} document element to fetch the element from
 * @returns {*}
 */
    function getParentPageElById(id, doc) {
		if(doc == window.parent.document) {
			return getParentElByIDTFacade(id);
		}
		return document.getElementById(id);
	}

	/**
	 * Logs provided string to browser console.
	 * Regards JSLoggingDisabled switch set in Admin.
	 * @param {string} s string to log
	 * @param {string?} severity Logging level, one of "log", "error", "warn", "info", "debug", "trace"
	 */
	function log(s, severity) {
		if (!JSLoggingDisabled) {
			if (typeof console != "undefined") {
				if (typeof severity != "string") {
					severity = "log";
				} else {
					severity = severity.toLowerCase();
				}
				if (console[severity]) { // if not defined, fallback to console.log()
					// Note, the Chrome browser requires "this" to be the "window.console" object.
					// This requirement is fulfilled since this function is global.
					console[severity](s);
				} else if (console.log) {
					console.log(severity.toUpperCase() + ": " + s);
				}
			}
		}
	}

	/**
	 * Check is c2c to persistent is set for site
	 * @param {Boolean} siteC2P site option from Portal settings
	 * @return {Boolean}
	 */
	function isC2PActive(siteC2P){
		if(inu1(siteC2P)){
			throw new Error("siteC2P parameter missing");
		}
		var chatData = CHM.getChatData().getChatData();
		if (!!chatData && !inu1(chatData['c2cToPersistent'])) {
			return chatData['c2cToPersistent'];
		}
		return siteC2P;
	}

	/**
	 * Fires custom event. Custom events are declared in business/program rules
	 * @param {String} eventName
	 * @param {Object} data event data
	 * @param {Rule=} rule
	 */
	function fireCustomEvent(eventName, data, rule) {
		try {
			EVM.fireCustomEvent(eventName, rule, data);
		} catch (err) {
			let12("External custom event(" + eventName + ") fire failure:" + cf21(err));
		}
	}

/**
 * Sends error message to TS. Regards JSLoggingDisabled switch set in Admin.
 * @param {string} errMsg - message to be logged in TS log as an error.
 * @param {=boolean} addLoggingContext - if true then add the context(@see {@link plc1})
 */
	function let12(errMsg, addLoggingContext) {
		lmt12(errMsg, LOG_LEVELS.ERROR, null, addLoggingContext);
	}

	/**
	 * Sends warn message to TS. Regards JSLoggingDisabled switch set in Admin.
	 * @param {string} warnMsg - message to be logged in TS log as a warn.
	 */
	function lwt12(warnMsg) {
		lmt12(warnMsg, LOG_LEVELS.WARN, null, true);
	}

	/**
	 * Sends info message to TS.
	 * @param {string} message - message to be logged in TS log as an info.
	 */
	function logInfoToTagServer(message) {
		lmt12(message, LOG_LEVELS.INFO, null, true);
	}

	/**
	 * Sends info message to TS and debug to console.
	 * Info should be sent to TS, instead of debug, because debug could be
	 * disabled on server. Our logs shouldn't be to depend on server log settings.
	 *
	 * @param {string} message - message to be logged in TS log as an info.
	 */
	function logDebugToTagServer(message) {
		lmt12(message, LOG_LEVELS.INFO, null, true, LOG_LEVELS.DEBUG);
	}

	/**
	 * Sends error which occurs on execution ROM.post function to TS.
	 *
	 * Should be used only by postToServer realisation (LR45),
	 * for other cases CORS requests should be used.
	 */
    function logErrorInPostToTagServer(errMsg) {
        log(errMsg, LOG_LEVELS.ERROR);
		ROM.postToServer(urls.logJsPostURL, {level: LOG_LEVELS.ERROR, line: trimMsg(errMsg)});
    }

	/**
	 * // TODO should be deleted when all clients will use CORS requests to TS
	 * Sends WARN which occurs on execution ROM.post function to TS.
	 *
	 * @param {string} warnMsg message to be logged in TS log as an warning.
	 */
	function logWarnInPostToTagServer(warnMsg) {
		log(warnMsg, LOG_LEVELS.WARN);
		ROM.postToServer(urls.logJsPostURL, {level: LOG_LEVELS.WARN, line: trimMsg(warnMsg)});
	}

/**
 * Sends message to TS. Regards JSLoggingDisabled switch set in Admin.
 * @param {string} msg message to be logged in TS log as an error.
 * @param {=string} logLevel log level type
 * @param {=function} callback - callback function
 * @param {=boolean} addLoggingContext - if true then add the context(@see {@link plc1})
 * @param {=string} consoleLogLevel - log level for console logs
 */
	function lmt12(msg, logLevel, callback, addLoggingContext, consoleLogLevel) {
		if (msg) {
			if (addLoggingContext) {
				msg = plc1(msg);
			}
			if (!consoleLogLevel) {
				consoleLogLevel = logLevel;
			}
			log(msg, consoleLogLevel);
			ROM.post(urls.loggingURL, {level: logLevel, line: trimMsg(msg)}, null, false, callback);
		}
	}

	/**
	 * Log level string constants
	 * @type {{FATAL: "FATAL", ERROR: "ERROR", WARN: "WARN", INFO: "INFO", DEBUG: "DEBUG"}}
	 */
	var LOG_LEVELS = {
		FATAL : "FATAL",
		ERROR : "ERROR",
		WARN : "WARN",
		INFO : "INFO",
		DEBUG : "DEBUG"
	};

	/**
	 * Log level number constants
	 * @type {{FATAL: number, ERROR: number, WARN: number, INFO: number, DEBUG: number}}
	 */
	var JS_LOG_LEVELS = {
		FATAL : 5,
		ERROR : 4,
		WARN : 3,
		INFO : 2,
		DEBUG : 1
	};

	/**
	 * This method is to check weather or not the value passed is valid log level
	 *
	 * @param {string} value - Log level value.
	 * @return {Boolean}
	 */
	function isValidLogLevel(value) {
		for (var logLevel in LOG_LEVELS)
			if (LOG_LEVELS[logLevel] == value) return true;
		return false;
	}

	/**
	 * Check if base JS functionality work as expected.
	 * In some cases we will catch errors if some base constructors(for example URL)
	 * was redefined on client side.
	 * In case we catch error we should stop CI work.
	 * @returns {boolean}
	 */
	function isValidBaseFunctionality() {
		try {
			validateUrlConstructor();
		} catch (e) {
			/*
			 * postToServer can't be used here for log, because at this time
			 * it wasn't created. If url constructor don't work as expected,
			 * postToServer couldn't be created because of wrong work with URL.
			 *
			 * CORS requests could be used instead of form, so in the future
			 * logWarnInPostToTagServer could be replaced on lwt12
			 */
			logWarnInPostToTagServer(
				"Chat can't be started because of " + e + " SiteId: " + getSiteID()
				+ " URL: " + location.href.split("?")[0]
				+ " userAgent: " + window.navigator.userAgent
			);
			return false;
		}
		return true;
	}

	/**
	 * Check is new URL returns valid object and generate error in case invalid URL constructor.
	 */
	function validateUrlConstructor() {
		// This situation could be in IE browsers
		// We should stop function work if URL doesn't have constructor because in this case we will use customParseUrl function
		if (typeof URL !== "function") {
			return;
		}
		var testUrl = "https://test-url.nuance.com/test";
		var url = new URL(testUrl);
		if (
			url.hash === undefined
			|| url.host === undefined
			|| url.hostname === undefined
			|| url.href === undefined
			|| url.origin === undefined
			|| url.password === undefined
			|| url.pathname === undefined
			|| url.port === undefined
			|| url.protocol === undefined
			|| url.search === undefined
			|| url.username === undefined
			|| typeof url.searchParams !== "object"
		) {
			throw("Invalid URL constructor.");
		}
	}

	/**
	 * This function is to send log data to server based on the Log Level defined in the Rules.
	 *
	 * At Program Rules level by default the JS_LOG_LEVEL is set to "ERROR".
	 * We can override it at Business Rules level if we want to change the log level for a site
	 * to debug an issue specific to that site. For anything JSLogging should be enabled in portal.
	 *
	 * JS_LOG_LEVEL defined in the rules is specific to weather or not we need to post the message to the server.
	 *
	 * @param {string} msg
	 * @param {string} [msgLogLevel= LOG_LEVELS.INFO] msgLogLevel requested for the message, if not defined default to LOG_LEVELS.INFO
	 * @param {string} [svrLogLevel=msgLogLevel] if defined, will write msg to server at a different log level than locally written
	 */
	function sendMessageToTagServer(msg,msgLogLevel,svrLogLevel) {
		log(msg);

		if (!JSLoggingDisabled) {

			// if message log level is not passed or is not a valid log level, default to INFO.
			if (inu1(msgLogLevel) || !isValidLogLevel(msgLogLevel)) {
				msgLogLevel = LOG_LEVELS.INFO;
			}

			// if server log level is not passed, or is not valid log level, apply the message log level defined.
			if (inu1(svrLogLevel) || !isValidLogLevel(svrLogLevel)) {
				svrLogLevel=msgLogLevel;
			}

			//if the log level defined in the message is >= log level defined in the Rules, Post the message.
			if (JS_LOG_LEVELS[msgLogLevel] >= JS_LOG_LEVELS[gc7("JS_LOG_LEVEL")]) {
				ROM.post(urls.loggingURL, {level: svrLogLevel, line: trimMsg(msg)});
			}
		}
	}

	/**
	 * Logs a rule action error. An error may occur at evaluation of rule condition or execution of rule actions.
	 * Sends error details to TS.
	 * Regards JSLoggingDisabled switch set in Admin.
	 * @param e error to report
	 * @param rule error to report
	 * @param {string} [msg] message to send and display. Prepended to message
	 */
	function logActionErr(e, rule, msg) {
		var errMsg = cf21(e);
		var errStr = "Error in " + rule + (inu1(msg) ? "." : (" msg=" + msg));
		log(errStr + " ChatID = " + CHM.getChatID() + ". CustomerID = " + getCustID());
		let12(errStr + " \n" + errMsg);
	}

	/**
	 * Checks if current window if persistent chat window even if window.parent.name is not defined
	 * @return {boolean}
	 */
	function isPersistentWindow() {
		try {
			if ((window.parent.name == "_inqPersistentChat" || (win.location.hostname + win.location.pathname === location.hostname + location.pathname)) && !isCEAPIPostChatSurveyMode()) {
				return true;
			}
		} catch (err) {
			return false;
		}
	}

	/**
	 * Generates random number from interval
	 * @param low lowest value
	 * @param high highest value
	 * @param roundToNearestIntegerFlag
	 * @return {number}
	 */
	function rand(low, high, roundToNearestIntegerFlag) {
		if (high < low) {
			throw ("Incorrect bounds for random generator: low = " + low + ", high = " + high);
		}
		var delta = high - low;
		var res = (!!roundToNearestIntegerFlag)?(Math.floor(Math.random()*(delta+1))+low):(Math.random() * delta + low);
		return res;
	}

	/**
	 * Returns type of passed value. Supports "array" and "null" as types
	 * @param value
	 * @return {string}
	 */
	function typeOf(value) {
		var s = typeof value;
		if (s === 'object') {
			if (value) {
				if (typeof value.length === 'number' &&
					!(value.propertyIsEnumerable('length')) &&
					typeof value.splice === 'function') {
					s = 'array';
				}
			} else {
				s = 'null';
			}
		}
		return s;
	}

	/**
	 * Obtains a list of dom elements by class name they sport. Given a node, it will iterate
	 * through all children of that node and collecting those sporting the given class name.
	 * @param classname {string} The name of the class to seek.
	 * @param node The node on which to start the search. If undefined or null, the document
	 * body is chosen for the resolved window context is chosen by default.
	 * @param winCtxt The document window in which to search.
	 * If undefined or null, the globally defined "win" context is chosen by default.
	 * @return {Array} array of dom elements found. May be empty, never null.
	 */
	function getElementsByClassName(classname, node, winCtxt) {
		if(!node){
			winCtxt = !!winCtxt?winCtxt:win;
			node = winCtxt.document.getElementsByTagName("body")[0];
		}
		var a;
		if (node.getElementsByClassName) {
			a = node.getElementsByClassName(classname);
		} else {
			// Fallback for old browsers like IE8
			a = [];
			var re = new RegExp('\\b' + classname + '\\b');
			var els = node.getElementsByTagName("*");
			for (var i = 0, j = els.length; i < j; i++) {
				if (re.test(els[i].className)) {
					a.push(els[i]);
				}
			}
		}
		return a;
	}

	/**
	 * Determines if an expression or an expression wrapped in a function evaluates safely
	 * to null or undefined.
	 * @param o the function or expression to be evaluated. Function must wrap
	 * and return the expression to be evaluated.
	 * @param dfltOnError {boolean} value to be returned if the expression evaluation results
	 * in an error.
	 * @param logOnError {boolean} if true, will log on evaluation error
	 * @return {boolean} true if function expression evaluates to anything other
	 * than null or undefined. Returns false if safely evaluates to null or undefined. If error
	 * in evaluation, returns dfltOnError.
	 */
	function e9(o, dfltOnError, logOnError) {
		try {
			var val = o;
			if (typeof o == "function") {
				val = o();
			}
			return ((typeof val != "undefined") && (val != null));
		} catch (err) {
			if (!!logOnError) {
				logActionErr(err, rule, "JS eval error on expression " + o.toString());
			}
			return dfltOnError;
		}
	}

	/**
	 * Returns true if passed parameter is null or undefined.
	 * @param {*} val any object or variable
	 * @return {boolean} true if passed parameter is null or undefined
	 */
	function inu1(val) {
		return val == null || typeof(val) == "undefined";
	}

	/**
	 * Check if current browser is IE
	 * @return {boolean} true if IE
	 */
	function isIE() {
		return window.navigator.appName == "Microsoft Internet Explorer" || window.navigator.userAgent.indexOf("Trident") >= 0;
	}

	/**
	 * Check if current browser is FF
	 * @return {boolean} true if FF
	 */
	function isFF() {
		return window.navigator.userAgent.indexOf("Firefox") >= 0;
	}

	/**
	 * Check if current OS is iOS
	 * @return {boolean} true if OS is iOS
	 */
	function isIOS() {
		return /(iPad|iPhone|iPod)/g.test( window.navigator.userAgent );
	}

	/**
	 * Check if current OS is iOS 9
	 * @return {boolean} true if OS is iOS
	 */
	function isIOS9() {
		return /(iPad|iPhone|iPod).*OS 9/i.test( window.navigator.userAgent );
	}

	/**
	 * Check if current browser is Opera
	 * @return {boolean} true if Opera
	 */
	function isOpera() {
		return window.navigator.userAgent.indexOf("Opera") >= 0;
	}

	/**
	 * Check if current browser is Chrome
	 * @return {boolean} true if Chrome
	 */
	function isChrome() {
		return (window.navigator.userAgent.indexOf("Chrome") >= 0 || window.navigator.userAgent.indexOf("CriOS") >= 0)
				&& !isAndroidWebView()
				&& (!isEdge()); // navigator.userAgent for Edge have "Chrome" inside the value
	}

	/**
	 * isAndroid WebView
	 * below link tell how to detect webView useragent
	 * @see https://developer.chrome.com/multidevice/user-agent
	 * @see com.inq.utils.Capabilities.isAndroidWebView
	 * @return {boolean}
	 */
	function isAndroidWebView() {
		var pattern = new RegExp("Android.*?(wv|Version\\/[.0-9]+).*?Chrome\\/[0-9]{2}", "i");
		return pattern.test(window.navigator.userAgent);
	}

	/**
	 * returns the inteface object added by ios native code to webview window instance
	 * @returns {null | Object}
	 */
	function getIOSNativeSDKInstance() {
		if (isWebSDK) {
			return;
		}
		var wk = window.parent.webkit;
		return wk && wk.messageHandlers && wk.messageHandlers.NuanIJSFBridge;
	}

	function getFormInIOSSDKInstance() {
		if (isWebSDK) {
			return;
		}
		var wk = window.parent.webkit;
		return  wk && wk.messageHandlers && wk.messageHandlers.NuanSurvey;
	}

	function getPostSurveyInIOSSDKInstance() {
		if (isWebSDK) {
			return;
		}
		var wk = window.parent.webkit;
		return  wk && wk.messageHandlers && wk.messageHandlers.NuanPCSurvey;
	}
	/**
	 * Check if current browser is Safari.
	 * @return {boolean} true if Safari.
	 */
	function isSafari() {
		return (window.navigator.userAgent.indexOf("Safari") >= 0 || isIOSWebView())
				&& (!isChrome()) && (!isEdge()); // navigator.userAgent for Chrome and Edge have "Safari" inside the value
	}

	/**
	 * Checks if it is iOsWebView
	 * On mobile devices it should work as Safari and browser type should be also as Safari
	 * @return {Boolean}
	 */
	function isIOSWebView () {
var pattern = new RegExp("(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)", "i");
		return pattern.test(window.navigator.userAgent) || isIPadWebViewInDesktopMode();
	}

	/**
	 * keyword Macintosh is present only for mac desktop machines,
	 * in case of ipad which is in desktop mode has Macintosh keyword
	 * Keyword AppleWebKit is present only for safari and chrome browsers, both this browsers has Safari keyword also
	 * @return {Boolean}
	 */
	function isIPadWebViewInDesktopMode() {
		var pattern = new RegExp("(Macintosh).*AppleWebKit(?!.*Safari)", "i");
		return pattern.test(window.navigator.userAgent) && (!isChrome());
	}
	/**
	 * Check if current browser is Edge.
	 * @return {boolean} true if Edge.
	 */
	function isEdge() {
		return window.navigator.userAgent.indexOf("Edge") >= 0
			|| window.navigator.userAgent.indexOf("Edg") >= 0;
	}

	/**
	 * Checks that device type returning from the Tag Server is match to one of the following:
	 *  - Phone
	 *  - Tablet
	 * @see LandingFramework.js function d8t
	 * @return {boolean}
	 */
	function isMobileDevice() {
		return d8t("Phone") || d8t("Tablet");
	}

	/**
	 * Returns abbreviated browser type IJSF is currently running in: one of CHROME, OPERA, SAFARI, IE, FF, EDGE.
	 * @return {string} browser type. If browser is not supported no value is returned.
	 */
	function getClientBrowserType() {
		if (isIE()) {
			return "IE";
		} else if(isEdge()) {
			return "EDGE";
		} else if(isFF()) {
			return "FF";
		} else if(isChrome()) {
			return "CHROME";
		} else if(isOpera()) {
			return "OPERA";
		} else if(isSafari()) {
			return "SAFARI";
		} else {
			return "OTHER";
		}
	}


	/**
	 * Returns array includes browser name and version
	 * original solution found http://stackoverflow.com/questions/5916900/detect-version-of-browser
	 * @return {string[]} Browser name and version in array, for example ["Firefox","16.0"]
	 */
	function getBrowserTypeAndVersion() {
		var nvg = window.navigator.appName;
		var userAgt = window.navigator.userAgent;
		var temp;
		var matches = userAgt.match(/android(?!.*chrome)/i);
		if (matches && (temp = userAgt.match(/version\/([\.\d]+)/i)) != null) {
			matches = ["Android Browser", temp[1]];
		} else {
			matches = userAgt.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
			if (matches && (temp = userAgt.match(/version\/([\.\d]+)/i)) != null) {
				matches[2] = temp[1];
			}
			//check for Edge
			if (userAgt.indexOf("Chrome") >= 0 && (temp = userAgt.match(/(edge|edg)\/?\s*(\.?\d+(\.\d+)*)/i))) {
				matches[1] = temp[1];
				matches[2] = temp[2];
			}
			matches = matches ? [matches[1], matches[2]] : [nvg, window.navigator.appVersion, '-?'];
		}
		return matches;
	}

	/**
	 * Returns client browser version
	 * @return {string} Returns browser version as string. for example "16.0"
	 */
	function cbtv1(){
		var browserTypeAndVersion = getBrowserTypeAndVersion();
		var ua = window.navigator.userAgent;
		if(ua.indexOf("Trident") >= 0) {
			var matches= ua.match(/(trident)\/?\s*(\.?\d+(\.\d+)*)/i);
			var tridentVersion = new Number(matches[2]);
			if (tridentVersion >= 4) {
				return (tridentVersion + 4) + ".0";
			}
		}
		return browserTypeAndVersion[1];
	}

	/**
	 * 	Takes 2 strings "2.3.4.5" and "2.5" and returns less, equal and greater than 0
	 * depending which one is bigger.
	 * Taken from http://stackoverflow.com/questions/2802993/compare-browser-versions-via-javascript/9116381
	 */
	function compareVersions(a, b) {
		var v1 = a.split('.');
		var v2 = b.split('.');
		for(var i = 0; i < Math.min(v1.length, v2.length); i++) {
			var res = v1[i] - v2[i];
			if (res != 0)
				return res;
		}
		return 0;
	}

	/**
	 * Returns client operating system type
	 * @return {string} Returns OS type as string.
	 */
	function getOSType() {
		var os = "Unknown";
		var platform = window.navigator.platform;
		var ua = window.navigator.userAgent;

		if (/Android/.test(ua)) {
			os = "Android";
		} else if (/iPhone/.test(ua) || /iPad/.test(ua) || /iPod/.test(ua)) {
			os = "iOS";
		} else if (/Win/.test(platform)) {
			os = "Windows";
		} else if (/Linux/.test(platform)) {
			os = "Linux";
		} else if (/Mac/.test(platform)) {
			os = "Mac OS";
		}

		return os;
	}

	/**
	 * Returns the string with os type, name of client browser and its version.
	 * @return {string} os type, name of client browser and its version
	 */
	function getFullBrowserInfo() {
		return getOSType() + " " + getClientBrowserType() + " " + cbtv1();
	}

	/**
	 * Returns browser major version.
	 * Note: Now used only to determine cookie limits and thus supports only IE browsers as only IE has different
	 * limits in different versions IJSF supports.
	 * @return {number} browser major version or 0 if unable to detect.
	 */
	function getBrowserMajorVer(compatibilityOnly) {
		var ver = 0;
		if (isIE()) {
			var ua = window.navigator.userAgent;
			var tridentInd = ua.indexOf("Trident");
			//IE8 and older
			if (tridentInd >= 0) {
				ver = parseInt(ua.substring(tridentInd + 8)) + 4;
			} else {
				//old IE
				var ind = ua.indexOf("MSIE ");
				ver = parseInt(ua.substring(ind + 5));
			}
			if (compatibilityOnly) {
				if (document.documentMode && document.documentMode < ver) {
					ver = document.documentMode;
				}
			}
		}
		return ver;
	}

	/**
	 * As documented on Confluence: {@link https://confluence.touchcommerce.com/display/dev/Cookie+size+limits}
	 */
	var COOKIE_SIZE_LIMITS = {
		"IE8": 5118,
		"IE9": 5118,
		"IE10" : 5118,
		"IE11" : 5118,
		"FF": 4097,
		"SAFARI": 4093,
		"CHROME": 4095,
		"OTHER" : 4093
	};

	/**
	 *  As documented on Confluence: {@link https://confluence.touchcommerce.com/display/dev/Cookie+size+limits}
	 */
	var COOKIE_TOTAL_SIZE_LIMITS = {
		"IE8": 10236,
		"IE9": 10236,
		"IE10" : 10236,
		"IE11" : 10236,
		"FF": 614550,
		"SAFARI": 8186,
		"CHROME": 732280,
		"OTHER" : 8186
	};

	/**
	 * Returns cookie size limit for current browser.
	 * @return {number} cookie size limit for current browser or 0 if limit is not defined for current browser.
	 */
	function csl11() {
		var browserType = getClientBrowserType();
		var limit = COOKIE_SIZE_LIMITS[browserType];
		if (inu1(limit)) {
			limit = COOKIE_SIZE_LIMITS[browserType + getBrowserMajorVer()];
		}
		return limit;
	}

	/**
	 * Returns total cookie size limit (per domain) for current browser.
	 * @return {number} total cookie size limit (per domain) for current browser.
	 */
	function ctl12() {
		var browserType = getClientBrowserType();
		var limit = COOKIE_TOTAL_SIZE_LIMITS[browserType];
		if (inu1(limit)) {
			limit = COOKIE_TOTAL_SIZE_LIMITS[browserType + getBrowserMajorVer()];
		}
		return limit;
	}

	/**
	 * Logging is ambiguous on the TS without chatID, custID, siteID etc.
	 * This function makes log message meaningful by adding context variables to the message.
	 * Pass in the chatID, custID, custIP, siteID, pageID only when needed, i.e. when
	 * Inq, CHM LDM are not initialized.
	 *
	 * @param {string} msg message string to be supplemented with context data
	 * @param {string=} chatID engagementID or null
	 * @param {string=} custID customerID or null
	 * @param {string=} custIP customer IP or null
	 * @param {string=} siteID siteID or null
	 * @param {string=} pageID pageID or null
	 * @param {number=} windowID windowID or null
	 *
	 * @return {string} message string supplemented with context data such as customer id etc
	 */
	function plc1(msg, chatID, custID, custIP, siteID, pageID, windowID) {
		var result = msg;
		if (!result) result = "";
		result += " ";
		var o = {};
		try {o["chatID"] = inu1(chatID) ? ("" + CHM.getChatID()) : chatID} catch(e){}
		try {o["custID"] = inu1(custID) ? getCustID() : custID} catch(e){}
		try {o["custIP"] = inu1(custIP) ? getCustIP() : custIP} catch(e){}
		try {o["siteID"] = inu1(siteID) ? getSiteID() : siteID} catch(e){}
		try {o["pageID"] = inu1(pageID) ? LDM.getPageID() : pageID} catch(e){}
		try {o["windowID"] = inu1(windowID) ? CHM.getWindowId() : windowID} catch(e){}
		o["codeVersion"] = v3Lander.codeVersion;
		for (var itm in o) {
			try {
				result += itm + ": " + o[itm] + "; ";
			} catch (e) {
				// formatArgument - Formats the argument into a somewhat readable format
				result += itm + ": " + formatArgument(o[itm]) + "; ";
			}
		}
		return result;
	}

	/**
	 * Formats error for logging. Adds parameters and stack trace
	 * @param err
	 * @return {String}
	 */
	function cf21(err) {
		try {
			var desc = "\t";
			if (err && err.message) {
				desc += err.message + ". ";
			} else {
				desc += "Throw while processing. ";
			}
			desc += plc1();
			desc += "\n\t" + getStackTrace(err);
			return encodeURIComponent(desc);
		} catch (e) {
			return "";
		}
	}

	/**
	 * Parses url and returns params
	 *
	 * @param {string} url
	 * @returns {Object}
	 */
	function getParamsFromURL(url) {
		/** @type {Object} */
		var params = {};

		if (typeof url === "string") {
			/** @type {number} */
			var startIndex = url.indexOf('?');

			if (startIndex >= 0) {
				/** @type {Array.<string>} */
				var paramsArray = url.slice(startIndex + 1).split('&');
				/** @type {Array.<string>} */
				var keyValuePair;

				for (var i = 0;  i < paramsArray.length; i++) {
					keyValuePair = paramsArray[i].split('=');
					params[keyValuePair[0]] = keyValuePair[1];
				}
			}
		}

		return params;
	}

	/**
	 * Evaluates the code and don't throw errors on higher level
	 * @param id code to eval
	 * @param dflt default data to return on error
	 * @param sendErrorToTagServer log error message on Tag Server if true
	 * @return {*}
	 */
	function s7(id, dflt, sendErrorToTagServer) {
		if (id) {
			try {
				var o = evaluateLegacySettings(id, win);
				return safeResult(o);
			} catch (err) {
				if (sendErrorToTagServer) {
					let12(cf21(err));
				}
			}
		}
		return dflt;
	}

	/**
	 * Returns value of the passed variable from the parent window
	 *
	 * @param {string} name - variable name
	 * @return {*}
	 */
	function getDataFromParentByName(name) {
		try {
			return safeResult(win[name]);
		} catch (err) {
			let12(cf21(err), false);
		}
	}

	function safeResult(o) {
				if (inu1(o)) {
					return o;
				} else if (typeOf(o) == "array") {
					return Array.clone(o);
				} else if (o.getTime) { // Date marker check
					if (!o.equals) { // a check to make sure that not yet mixed in
						MI8.prepare(o).im13(DateMixIn);
					}
				} else if (o.toExponential) { // Number marker check
					if (!o.inRange) { // a check to make sure that not yet mixed in
						MI8.prepare(o).im13(NumberMixIn);
					}
				}

				return o;
	}

	/**
	 * Function to compare the objects
	 * obj1 and obj2 parameters may be any type, because initial objects may have deep nesting
	 * so we need to check all internal objects prop
	 * @param {*} obj1
	 * @param {*} obj2
	 * @return {boolean}
	 */
	function objectEquals(obj1, obj2) {
		if (typeof(obj1) !== typeof(obj2)) {
			return false;
		}
		if (typeof(obj1) === "function") {
			return obj1.toString() === obj2.toString();
		}
		if (obj1 instanceof Object && obj2 instanceof Object) {
			if (countProps(obj1) !== countProps(obj2)) {
				return false;
			}
			/** @type {boolean} we use this var because we need to recursively check all internal objects props*/
			var flag = true;
			for (var key in obj1) {
				flag = objectEquals(obj1[key], obj2[key]);
				if (!flag) {
					return false;
				}
			}
			return true;
		} else {
			return obj1 === obj2;
		}

		function countProps(obj) {
			var count = 0;
			for (var prop in obj) {
				if (obj.hasOwnProperty(prop)) {
					count++;
				}
			}
			return count;
		};
	}

	function processReceivedExternalDataThrows(id, dflt) {
		return s7(id, dflt, true);
	}

	/**
	 * Returns true if supplied object is an empty object i.e. {}.
	 */
	function isEmptyObject(obj){
		for(var i in obj) { return false;}
		return true;
	}

	/**
	 * Replaces protocol to HTTPS
	 * @param url
	 * @return {String}
	 */
	function secureProtocol(url) {
		var URL_REGEXP_IS_CONTAINS_PROTOCOL = new RegExp("^[0-9A-z\\.\\+\\-]*:|^//");
		if (url == null || url.length == 0) {
			return url;
		}

		url = url.trim();
		if (url.match(URL_REGEXP_IS_CONTAINS_PROTOCOL)) {
			return url.replace(/^HTTPS?:/i, "https:");
		} else {
			return "https://" + url;
		}
	}

	/**
	 * Modifies protocol of url from HTTP to HTTPS
	 * @param {string} httpURL which has to be processed
	 * @return {string} url will be returned with HTTPS protocol
	 */
	function secureHTTP(httpURL) {
		return httpURL ? httpURL.replace(/^http:/i, "https:") : httpURL;
	}

	/**
	 * Returns object as key,value;key,value sequence
	 * @param {Object} obj JSON object to process
	 * @param {boolean=} encodingRequired flag to use URL encoding for data
	 * @return {string} string of appropriate format
	 */
	function objectAsLogString(obj, encodingRequired) {
		if (!obj) {
			return null;
		}
		var string = "";
		for (var a in obj) {
			if (!inu1(obj[a]) && obj[a] !== "") {
				var encodedPair = encodingRequired ? encodeURIComponent(a) + "," + encodeURIComponent(obj[a]) : a + "," + obj[a];
				string += !!string ? ";" + encodedPair : encodedPair;
			}
		}
		return string;

	}

	/** productionFilter
	 * Filters the hosted file list for production and non production.
	 *
	 * RTDEV-8345
	 *	First Party Cookie Solution Does Not Work on Non-Public Domains
	 *	Make the filter a list of filters that can test independent internal sites called "silos"
	 * TODO: split these regular expressions into separate database entries, do not like comma deliminated
	 *
	 * @param {string} hostedFileList
	 * @param {string} _productionFilter
	 * @return {string}
	 */
	function productionFilter(hostedFileList, _productionFilter){
		if (_productionFilter) {
			var filters = _productionFilter.split(","); /* The filter is now a list of filters delimited by commas */

			var listItems = hostedFileList.split(",");
			var filteredListItems = [];
			var regexProduction = new RegExp(filters[0], "i");	/* The first filter is for production URLs */
			var production = regexProduction.test(isWebSDK ? window.pageUrl : inqFrame.parent.location.href);//inqFrame.parent.location.href.match(regexProduction);

			if (production) {
				for (var i = 0; i < listItems.length; i++) {
					var item = listItems[i];
					if (regexProduction.test(item)) {
						filteredListItems.push(item);
					}
				}
				return filteredListItems.join(",");
			} else if (filters.length > 1) { /* The production filter failed so we will check for each group (silo) */
				/* The filter code below is the similar as the filter code above, for production
				 * The difference is that we filter production and silo urls into the list
				 */

				/* Added "Walled Garden" support where the sites in the garden can coexist but the production references would be filtered out
				 * So ... if prefixed with a minus sign we realise that this is a walled garden and we leave out production list
				 */
				var /** @type {boolean} */ walledGarden;
				var /** @type {string} */ filter;
				for (i = 1; i < filters.length; i++) {
					filter = filters[i];
					walledGarden = filter.indexOf("-") == 0;
					var regexSilo = new RegExp((walledGarden)?filter.substr(1):filter, "i");
					var silo = regexSilo.test(isWebSDK ? window.pageUrl : inqFrame.parent.location.href);
					if (silo) {
						for (i = 0; i < listItems.length; i++) {
							var item = listItems[i];
							if (regexSilo.test(item) || (!walledGarden && regexProduction.test(item))) {
								filteredListItems.push(item);
							}
						}
						return filteredListItems.join(",");
					}
				}
			}
		}
		return hostedFileList;
	}

	/**
	 * Public function
	 * Attaches the listener of event on the target element.
	 *
	 * Usage: attachListener(window, "load", Inq.start);
	 *
	 * @param {DOMElement|Window} target
	 * @param {string} type
	 * @param {function} listener
	 * @param {boolean} useCapture
	 */
	function attachListener(target, type, listener, useCapture) {
		if (!useCapture) {
			// Prior to Firefox 6, the browser would throw an error
			// if the useCapture parameter was not explicitly false.
			useCapture = false;
		}
		if (target.addEventListener) {
			target.addEventListener(type, listener, useCapture);
		} else if (target.attachEvent) {
			target.attachEvent("on" + type, listener);
		}
	}

	/**
	 * Public function
	 * Removes the event listener previously registered with attachListener()
	 *
	 * Usage: detachListener(window, "load", Inq.start);
	 *
	 * @param {DOMElement|Window} target
	 * @param {string} type
	 * @param {function} listener
	 * @param {boolean} useCapture
	 */
	function detachListener(target, type, listener, useCapture) {
		if (!useCapture) {
			// Prior to Firefox 6, the browser would throw an error
			// if the useCapture parameter was not explicitly false.
			useCapture = false;
		}
		if (target.removeEventListener) {
			target.removeEventListener(type, listener, useCapture);
		} else if (target.attachEvent) {
			target.detachEvent("on" + type, listener);
		}
	}

	/**
	 * Returns result of the specified method on the first non-null object in the sequence, which has this method
	 * @param {String} method name of method to be called
	 * @return {*} result of method call
	 */
	function firstExisting(method) {
		for (var i = 1; i < arguments.length; i++) {
			var obj = arguments[i];
			if (obj && obj[method]) {
				return obj[method].call(obj);
			}
		}
		return null;
	}

    /**
     * Return the default value if the given value is null, otherwise return the given value.
     * @param val
     * @param def
     * @returns {*}
     */
    function getDefaultValueIfNull(val, def) {
        return inu1(val)?def:val;
    }

	/**
	 * Function detects whether localStorage is both supported and available.
	 * @param {string} type - "localStorage" or "sessionStorage"
	 * @returns {boolean}
	 */
	function storageAvailable(type) {
		try {
			var storage = window[type];
			var x = '__storage_test__';
			storage.setItem(x, x);
			var result = storage.getItem(x) == x;
			storage.removeItem(x);
			return !!storage && result;
		} catch(e) {
			return false;
		}
	}

	/**
	 * Find if element is in viewport
	 *     http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
	 *
	 * @param el
	 * @returns {boolean}
	 */
	function isElementInViewport (el) {
		if(!el) return false;

		var rect = el.getBoundingClientRect();
		var vpHeight = window.top.innerHeight;
		var vpWidth = window.top.innerWidth;
	    return rect.top >= 0 &&
			rect.left >= 0 &&
			rect.bottom <= vpHeight &&
			rect.right <= vpWidth;
	}

	/**
	 * Convert mapArray object like {attr1:[value1,value2], attr2:[value1,value2]
	     * to String attr1=value1,attr2=value2,attr2=value1,attr2=value2
	 * @param mapArray
	 */
	function attributeMapToString (mapArray) {
		var nameEqualValueFormatter = function(val) {
			return (name + "=" + val);
		};
		var result = "";
		if (!inu1(mapArray)) {
			var name;
			Object.keys(mapArray).forEach(function (key) {
				name = key;
				var arr = mapArray[name];
				var nvArr = arr.map(nameEqualValueFormatter);
				if (result.length > 0) {
					result += ",";
				}
				result += nvArr.join(",");
			});
		}
		return result;
	}

	/**
	 * Converts agent attributes row string to an object
	 * @param attrs is string of attributes (attr1=va1,attr2=val2)
	 * @return object like {attr1:[value1,value2], attr2:[value1,value2]}
	 */
	function attributesStringToMap (attrs) {
		function split2(str, sep) {
			var index = str.indexOf(sep);
			if (index < 0) {
				return [str, ""];
			} else {
				return [str.substring(0, index), str.substring(index + sep.length)];
			}
		}
		var map = {};
		var delimiter = '=';
		if(!!attrs) {
			var attrsArray = attrs.split(',');
			for(var i = 0; i < attrsArray.length; i++) {
				var nameValue = split2(attrsArray[i], delimiter);
				if(!map[nameValue[0]]) {
					map[nameValue[0]] = [];
				}
				map[nameValue[0]].push(nameValue[1]);
			}
		}
		return map;
	}

	/**
	 * Trims original message to MAX_LOG_LINE_LENGTH symbols. Adds information about original message size in case of trimming.
	 * @param sourceMsg source message
	 * @returns {string}
	 */
	function trimMsg(sourceMsg) {
	    var maxLogLineLength = gc7("MAX_LOG_LINE_LENGTH");
	    if (sourceMsg && sourceMsg.length && sourceMsg.length > maxLogLineLength) {
		    return sourceMsg.substring(0, maxLogLineLength) +
			    "... Message was trimmed to " + maxLogLineLength + " symbols, original size is:" + sourceMsg.length;
	    } else {
		    return sourceMsg;
	    }
    }

	/**
	 * Prefetch the resource.
	 *
	 * @param {string} path - URL of the prefetching resource
	 * @param {function=} errorHandler - error handler
	 */
	function prefetchResource(path, errorHandler) {
		// prefetching resource
		var resource = win.document.createElement("link");
		resource.rel = "prefetch";
		resource.as = "script";
		resource.href = path;
		resource.onerror = function() {
			if (typeof errorHandler === "function") {
				errorHandler();
			}
		}
		win.document.head.appendChild(resource);
	}

	/**
	 * We are faced with slow loading of persistent chat in IE and Edge browsers on some particular pages.
	 * Therefore was implemented the limitation of some functionality for that use case.
	 * See tickets RTDEV-19357 and RTDEV-20640 for more details.
	 * @return {boolean}
	 */
	function isPersistentChatLaunchingLimited() {
		return isPersistentWindow() && (isIE() || isEdge());
	}

	/**
	 * This is a regular debounce function.
	 * @param func {function} - The function to be debounced
     * @param wait {int} - The time delay in milliseconds
     * @param immediate {boolean} - if true, then it trigger the function on the leading edge, instead of the trailing.
     * @return callBackFun {function} - A debounced call back function
	 */
	function debounce(func, wait, immediate) {
		var timeout;
		return function () {
			var context = this, args = arguments;
			var later = function () {
				timeout = null;
				if (!immediate) func.apply(context, args);
			};
			var callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (callNow) func.apply(context, args);
		};
	}

	/**
	 * Returns the result of checking where from to load ACIF, Business Rule or IJSF.
	 * If there is a constant "ACIF_VERSION" in rules so ACIF will be loaded from business rule.
	 * If there isn't this constant, ACIF will be loaded from af4.
	 * @return {boolean}
	 */
	function isACIFLoadedFromBR() {
		return !!gc7('ACIF_VERSION', null);
	}

	/**
	 * Returns true when communication with CR isn't started yet and agent wasn't assigned yet.
	 * @returns {boolean}
	 */
	function isPreassignedChat() {
		return !Application.application.isConnected() && !CHM.getAgentID();
	}

	/**
	 * Creates new script element.
	 *
	 * @return {HTMLScriptElement} - returns script element
	 */
	function createScriptElement() {
		var script = document.createElement("script");
		script.type = "text/javascript";
		script.language = "javascript";
		script.setAttribute("language", "javascript");
		script.setAttribute("type", "text/javascript");
		script.charset = "utf-8";

		return script;
	}

	function generateRequestId (key) {
		return key + Math.floor(Math.random() * 1000001);
	}

	/**
	 * This function attempts to send data to a web server prior to the unloading of the document.
	 *
	 * Format of request:
	 * - Method: POST
	 * - Content-Type: "text/plain;charset=UTF-8"
	 *
	 * @see [MDN Navigator.sendBeacon()]{@link https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon}
	 * navigator.sendBeacon - isn't implemented by IE, so we will try to send beacon by XHR
	 *
	 * @param {string} url - The url parameter indicates the resolved URL where the data is to be transmitted.
	 * @param {string=} data - Object, serialized to JSON string, which is to be transmitted.
	 */
	function sendBeacon(url, data) {
		url += "&timestamp=" + (new Date()).getTime();
		if (navigator.sendBeacon) {
			navigator.sendBeacon(url, data);
		} else {
			sendBeaconByXHR(url, data);
		}
	}

	/**
	 * This function attempts to submit data to a server by using a synchronous XMLHttpRequest in an unload
	 * (or beforeunload, or hidepage etc.) handler. This results in the unload of the page to be delayed.
	 * The synchronous XMLHttpRequest forces the User Agent to delay unloading the document,
	 * and makes the next navigation appear to be slower.
	 * There is nothing the next page can do to avoid this perception of poor page load performance.
	 * But this is the only way to make the sending of beacon, if there is no method "navigator.sendBeacon()".
	 *
	 * Request parameters matches the API navigator.sendBeacon()
	 * @see [MDN Navigator.sendBeacon()]{@link https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon}
	 *
	 * @param {string} url - The url parameter indicates the resolved URL where the data is to be transmitted.
	 * @param {string=} data - Object, serialized to JSON string, which is to be transmitted.
	 */
	function sendBeaconByXHR(url, data) {
		var xHR = new XMLHttpRequest();
		xHR.open("POST", url, false);
		xHR.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
		xHR.send(data);
	}

	/**
	 * Maps url to object with extracted parts (origin, protocol, hostname, port, pathname)
	 * @param {string} str
	 * @return {(URL|{origin: String, href: String, protocol: String, hostname: String, port: number})}
	 */
	function parseUrl(str) {
		if (typeof URL === "function") {
			return new URL(str);
		} else {
			return customParseUrl(str);
		}
	}

	/**
	 * Only for IE, because it doesn't support URL constructor.
	 * Maps url to object with extracted parts (origin, protocol, hostname, port, pathname)
	 * @param {string} str
	 * @return {{origin: String, href: String, protocol: String, hostname: String, port: number}}
	 */
	function customParseUrl(str) {
		var result;
		var m = str.match(/^(https?:)\/\/([^\/:]+)(:?(\d*))/);
		var protocol = "";
		var hostname = "";
		var port = "";
		var origin = "";

		if (m) {
			protocol = m[1];
			hostname = m[2];
			/**
			 * Port should be empty if it port 80 and protocol 'http'
			 * or port 443 and protocol 'https' in specification,
			 * but in our realization if port specified, it won't be empty.
			 * @type {string}
			 */
			port = m[4] ? m[4] : "";
			
			origin = protocol + "//" + hostname;
			if (port !== ""
			&& (port !== "80" || protocol !== "http:")
			&& (port !== "443" || protocol !== "https:")
			) {
				origin += ":" + port;
			}
		}
		result = {
			origin: origin,
			href: str,
			protocol: protocol,
			hostname: hostname,
			port: port
		};
		return result;
	}

	/**
	 * Returns a concatenated string that contains 2 stacktraces.
	 * One stacktrace is the stacktrace of calling function, which includes arguments that were
	 * provided to each function in the chain.
	 * The second stacktrace is the native stacktrace we get from error.stack.
	 *
	 * Example output (see tests):
	 * ---------------------------
	 *
	 * caller stack trace:
	 * 		thirdFunction ({"third":"function"})
	 * 		secondFunction ({"greeting":"hi"},true)
	 * 		firstFunction ()
	 * 		anonymous function(function Assert(testContext) {   		classCallCheck(this, Assert);    		this.test = testContext;   	})
	 * error stack trace: Error: Error from third function
	 *     at thirdFunction (http://localhost:9088/base/src/test/resources/CommonUtilsQUnit.js:403:18)
	 *     at secondFunction (http://localhost:9088/base/src/test/resources/CommonUtilsQUnit.js:400:5)
	 *     at firstFunction (http://localhost:9088/base/src/test/resources/CommonUtilsQUnit.js:397:4)
	 *     at Object.<anonymous> (http://localhost:9088/base/src/test/resources/CommonUtilsQUnit.js:409:3)
	 *     at runTest (http://localhost:9088/base/node_modules/qunit/qunit/qunit.js:3048:30)
	 *     at Test.run (http://localhost:9088/base/node_modules/qunit/qunit/qunit.js:3034:6)
	 *     at http://localhost:9088/base/node_modules/qunit/qunit/qunit.js:3265:12
	 *     at processTaskQueue (http://localhost:9088/base/node_modules/qunit/qunit/qunit.js:2621:24)
	 *     at http://localhost:9088/base/node_modules/qunit/qunit/qunit.js:2625:8
	 * @param {Error} err
	 * @return {string}
	 */
	function getStackTrace(err) {
		try {
			var callstack = [];
			if (arguments && arguments.callee && arguments.callee.caller) {
				var fnctn = arguments.callee.caller;
				while (fnctn) {
					if (callstack.length > 32) {
						break;
					}
					var fn = fnctn.toString();
					var fnameIx = fn.indexOf("function ") + 9;
					var fnameEnd = fn.indexOf("(", fnameIx);
					var fname = fn.substring(fnameIx, fnameEnd) || "anonymous function";
					var args = "";
					if (fnctn.arguments.length) {
						for (var ix = 0; ix < fnctn.arguments.length; ix++) {
							var arg = fnctn.arguments[ix];
							args += ((args.length != 0) ? "," : "") + formatArgument(arg);
						}
					}
					callstack.push(fname + "(" + args + ")");
					fnctn = fnctn.caller;
				}

				var errorStackTrace;
				try {
					errorStackTrace = "error stack trace: " + err.stack;
				} catch (error) {
					/**
					 * Error stacktraces are highly inconsistent between browsers, in the way they output
					 * the information, and in browser support of the feature. Added try catch to make
					 * sure we're s7 and not interrupting the program accidentally.
					 */
					errorStackTrace = "Failed to retrieve error object's stacktrace.";
				}

				var callerStackTrace = "caller stack trace:\n\t\t" + callstack.join("\n\t\t");

				return callerStackTrace + "\n" + errorStackTrace;
			}
		} catch (e) {}

		return "";
	}

	/**
	 * Formats the argument into a somewhat readable format
	 *
	 * We have two different implementations, the first we implemented is the customFormatArgument which
	 * was not sufficient for formatting objects correctly, but could format values that can not be
	 * represented in JSON.
	 *
	 * The second implementation of customJSONStringify was added in order to be able to format objects
	 * using the native browser JSON.stringify implementation. But some values cannot be represented in
	 * JSON so we're using the customFormatArgument as a fallback.
	 *
	 * @param {any} arg, is the object to be rendered readable
	 * @return {string} with the argument or argument description
	 */
	function formatArgument(arg) {
		try {
			return customJSONStringify(arg);
		} catch (customJSONStringifyError) {
			try {
				return customFormatArgument(arg);
			} catch (customFormatArgumentError) {
				return "[argument]";
			}
		}
	}

	/**
	 * Try to convert an argument into readable form using JSON.stringify. Throws for values that can't
	 * be represented in JSON form like NaN, Infinity, Function
	 * @param {*} arg
	 * @return {string}
	 */
	function customJSONStringify (arg) {
		var stringifiedArgument = JSON.stringify(arg);

		// JSON-Stringified values of Infinity, NaN will get converted to a "null" string, which we don't want
		var valueWasConvertedToNull = arg !== null && stringifiedArgument === "null";

		if (valueWasConvertedToNull) {
			throw new Error("JSON.stringify converted" + arg + " to null");
		}

		// JSON-Stringified values of Function will get converted to undefined
		var valueWasConvertedToUndefined = arg !== undefined && stringifiedArgument === undefined;

		if (valueWasConvertedToUndefined) {
			throw new Error("JSON.stringify converted" + arg + " to undefined");
		}

		if (arg === undefined) {
			throw new Error("Can not stringify undefined value");
		}

		return stringifiedArgument;
	}

	/**
	 * Format argument into readable form.
	 * Can format arguments that JSON.stringify cannot represent in JSON such as NaN, Infinity, undefined, Function
	 * @param {*} arg
	 * @return {string}
	 */
	function customFormatArgument(arg) {
		var type = "[unknown]";
		try {
			type = (typeof (arg) == "object") ? ((arg["constructor"] != null) ? arg.constructor.toString() : "" + arg) : ("(" + typeof (arg) + ")");
		} catch (e) {
			type = "" + arg;
		}
		if (type.indexOf("function") != -1) {
			type = type.split("\n").join(" ").replace(/^\s*function (\w+)\s*\(\)[^\n]*/g, "[object $1]");
		}
		if (type == "(boolean)" || type == "[object Boolean]") type = (arg) ? "true" : "false";
		if (type == "(string)" || type == "[object String]") type = arg;
		if (type == "(number)") type = "" + arg;
		if (type == "(array)" || type == "[object Array]") {
			type = "";
			for (var ix = 0; ix < arg.length; ix++) {
				type += ((type.length != 0) ? "," : "") + customFormatArgument(arg[ix]);
				if (type.length > 128) break;
			}
			if (type.length > 128)
				type = type.substr(0, 128 - 3) + "...";
			return "[" + type + "]";
		}
		return type;
	}

	/**
	 * Gets the current inqFrame.location url string
	 *
	 * @returns {string} - url
	 */
	function getInqFrameURL() {
		var port = "";
		if (inqFrame.location.port != "") {
			port = ":" + inqFrame.location.port;
		}

		return (
			inqFrame.location.protocol + "//" +
			inqFrame.location.hostname + port +
			inqFrame.location.pathname
		);
	}

	/**
	 * Creates or sets parameter paramName in the obj variable.
	 *
	 * @param {object} obj - target object.
	 * @param {string} paramName - path to parameter, where the symbol "." is delimiter.
	 * @param {*} value - value of the parameter.
	 * @param {boolean?} createOnly - the existing parameter in the obj won't be overridden if it set to true.
	 */
	function setParamToObject (obj, paramName, value, createOnly) {
		var params = paramName.split(".");
		var currObj = obj;
		for (var i = 0; i < params.length - 1; i++) {
			if (inu1(currObj[params[i]])) {
				currObj[params[i]] = {};
			}
			currObj = currObj[params[i]];
		}

		if (currObj[params[params.length - 1]] === undefined || !createOnly) {
			currObj[params[params.length - 1]] = value;
		}
	}

	function setParamToObjectIfParamAbsent (obj, paramName, value) {
		setParamToObject(obj, paramName, value, true);
	}

	/**
	 * Saves time for use in SetTimeout when time always increases
	 * @param {number} increment
	 * @param {number} maxDelay
	 * @constructor
	 */
	function TimeoutIncrement(increment, maxDelay) {
		this.delayTimeout = 0;
		this.increment = increment;
		this.maxDelay = maxDelay;
	}

	/**
	 * Increases time on preset increment into maximum delay
	 * @return {number} next timeout
	 */
	TimeoutIncrement.prototype.getNextTimeout = function () {
		if (this.delayTimeout < this.maxDelay) {
			this.delayTimeout += this.increment;
		}
		return this.delayTimeout;
	};

	/**
	 * Resets delay timeout
	 */
	TimeoutIncrement.prototype.reset = function () {
		this.delayTimeout = 0;
	};

/**
 * XMLHttpRequest Facade -
 * Creates a consistent XMLHttpRequest that works cross-domain across all supported browsers.
 * @see http://www.w3.org/TR/cors/
 * @see http://www.w3.org/TR/XMLHttpRequest/
 * @see http://blogs.msdn.com/b/ie/archive/2012/02/09/cors-for-xhr-in-ie10.aspx
 * @see http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
 * @author fpinn@touchcommerce.com
 */
(function() {
	// Note: resetGlobalVars() relies that we check type of global variables,
	// DO NOT USE ["XMLHttpRequestFacade" in window] to check for custom window properties.
	if (typeof window.XMLHttpRequestFacade != "undefined") {
		return;
	}

	if (!!window["XMLHttpRequest"]) {
        if ("FACADE" in window.XMLHttpRequest) {
            // We are heavily broken if we got here as this means that window.XMLHttpRequestFacade
            // and window.XMLHttpRequestOriginal are not present but XMLHttpRequest is overwritten
            if ("console" in window) console.error("XF: ERROR: Inconsistent xform window state detected");
        } else {
            window.XMLHttpRequestOriginal = XMLHttpRequest;
        }
    }

	/**
	 * XMLHttpRequestFacade constructor - replaces the XHLHttpRequest to perform cross domain on all supported browsers
	 */
	window.XMLHttpRequestFacade = function() {
		/* establish the correct implementation for ajax transport */
		this._impl = XMLHttpRequestFacade._factory();	/* This is the implementation factory that gets the correct impl */
		this._impl._subclass = this;					/* Have the implementation have reference to this */
		this.log = function(s){ if ("console" in window) console.log("XHRF: " + s); };
		this.error = function(s,ex){ if ("console" in window) console.log("XHRF: " + s, ex); };
		this.debug = function(s,ex){ if ("console" in window && this._debug) console.log("XHRF: " + s, ex); };
		this.onabort = null;
		this.onerror = null;
		this.onload = null;
		this.onloadend = null;
		this.onloadstart = null;
		this.onprogress = null;
		this.onreadystatechange = null;
		this._debug = false;
		this.readyState = 0;
		this.response = "";
		this.responseText = "";
		this.responseBody = "";
		this.responseType = "";
		this.responseXML = null;
		this.status = 0;
		this.statusText = 0;

		/**
		 * onabort
		 */
		this._impl.onabort = function(event){
		//	this._subclass.log("onabort");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onabort){
				this._subclass.onabort(event);
			}
		};

		this._impl.setOnError(function(event){
		//	this._subclass.log("onerror");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onerror){
				this._subclass.onerror(event);
			}
		});

		this._impl.setOnLoad(function(event){
		//	this._subclass.log("onload");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onload){
				this._subclass.onload(event);
			}
		});

		this._impl.onloadend = function(event){

		//	this._subclass.log("onloadend");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onloadend){
				this._subclass.onloadend(event);
			}
		};

		this._impl.onloadstart = function(event){
		//	this._subclass.log("onloadstart");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onloadstart){
				this._subclass.onloadstart(event);
			}
		};

		this._impl.onprogress = function(event){
		//	this._subclass.log("onprogress");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onprogress){
				this._subclass.onprogress(event);
			}
		};

		this._impl.onreadystatechange = function(event){
		//	this._subclass.log("onreadystatechange");
			(this._subclass)._syncupFromImpl();
			if (null != this._subclass.onreadystatechange){
			//	this._subclass.log("onreadystatechange: " + this.readyState);
				this._subclass.onreadystatechange(event);
			}
		};

		this.addEventListener = function(type, listener, useCapture){
			this.debug("addEventListener: " + type);
			if (!useCapture)useCapture=false;
			if ("addEventListener" in this._impl)
				this._impl.addEventListener(type, listener, useCapture);
		};

		this.removeEventListener = function(type, listener){
			if ("removeEventListener" in this._impl)
				this._impl.removeEventListener(type, listener, useCapture);
		};

		/**
		 * abort delegate - ask impl to abort the xhr
		 * @return nothing
		 */
		this.abort = function() {
			if ("abort" in this._impl){
				this._impl.abort();
			} else {
				this.error("abort: Not implemented");
			}
		};

		this.getAllResponseHeaders = function () {
			if ("getAllResponseHeaders" in this._impl)
				return this._impl.getAllResponseHeaders();
		};

		this.getResponseHeader = function(headerString) {
			if ("getResponseHeader" in this._impl)
				return this._impl.getResponseHeader(headerString);
		};

		/**
		 * open delegate - assigns destination URL and method to send request
		 *	This open is subclassed to:
		 *		1) allow default server and protocol, if not supplied in URL
		 *		2) allow the JSESSION-ID to be injected into the URL for correct session tracking
		 *			This is needed to preserve java sessions when 3rd party cookies are not enabled
		 *			Cookieless sessions are achieved by appending a string of the format ";jsessionid=sessionIdentifier" to the end of a URL and before the query.
		 * @see http://stackoverflow.com/questions/436752/supporting-sessions-without-cookies-in-tomcat
		 * @see https://developers.google.com/search-appliance/documentation/50/admin/URL_patterns
		 * @param methodString - the method to perform, ie GET, POST, HEAD
		 * @param methodUrl - the URL to be accessed
		 * @param asyncFlag - (optional) true signifies asynchronous.  Default true
		 * @param userString - (optional) user name for authentication
		 * @param userPassword - (optional) user password for authentication
		 */
		this.open = function(methodString, methodUrl, asyncFlag, userString, userPassword){
			if (asyncFlag==null) asyncFlag = true;

			// fix up the URL
			var domain = this.constructor.defaultServerDomain;		/* From the constructor function get the default domain */
			var proto  = this.constructor.defaultServerProtocol;	/* From the constructor function get the default protocol */
			if (domain==null) domain = "";
			if (proto==null) proto = "";

			if (proto.length > 0){									/* Add the colon if e9 */
				if (proto.indexOf(":")==-1) proto += ":";
			}

			var rx = new RegExp('((http://|https://|//|/|#){0,1}[^"]*)', 'i');
			var parts = rx.exec(methodUrl);
			var url = "";

			// Fix the URL, put in default protocol and domain if not specified
			switch(parts[2]) {
				case "http://":case "https://":case "#":{
					url = parts[1];
					} break;
				case "//":{
					url = proto + parts[1];
					}break;
				case "/":{
					url = proto + "//" + domain + parts[1];
					}break;
				default:{
					url = path + "/" + parts[1];
					}break;
			}
			methodUrl = url ;

			// Now put the session id in the URL for Resin to pick up
			var jsessionid  = this.constructor.jsessionid;
			if (jsessionid!=null && jsessionid.length > 0) {
				parts = methodUrl.split("?");
				parts[0] += ";jsessionid=" + jsessionid;
				methodUrl = parts.join("?");
			}

			if (arguments.length < 4){
				this._impl.open(methodString, methodUrl, asyncFlag);
			} else if (arguments.length < 5) {
				this._impl.open(methodString, methodUrl, asyncFlag, userString);
			} else {
				this._impl.open(methodString, methodUrl, asyncFlag, userString, userPassword);
			}
		};

		/**
		 * overrideMimeType delegate - ask impl to perform the overrideMimeType
		 * @param mimeString - string containing new mime type
		 */
		this.overrideMimeType = function(mimeString){
			this.debug("override: " + mimeString);
			if ("overrideMimeType" in this._impl)
				return this._impl.overrideMimeType(mimeString);
		};

		/**
		 * send delegate - ask implementation to send data
		 * @param data to be sent or null
		 */
		this.send = function(data){
			this.debug("send");
			if ("send" in this._impl){
				if (!!data) {
					return this._impl.send(data);
				} else {
					return this._impl.send();
				}
			}
		};

		/**
		 * setRequestHeader delegate - ask (if implemented) the implementation (impl) to set the request header
		 * @param headerString - string that specifies the header name
		 * @param valueString - string that specifies the value to which the headerName is to be set
		 * @return nothing
		 */
		this.setRequestHeader = function(headerString, valueString){
			this.debug("setRequestHeader: " + headerString + ": " + valueString);
			try {
				if ("setRequestHeader" in this._impl)
					return this._impl.setRequestHeader(headerString, valueString);
			} catch (e){ this.error("setRequestHeader: Error", e); }
		};

		/**
		 * private function that makes sure that the impl data is set to the facade
		 */
		this._syncupFromImpl=function() {
			this.debug("sync readyState");
			this.readyState = this._impl.readyState;
			this.response = this._impl.response;
			this.responseText = this._impl.responseText;
			try {this.responseBody = this._impl.responseBody;} catch(X){ /* No error here, no need to report */ }
			this.responseType = this._impl.responseType;
			try {this.responseXML = this._impl.responseXML;} catch(X){ /* No error here, there may not be a responseXML */ }
			try {this.status = this._impl.status;} catch(X){ /* No error here, there may not be a status */ }
			try {this.statusText = this._impl.statusText;} catch(X){ /* No error here, there may not be a statusText */ }
		};
		return this;
	};
		/**
		 * private static function _factory
		 * produces implementations for
		 * CORS (Cross Origin Resource Sharing) for HTML5 and IE10 (not IE8-9)
		 * and legacy support for non-HTML5 browsers.
		 */
		XMLHttpRequestFacade._factory = function () {
			if (typeof window.XMLHttpRequestOriginal != "undefined") {
				var impl = new XMLHttpRequestOriginal();
				if ("withCredentials" in impl) {
					impl.setOnLoad = function (handler) {
						this.onload = handler;
					};
					impl.setOnError = function (handler) {
						this.onerror = handler;
					};
					return impl;
				}
			}

			if (window.Inq && window.Inq.FlashPeer
				&& typeof window.Inq.FlashPeer.logErrorToServer == "function"
			) {
				window.Inq.FlashPeer.logErrorToServer("XMLHttpRequestOriginal "
					+ " or withCredentials parameter is absent."
					+ " Factory function will return empty object."
				);
			}

			return {};
		};
	// Constructor name
	try {
		window.XMLHttpRequestFacade.name = "XMLHttpRequest";
	} catch(e) {
		// This is not an error but a quirk in FF
	}
	window.XMLHttpRequestFacade.DONE = 4;
	window.XMLHttpRequestFacade.LOADING = 3;
	window.XMLHttpRequestFacade.HEADERS_RECEIVED = 2;
	window.XMLHttpRequestFacade.OPENED = 1;
	window.XMLHttpRequestFacade.UNSENT = 0;
	window.XMLHttpRequestFacade.defaultServerDomain = null;
	window.XMLHttpRequestFacade.defaultServerProtocol = "";
	window.XMLHttpRequestFacade.jsessionid = "";
	// Flag used to detect whether XMLHttpRequest is our facade or original request
	window.XMLHttpRequestFacade.FACADE = true;
})();

/**
 *  Refactoring reason
 * Firsts of all Extending new properties to Javascript in-build objects is not recommended because
 * http://lucybain.com/blog/2014/js-extending-built-in-objects/
 * http://rlynjb.github.io/wandrr/JS-Interview-Question-Why-is-extending-built-in-JavaScript-objects-not-a-good-idea
 * Since we have already done that we need to make sure that properties that are added below are not enumerable.
 * Adding a new property to prototype makes it enumerable.
 * The problem of being enumerable is that it appears in for-in loop. That may cause problems in many libraries including jquery
 * Here is an example
 * https://api.jquery.com/jQuery.isEmptyObject/
 * Jquery isEmptyObject determines if an Array is empty by executing for-in loop.
 * 	Array.prototype.test = 123
 	var cars = ["Saab", "Volvo", "BMW"];
 	for (var a in cars) {
		alert(a)
	}
 */
	/* Moves the current date objects time forward or backward by number of provided MS. Function returns the rolled Date object. */
	Object.defineProperty(Date.prototype, "roll", {
		value: function(rollTimeInMS) {
			/* RU */
			this.setTime(this.getTime() + rollTimeInMS);
			return this;
		},
		enumerable: false
	});

	/* Returns time diff between instance and given Date object in MS. Returns negative value if future date is passed in. */
	Object.defineProperty(Date.prototype, "diff", {
		value: function(otherDate) {
			/* RU */
			return otherDate ? this.getTime() - otherDate.getTime() : 0;
		},
		enumerable: false
	});

	/* Returns true if this object represents point in time earlier than specified Date object. */
	Object.defineProperty(Date.prototype, "before", {
		value: function(otherDate) {
			/* RU */
			return otherDate ? this.getTime() < otherDate.getTime() : 0;
		},
		enumerable: false
	});

	/* Returns true if this object represents point in time later than specified Date object. */
	Object.defineProperty(Date.prototype, "after", {
		value: function(otherDate) {
			/* RU */
			return otherDate ? this.getTime() > otherDate.getTime() : 0;
		},
		enumerable: false
	});

	/* Returns true if this object and specified Date object represent the same point in time. */
	Object.defineProperty(Date.prototype, "equals", {
		value: function(otherDate) {
			/* RU */
			if(otherDate)
				return this.getTime() == otherDate.getTime();
			return false;
		},
		enumerable: false
	});

	/* MixIn for mixing in additional Date functionality. See usage in LandingFramework.js, function s7().  */
	var DateMixIn = (function() {
		return {
			equals: Date.prototype.equals,
			roll: Date.prototype.roll,
			diff: Date.prototype.diff,
			before: Date.prototype.before,
			after: Date.prototype.after
		};
	})();


	Object.defineProperty(Array.prototype, "contains", {
		value: function (item, equalsFcn) {
			/* RU */
			for (var idx = 0; idx < this.length; idx++) {
				if ((equalsFcn && equalsFcn(this[idx], item)) || (!inu1(item) && item.equals && item.equals(this[idx])) || this[idx] == item) {
					return true;
				}
			}
			return false;
		},
		enumerable: false
	});


	/**
	 * Returns true if this array contains all elements of array supplied in parameter, otherwise return false.
	 * @param _arr array containing elements to check for presence in this array.
	 * @return true if this array contains all elements of array supplied in parameter, otherwise false.
	 */

	Object.defineProperty(Array.prototype, "containsAll", {
		value: function (_arr) {
			for (var idx = 0; idx < _arr.length; idx++) {
				if (!this.contains(_arr[idx])) {
					return false;
				}
			}
			return true;
		},
		enumerable: false

	});


	/**
	 * Returns true if this array is empty, otherwise return false.
	 * @return true if this array is empty, otherwise false.
	 */

	Object.defineProperty(Array.prototype, "isEmpty", {
		value: function () {
			if (this.length) {
				return false;
			}
			return true;
		},
		enumerable: false
	});


	/**
	 * Appends (to back of array) items in a second array in the same order.
	 * @return altered instance of the modified array
	 */
	Object.defineProperty(Array.prototype, "append", {
		value: function(a) {
			if(!!a && !!a.length){
				for(var i=0; i<a.length; i++) {
					this.push(a[i]);
				}
			}
			return this;
		},
		enumerable: false
	});


	/**
	 * Prepends (to front of array) items in a second array in the same order.
	 * @return altered instance of the modified array
	 */
	Object.defineProperty(Array.prototype, "prepend", {
		value: 	function(a) {
			for(var i=0; i<a.length; i++) {
				this.unshift(a[a.length-1-i]);
			}
			return this;
		},
		enumerable :false
	});


	/**
	 * Returns the index of the first occurrence of the specified element
	 * in this list, or -1 if this list does not contain the element (IE8 support).
	 * Remark: Current implementation works more quick than original. It's very critical for Firefox (see investigation in RTDEV-4236)
	 *
	 * @param el element to find in this array
	 * @return index of supplied element in this array
	 */
	Object.defineProperty(Array.prototype, "indexOf", {
		value: function(el) {
			var ind = -1;
			for(var i = 0; i < this.length; i++) {
				if (this[i] == el) {
					ind = i;
					break;
				}
			}
			return ind;
		},
		enumerable :false
	});


	/**
	 * Truncates an array (lopping off last array.length - len from end of array) to size specified
	 * @return {Array} altered instance of the modified array
	 */
	Object.defineProperty(Array.prototype, "constrain", {
		value: function(len){
			if(len && len>0 && this.length>len){
				this.length = len;
			}
			return this;
		},
		enumerable :false
	});

	/**
	 * Static that clones a given array to a new instance of an array with the same elements in the same order.
	 * @return {Array} new (copied) instance of the given array. NOT A DEEP CLONE.
	 */
	Array.clone = function(_arr){
		if(_arr){
			var rv = [];
			if(typeOf(_arr)=='array'){
				for(var idx=0; idx<_arr.length; idx++){
					rv[idx]=_arr[idx];
				}
				return rv;
			}
		}
		return _arr;
	};

	/**
	 * Static function that moves the date to the given amount of time forward.
	 * <p>If the given date is null or undefined or not a date objet, then return 0.
	 * <p>If the given roll time is null or undefined or not a number, then return the same date.
	 * @param date {Date} given date to move forward
	 * @param rollTimeInMS {Number} given time (miliseconds) to add
	 * @returns {*} updated date object if the date is valid, or 0 if the date is invalid
	 */
	Date.roll = function(date, rollTimeInMS) {
		if (date && date instanceof Date) {
			if (rollTimeInMS && !isNaN(rollTimeInMS)) {
				date.setTime(date.getTime() + rollTimeInMS);
			}
			return date;
		}
		return new Date(0);
	};

	/**
	 * Static function that returns time diff between instance and given Date object in MS. Returns negative value if future date is passed in. Returns 0 if firstDate or secondDate are invalid.
	 * @param firstDate {Date}
	 * @param secondDate {Date}
	 * @returns {Number}
	 */
	Date.diff = function(firstDate, secondDate) {
		if (firstDate instanceof Date && secondDate instanceof Date) {
			return firstDate.diff(secondDate);
		}
		return 0;
	};

	Object.defineProperty(Array.prototype, "_assertNumType", {
		value: function(){
			if (this.length>0 && typeof this[0] != 'number')
				throw "OperationNotSupported: can't sum on a non-numerical list";
		},
		enumerable :false
	});

	/* Calculates and returns sum of numeric elements of array. Nonnumeric elements are skipped.
	 * @return sum of numeric elements of array.
	 * @throws error "OperationNotSupported" if array contains nonnumeric elements.
	 */
	Object.defineProperty(Array.prototype, "sum", {
		value: function() {
			this._assertNumType();
			if (!this.length) {
				return 0;
			} else {
				return this[0] + this.slice(1).sum();
			}
		},
		enumerable :false
	});

	/* Returns standard deviation of array elements.
	 * @return standard deviation of array elements.
	 */
	Object.defineProperty(Array.prototype, "std_dev", {
		value: function() {
			this._assertNumType();
			var sum = this.sum();
			var mean = sum / this.length;
			for(var i = 0, variance = 0; i < this.length; i++) {
				variance += Math.pow(this[i] - mean, 2);
			}
			variance = variance / this.length;
			return Math.sqrt(variance);
		},
		enumerable :false
	});

	/* Returns average of array elements.
	 * @return average of array elements.
	 * @throws error "OperationNotSupported" if array contains nonnumeric elements.
	 */
	Object.defineProperty(Array.prototype, "average", {
		value: function(){
			this._assertNumType();
			var sum = 0;
			for(var i=0; i<this.length; i++){
				sum += this[i];
			}
			return sum/this.length;
		},
		enumerable :false
	});

	/* Returns array size.
	 * @return array size.
	 */
	Object.defineProperty(Array.prototype, "size", {
		value: function() {
			return this.length;
		},
		enumerable :false
	});

	/**
	 * boolean visitor iterator that takes an object and an objects comparator fcn to test against a given result
	 * @return true if all comparisons equal the desired result. False if any one fails.
	 */
	Object.defineProperty(Array.prototype, "_visit", {
		value: function(o, bFcn, bool){
			for(var i=0; i<this.length; i++){
				if(bFcn(this[i], o)!=bool)
					return false;
			}
			return true;
		},
		enumerable :false
	});

	// VISITOR function definitions FOR DATE-TYPED ARRAYS...
	Object.defineProperty(Array.prototype, "after", {
		value: function(d){
			return this._visit(
				d,
				function(d1,d2){
					return d1.after(d2);
				},
				true
			);
		},
		enumerable :false
	});

	Object.defineProperty(Array.prototype, "before", {
		value: function(d){
			return this._visit(
				d,
				function(d1,d2){
					return d1.before(d2);
				},
				true);
		},
		enumerable :false
	});

	Object.defineProperty(Array.prototype, "remove", {
		value: function(index) {
			if (index < 0 || index > this.length) {
				return;
			}
			for (var i = index ; i +1 < this.length; i++) {
				this[i] = this[i+1];
			}
			this.length = this.length -1;
		},
		enumerable :false
	});


    /**
     * Returns Array of keys (Map`).
     * @return Array of keys.
     */
	Object.defineProperty(Array.prototype, "keys", {
		value: function () {
			var out = new Array();
			for(var index = 0; index < this.length; index ++) {
				var entry = this[index];
				out.push(entry.key);
			}
			return out;
		},
		enumerable :false
	});


    /**
     * Returns Array of values (from map).
     * @return Array of values.
     */
	Object.defineProperty(Array.prototype, "values", {
		value: function () {
			var out = new Array();
			for(var index = 0; index < this.length; index ++) {
				var entry = this[index];
				out.push(entry.value);
			}
			return out;
		},
		enumerable :false
	});


    /**
     * Returns Map.Entry
     * @param key key of entry
     * @return Map.Entry if there is key in map, otherwise null.
     */
	Object.defineProperty(Array.prototype, "findEntry", {
		value: function (key) {
			for(var index = 0; index < this.length; index ++) {
				if (this[index].key == key) {
					return this[index];
				}
			}
			return null;
		},
		enumerable :false
	});

    /**
     * Returns value for key (Map)
     * @param key key of entry
     * @return value if there is key in map, otherwise null.
     */
	Object.defineProperty(Array.prototype, "get", {
		value: function (key) {
			var entry = this.findEntry(key);
			if (entry) {
				return entry.value;
			}
			return null;
		},
		enumerable :false
	});

    /**
     * Create(if there is no entry)/Rewrite (if there is entry) Map.Entry
     * @param key key of map entry
     * @param value value of map entry
     * @param findEntry if true, then try to find entry in map
     */
	Object.defineProperty(Array.prototype, "set", {
		value: function (key, value, findEntry) {
			var entry = null;
			if (typeof(findEntry) == 'undefined'  || findEntry == true) {
				entry = this.findEntry(key);
			}
			if (entry) {
				entry.value = value;
			}
			else {
				entry = {key: key, value : value};
				this.push(entry);
			}
		},
		enumerable :false
	});

    /**
     * Remove Map.Entry for key
     * @param key key of map entry
     */
	Object.defineProperty(Array.prototype, "unset", {
		value: function (key) {
			for(var index = 0; index < this.length; index ++) {
				if (this[index].key == key) {
					this.remove(index);
					break;
				}
			}
		},
		enumerable :false
	});

    /**
     * Clear Array
     */
	Object.defineProperty(Array.prototype, "clear", {
		value: function () {
			this.length = 0;
		},
		enumerable :false
	});

    /**
     * Execute function for each Map.Entry
     * @param fnc function to which will executed for each map entry
     * function's parameters: key, value
     * @return Array with 'fnc returns' if there is function, otherwise null
     */
	Object.defineProperty(Array.prototype, "collect", {
		value: function (fnc) {
			if (typeof fnc != "function") {
				return null;
			}
			var out = [];
			for(var index = 0; index < this.length; index ++) {
				var entry = this[index];
				if(entry.key && entry.value) {
					out.push(fnc(entry.key, entry.value));
				}
				else{
					out.push(fnc(entry));
				}
			}
			return out;
		},
		enumerable :false
	});


    /**
     * Execute function for each Map.Entry
     * @param fnc function which will executed for each map entry
     * (function's parameters : key, value, map)
     */

	Object.defineProperty(Array.prototype, "each", {
		value: function (fnc) {
			if (typeof fnc != "function") {
				return;
			}
			for(var index = 0; index < this.length; index ++) {
				var entry = this[index];
				fnc(entry.key, entry.value, this);
			}
		},
		enumerable :false
	});

    if (!Array.prototype.forEach) {
        /**
         * Executes a provided function once per array element (IE8 support).
         * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
         * @return callback Function to execute for each element
         * @return thisArg Object to use as this when executing callback
         */
		Object.defineProperty(Array.prototype, "forEach", {
			value: function (callback, thisArg) {
				for (var i = 0, n = this.length; i < n; i++) {
					if (i in this) {
						callback.call(thisArg, this[i], i, this);
					}
				}
			},
			enumerable :false
		});
    }

    Array.prepareMapToSerialize = function(map) {
        var out = {};
        for(var i = 0; i < map.length; i++){
            var element = map[i];
            out[element.key]  = element.value;
        }
        return out;
    };

	/* Performs range check for this Number object value. Range bounds are inclusive.
	 * @return true if this Number object value is within bounds.
	 * @throws If upper range bound is less than lower range bound.
	 */
	Object.defineProperty(Number.prototype, "inRange", {
		value: function(low, high) {
			if (high < low) throw ("Incorrect range bounds: low = " + low + ", high = " + high);
			if ((this >= low) && (this <= high)) return true;
			else return false;

		},
		enumerable :false
	});

	// MixIn for mixing in additional Number functionality. See usage in LandingFramework.js, function s7()
	var NumberMixIn = (function() {
		return {inRange: Number.prototype.inRange};
	})();

	/* Returns true if current String object contains searchString as a substring.
	 * Remark: the implementation is different as in other browser - additional parameter "isRegexp" (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FString%2Fcontains)
	 *
	 * @param searchString a substring to search for.
	 * @param bIgnoreCase ignore case flag; if set to true, search is done ignoring character case.
	 * @param isRegexp true if searchString must be treated as RegExp pattern
	 * @return true if substring was found.
	 */
	Object.defineProperty(String.prototype, "contains", {
		value: function(searchString, bIgnoreCase, isRegexp) {
			if(inu1(searchString)) {
				return false;
			}
			if (!isRegexp) {
				var str1;
				var str2;
				if (bIgnoreCase) {
					str1 = this.toLowerCase();
					str2 = searchString.toLowerCase();
				} else {
					str1 = this;
					str2 = searchString;
				}
				var ind = str1.indexOf(str2);
				return (ind != -1);
			} else {
				var reFlags = "";
				if (bIgnoreCase) reFlags = "i";
				var re = new RegExp(searchString, reFlags);
				return re.test(this);
			}
		},
		enumerable :false
	});

	/* Returns true if current String object starts with value specified in searchString parameter.
	 * Remark: the implementation is different as in other browser - additional parameter "isRegexp" (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FString%2FstartsWith)
	 *
	 * @param searchString a string to search for.
	 * @param bIgnoreCase ignore case flag; if set to true, search is done ignoring character case.
	 * @param isRegexp true if searchString must be treated as RegExp pattern
	 * @return true if current string starts with @searchString.
	 */
	Object.defineProperty(String.prototype, "startsWith", {
		value: function(searchString, bIgnoreCase, isRegexp) {
			if(inu1(searchString)) {
				return false;
			}
			if (!isRegexp) {
				var str1;
				var str2;
				if (bIgnoreCase) {
					str1 = this.toLowerCase();
					str2 = searchString.toLowerCase();
				} else {
					str1 = this;
					str2 = searchString;
				}
				var ind = str1.indexOf(str2);
				return (ind == 0);
			} else {
				var reFlags = "";
				if (bIgnoreCase) reFlags = "i";
				if (searchString.charAt(0) != "^") searchString = "^" + searchString;
				var re = new RegExp(searchString, reFlags);
				return re.test(this);
			}
		},
		enumerable :false
	});

	/* Returns true if current String object ends with value specified in searchString parameter.
	 * Remark: the implementation is different as in other browser - additional parameter "isRegexp" (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FString%2FendsWith)
	 *
	 * @param searchString a string to search for.
	 * @param bIgnoreCase ignore case flag; if set to true, search is done ignoring character case.
	 * @param isRegexp true if searchString must be treated as RegExp pattern
	 * @return true if current string ends with @searchString.
	 */

	Object.defineProperty(String.prototype, "endsWith", {
		value: function(searchString, bIgnoreCase, isRegexp) {
			if(inu1(searchString)) {
				return false;
			}
			if (!isRegexp) {
				var str1;
				var str2;
				if (bIgnoreCase) {
					str1 = this.toLowerCase();
					str2 = searchString.toLowerCase();
				} else {
					str1 = this;
					str2 = searchString;
				}
				var ind = str1.lastIndexOf(str2);
				return ((ind != -1) && (ind == (str1.length - str2.length)));
			} else {
				var reFlags = "";
				if (bIgnoreCase) reFlags = "i";
				if (searchString.charAt(searchString.length - 1) != "$") searchString = searchString + "$";
				var re = new RegExp(searchString, reFlags);
				return re.test(this);
			}
		},
		enumerable :false
	});

	/* Returns true if current String object is equal to the specified searchString parameter.
	 * @param searchString a string to compare with.
	 * @param bIgnoreCase ignore case flag; if set to true, comparison is done ignoring character case.
	 * @param isRegexp true if searchString must be treated as RegExp pattern
	 * @return true if current string is equal to @searchString.
	 */
	Object.defineProperty(String.prototype, "equals", {
		value: function(searchString, bIgnoreCase, isRegexp) {
			if(inu1(searchString)) {
				return false;
			}
			if (!isRegexp) {
				var str1;
				var str2;
				if (bIgnoreCase) {
					str1 = this.toLowerCase();
					str2 = searchString.toLowerCase();
				} else {
					str1 = this;
					str2 = searchString;
				}
				return (str1 == str2);
			} else {
				var reFlags = "";
				if (bIgnoreCase) reFlags = "i";
				if (searchString.charAt(0) != "^") searchString = "^" + searchString;
				if (searchString.charAt(searchString.length - 1) != "$") searchString = searchString + "$";
				var re = new RegExp(searchString, reFlags);
				return re.test(this);
			}
		},
		enumerable :false
	});

	/**
	 * Javascript implementation of Javaâ€™s String.hashCode() method
	 * @see http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
	 * @see http://stackoverflow.com/questions/7616461/
	 * @return {number}
	 */
	Object.defineProperty(String.prototype, "hashCode", {
		value: function(){
			var hash = 0;
			for (var i = 0; i < this.length; i++) {
				var char = this.charCodeAt(i);
				hash = ((hash << 5) - hash) + char;
				hash = hash << 0; // convert to 32bit integer
			}
			return hash;
		},
		enumerable :false
	});

	if (!String.prototype.trim) {
		/**
		 * Delete start and end spaces in the string (IE8 support).
		 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FString%2FTrim
		 *
		 * @return {String} resulted string
		 */
		Object.defineProperty(String.prototype, "trim", {
			value: function() {
				return this.replace(/^\s+|\s+$/g, "");
			},
			enumerable :false
		});
	}

	if (!String.prototype.replaceAll) {
		/**
		 * String.prototype.replaceAll() polyfill
		 * Returns a new string with all matches of a pattern replaced by a replacement.
		 *
		 * @type {RegExp|string} pattern
		 * @type {Function|string} replacement
		 * @returns {string}
		 */
		String.prototype.replaceAll = function (pattern, replacement) {
			// If a regex pattern
			if (Object.prototype.toString.call(pattern).toLowerCase() === '[object regexp]') {
				return this.replace(pattern, replacement);
			}

			// If a string
			return this.replace(new RegExp(pattern, 'g'), replacement);
		};
	}

	/**
	 * Provides access to internal data without reference linkage.
	 * @interface
	 */
	function DataExporter(){}
	/**
	 * Provides data snapshot of the implementing instance.
	 * @return {Object} a data object that contains no linkage to the internals of the instance
	 * (shallow copy only if needed). To protect internal references from exposure, it is highly recommended
	 * that clones of internal data be returned instead of actual references.
	 * @see MI8.clonize
	 */
	DataExporter.prototype.getData = function(){};

	/**
	 * MI8 defines reusable interfaces with default implementations that
	 * can be added to a target object at runtime.
	 * @namespace Holds functionality related to Mix-ins.
	 */
	var MI8 = (function(){
		/** @inner */
		function _throwNoImpl(){
			throw (""+this.getID()+": "+arguments.callee.name+" requires override.");
		}

        function wrapWithTryCatch(code) {
            // window.console is used because Inq.log() is not available in XFormExternsions
            return "try{" + code + "}catch(e){if(window.console)window.console.error('ERROR:' + e.message);};\n";
        }

		/**
		 * Document XJA3 class here
		 * @name XJA3
		 * @class
		 */
		var XJA3 =
		/**
		 * This is an API that can be mixed into other objects
		 * @lends XJA3#
		 */
		{
			/**
			 * Absorbs the contents of the argument object into self
			 * @param {Object} absorbee object to absorb fields from
			 * @param {boolean} [agregateFlag] Optional flag, if true, then nested 1st level objects are augmented, not overwritten.
			 * @returns this for chaining convenience
			 */
			absorb: function(absorbee, agregateFlag) {
				if(absorbee){
					for(var name in absorbee) {
						if ((typeOf(this[name]) == 'object') && (typeOf(absorbee[name]) == 'object') && agregateFlag) {
							MI8.mixAbsorber(this[name]);
							this[name].absorb(absorbee[name]);
						} else {
							this[name]=absorbee[name];
						}
					}
				}
				return this;
			}
		};

		/**
		 * Add the RC54 interface to a target object.
		 * The target object will gain the following methods:
		 * onRemoteCallback, callRemote, getRID
		 * @class
		 * @name RC54
		 */
		var RC54 =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends RC54#
			 */
		{
				/**
				 * callback on a remote call
				 */
				onRemoteCallback: _throwNoImpl,
				/**
				 * calls out a round trip message to a remote server via a url
				 * @param {string} url properly formatted base url to communicate
				 * @param {object} data name-value pairs to be sent to the server
				 */
				callRemote: function(url, data){
					ROM.doRemoteCall(url, data, this);
				},
				send: function() {
					ROM.send.apply(ROM, arguments);
				}
		};

		/**
		 * Support for resource interface
		 * @class
		 * @name Resource
		 */
		var Resource =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends Resource#
			 */
		{
				/**
				 * "super" type constructor. REQUIRED on construction.
				 * @param {string} id The resource id
				 */
				_resource: function(id){
					this._rsrcID = id;
				},
				/**
				 * Writes name-value pairs to resource. If value is undefined, name-value pair is deleted from resource.
				 * @param {string} name name part to be saved
				 * @param {object} value value to be saved with the name.
				 * 	If undefined, name-value pair is deleted from resource.
				 */
				write: _throwNoImpl,
				/**
				 * Reads an object from the resource.
				 * @param {string} name name of the object to be retrieved from resource
				 */
				read: _throwNoImpl,
				/**
				 * helper method to serialize values.
				 * @param {object} o object to be serialized
				 * @return {string} string value of the object
				 * @public
				 */
				_serialize: _throwNoImpl,
				/**
				 * helper method to de-serialize strings to objects.
				 * @param {string} o string to be deserialized
				 * @return {object} object or null if either not deserialzable or not found
				 * @public
				 * @throws {string} error on de-serialization
				 */
				_deserialize: _throwNoImpl,
				/**
				 * obtains the resource id for the resource
				 */
				getResourceID: function(){
					return this._rsrcID;
				}
		};

		/**
		 * Support for DataReadyListener interface
		 * @class
		 * @name DataReadyListener
		 * @see X4334rtf
		 */
		var DataReadyListener =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends DataReadyListener#
			 */
		{
			/**
			 * Invoked when a data ready evt is fired
			 */
				agrtyer: _throwNoImpl
		};


		/**
		 * Support for Persistable interface
		 * @class
		 * @name Persistable
		 * @see X4334rtf
		 */
		var Persistable =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends Persistable#
			 */
		{
				/**
				 * obtains the persistable's id
				 * @return {string} string id
				 */
				getPersistentID: _throwNoImpl,
				/**
				 * loads the persistable's data from serialzed repository to memory
				 */
				load: _throwNoImpl,
				/**
				 * saves the persistables memory data to data repository
				 */
				save: _throwNoImpl,
				/**
				 * invoked as data ready listener
				 * @borrows DataReadyListener#agrtyer ad #agrtyer
				 */
				agrtyer: _throwNoImpl
		};

		/**
		 * Document FM2 class here
		 * @name FM2
		 * @class
		 */
		var FM2 =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends FM2#
			 */
		{
				_frameworkModule: function(id){
					this._id = id;
				},
				getID: function(){ return this._id;},
				/**
				 * initialized a module. Contract: internal init only. No linkage.
				 */
				init: _throwNoImpl,
				/**
				 * starts a module.
				 */
				start: _throwNoImpl,
				/**
				 * resets a module completely.
				 */
				reset: _throwNoImpl
		};

		/**
		 * Document Observable class here
		 * @name Observable
		 * @class
		 */
		var Observable = (function(){
			var retval =
			/**
			 * This is an API that can be mixed into other objects
			 * @lends Observable#
			 */
			{
				/**
					* adds an array of listeners to the class
					*/
				addListeners: function(_arr){
					for(var idx=0; idx < _arr.length; idx++){
						this.addListener(_arr[idx]);
					}
				},

				/**
				 * Must be invoked with constructor
					* @public
					*/
				_observable: function(){
					this._listeners = [];
					this.observable=true;
				},

				/**
					* clears all listeners in the class
					*/
				clearListeners: function(){
					this._listeners=[];
				},
				/**
					* generic event firing method for use by any Observable mixin
					* @public
					*/
				_fireEvt: function(vfcn, evt){
					for(var idx=0; idx < this._listeners.length; idx++){
						var listener = this._listeners[idx];
						vfcn(listener, evt);
						if (typeof listener.onAnyEvent == "function") {
							listener.onAnyEvent(evt);
						}
					}
				},
				/**
					* adds a listener
					*/
				addListener: function(l){
					if(l && (this.isListener(l) || l.onAnyEvent)){
						this._listeners.push(l);
					}
				},
				removeListener: function(name) {
					for (var idx=0; idx < this._listeners.length; idx++) {
						if (typeof this._listeners[idx][name] == "function") {
							this._listeners.splice(idx--, 1);
						}
					}
				},
				/**
					* Determines if a given object is an acceptable listener for this class.
					* Overriding this method is required.
					* @throws {String} if the method is invoked without override
					*/
				isListener: _throwNoImpl
			};
			return retval;
		})();


		/**
		 * Document JSON MixIn here
		 * @constructor
		 * @class JSON
		 * @name JSON
		 * @field
		 */
		var _JSON;
		if (jsSDKEnabled === false) {
			_JSON = (function () {
				function f (n) {
					return n < 10 ? '0' + n : n;
				}

				if (typeof Date.prototype.toJSON !== 'function') {
					/** @ignore */
					Object.defineProperty(Date.prototype, "toJSON", {
						value: function (key) {
							return this.getTime();
						},
						enumerable: false
					});
					/** @ignore */
					Object.defineProperty(String.prototype, "toJSON", {
						value: function (key) {
							return this.valueOf();
						},
						enumerable: false
					});
					Object.defineProperty(Number.prototype, "toJSON", {
						value: function (key) {
							return this.valueOf();
						},
						enumerable: false
					});
					Object.defineProperty(Boolean.prototype, "toJSON", {
						value: function (key) {
							return this.valueOf();
						},
						enumerable: false
					});
				}
				var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapeable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},rep;

				function quote (string) {
					escapeable.lastIndex = 0;
					return escapeable.test(string) ? '"' + string.replace(escapeable, function (a) {
						var c = meta[a];
						if (typeof c === 'string') {
							return c;
						}
						return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
					}) + '"' : '"' + string + '"';
				}

				function str (key, holder) {
					var i, k, v, length, mind = gap, partial,
						value = holder[key];
					if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
						value = value.toJSON(key);
					}
					if (typeof rep === 'function') {
						value = rep.call(holder, key, value);
					}
					switch (typeof value) {
						case'string':
							return quote(value);
						case'number':
							return isFinite(value) ? String(value) : 'null';
						case'boolean':
						case'null':
							return String(value);
						case'object':
							if (!value) {
								return 'null';
							}
							gap += indent;
							partial = [];
							if (typeof value.length === 'number' && !value.propertyIsEnumerable('length')) {
								length = value.length;
								for (i = 0; i < length; i += 1) {
									partial[i] = str(i, value) || 'null';
								}
								v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
								gap = mind;
								return v;
							}
							if (rep && typeof rep === 'object') {
								length = rep.length;
								for (i = 0; i < length; i += 1) {
									k = rep[i];
									if (typeof k === 'string') {
										v = str(k, value);
										if (v) {
											partial.push(k + (gap ? ': ' : ':') + v);
										}
									}
								}
							} else {
								for (k in value) {
									if (k != "") {
										try {
											if (Object.hasOwnProperty.call(value, k)) {
												v = str(k, value);
												if (v) {
													partial.push(k + (gap ? ': ' : ':') + v);
												}
											}
										} catch (e) {
											var eMsg = 'Exception at Object.hasOwnProperty.call(' + value + ', ' + k + ') ';
											eMsg += cf21(e) + ' in JSON.str(' + key + ', ' + holder + ')';
											ROM.post(urls.loggingURL, {
												level: 'WARN',
												line: (eMsg)
											});
										}
									}
								}
							}
							v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
							gap = mind;
							return v;
					}
				}

				function clone (object) {
					return parse(stringify(object));
				}

				function stringify (value, replacer, space) {
					if (typeof value == "undefined" || value == null) {
						return null;
					}
					var i;
					gap = '';
					indent = '';
					if (typeof space === 'number') {
						for (i = 0; i < space; i += 1) {
							indent += ' ';
						}
					} else if (typeof space === 'string') {
						indent = space;
					}
					rep = replacer;
					if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
						throw new Error('_JSON.stringify');
					}
					return str('', { '': value });
				}

				function parse (text, reviver) {
					if (!text) return null;

					if (useNativeJson()) {
						try {
							// for valid JSONs we may try to use native JSON
							return JSON.parse(text);
						} catch (e) {
							try {
								// for cookie object we use custom JSON-like format without quotes,
								// so to avoid usage of eval() we wrapping keys with quotes and use native JSON.parse.
								var formattedJSON = text.replace(/([{,])([\w\\.]+)(:)/g, '$1"$2"$3');
								return JSON.parse(formattedJSON);
							} catch (e) {
								e.message = "Error while parsing JSON: " + e.message + ". Input JSON: " + text;
								throw e;
							}
						}
					} else {
						var j;

						function walk (holder, key) {
							var k, v, value = holder[key];
							if (value && typeof value === 'object') {
								for (k in value) {
									if (Object.hasOwnProperty.call(value, k)) {
										v = walk(value, k);
										if (v !== undefined) {
											value[k] = v;
										} else {
											delete value[k];
										}
									}
								}
							}
							return reviver.call(holder, key, value);
						}

						cx.lastIndex = 0;
						if (cx.test(text)) {
							text = text.replace(cx, function (a) {
								return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
							});
						}
						try {
							j = evaluateLegacySettings('(' + text + ')');
						} catch (e) {
							e.message = "Error while parsing JSON: " + e.message + ". Input JSON: " + text;
							throw e;
						}
						return typeof reviver === 'function' ? walk({ '': j }, '') : j;
					}
				}

				var retval =
					/**
					 * This is an API that can be mixed into other objects
					 * @lends JSON#
					 */
					{

						/**
						 * converts a given Object into a new object instance
						 * @function
						 * @param object, object to be cloned
						 * @return new object
						 * @throws {Error} When JS object is not "stringifiable"
						 */
						clone: clone,

						/**
						 *  converts a given object to JSON string
						 *  @function
						 *  @param value val
						 *  @param replacer replacer
						 *  @param space space
						 *  @throws {SyntaxError} When invalid JSON string is parsed
						 */
						stringify: stringify,
						/**
						 * converts a given JSON string to an object
						 * @function
						 * @param text text to be parsed into an object. Must be valid JSON string to succeed
						 * @param reviver
						 * @throws {Error} When JS object is not "stringifiable"
						 */
						parse: parse
					};
				return retval;
			})();
		} else {
			_JSON = window.JSON
			var oParse = _JSON.parse
			_JSON.parse = function (text, reviver) {
				if (!text) return null;
				return oParse(text, reviver);
			}
			_JSON.clone = function (object) {
				return JSON.parse(JSON.stringify(object));
			}
		}


		/**
		 * This mixin is for objects that need to be able to clone themself.
		 * @name Cloneable
		 * @class Cloneable
		 */
		var Cloneable = (function(){
			var retval =
			/**
			* This is an API that can be mixed into other objects
			* @lends Cloneable#
			*/
			{

				/**
				* Returns clone of the object.
				* Overriding this method is required.
				* @throws {String} if the method is invoked without override
				*/
				clone: function(){
					return JSON.parse(JSON.stringify(this));
				}
			};

			return retval;
		})();

		var im13 = function(mixable){
			if(mixable){
				for(var name in mixable){
					if(!this[name]) {
						if(this.prototype) {
							this.prototype[name]=mixable[name];
						} else {
							this[name] = mixable[name];
						}
					}
				}
			}
			return this;
		};

		function prepare(_class){
			if(_class){
				_class.im13 = im13;
			}
			return _class;
		}

		function mixAbsorber(o){
			if(!o){
				o= {};
			}
			o.absorb = XJA3.absorb;
			return o;
		}

		function clonize(o){
			if(!!o && typeOf(o)=="object"){
				o.clone = function(){
					return JSON.parse(JSON.stringify(this));
				}
			}
			return o;
		}

		/**
		 * Settable allows set chaining.
		 * @param {Object} the object instance to be made into a "settable".
		 * If null or undefined, a new object settable will be created and returned. If
		 * non-object is passed it will not be mixed (ignored).
		 * Ex. var o = MI8.mixSettable().set("a",123).set(2, "foo");
		 */
		function mixSettable(o){
			if(inu1(o)){
				o = {};
			}
			if(!!o && typeOf(o)=="object"){
				/**
				 * sets a name value to this object.
				 * @param n {any} assigns the given value to the name.
				 * Will not assign if null or undefined.
				 * @param v {any} Value for the given name to be assigned to the object
				 * @returns this object always.
				 */
				o.set = function(n,v){
					if(!!n || n===0 || n === ""){
						this[n]=v;
					} else {
						var error = new Error();
						log(
							"Settable: Unable to set n,v=(" + n + "," + v + ") on "
							+ this.toString() + ". \n" + error.stack
						);
					}
					return this;
				};
				/**
				 * Set parameter to object if value is exist
				 * @param {string} name - name of parameter
				 * @param {*} value - value of parameter
				 * @returns {Object}
				 */
				o.setIfNotEmpty = function (name, value) {
					if (!!value) {
						return this.set(name, value);
					} else {
						return this;
					}
				}
			}
			return o;
		}
		/**
		 * Removable allows remove chaining.
		 * @param {Object} the object instance to be made into a "settable".
		 * If null or undefined, a new object settable will be created and returned. If
		 * non-object is passed it will not be mixed (ignored).
		 * Ex. var o = MI8.mixSettable().set("a",123).set(2, "foo");
		 */
		function mixRemovable(o){
			if(inu1(o)){
				o = {};
			}
			if(!!o && typeOf(o)=="object"){
				/**
				 * Removes a named value from this object.
				 * @param n {any} assigns the given value to the name.
				 * Will not assign if null or undefined.
				 * @returns this object always.
				 */
				o.remove = function(n){
					if(!!n || n===0 || n === ""){
						delete this[n];
					}
					return this;
				};
			}
			return o;
		}
		/**
		 * Renamable allows remove chaining.
		 * @param {Object} the object instance to be made into a "settable".
		 * If null or undefined, a new object settable will be created and returned. If
		 * non-object is passed it will not be mixed (ignored).
		 * Ex. var o = MI8.mixSettable().set("a",123).set(2, "foo");
		 */
		function mixRenamable(o){
			if(inu1(o)){
				o = {};
			}
			if(!!o && typeOf(o)=="object"){
				/**
				 * Renames a named value in this object.
				 * @param n {any} assigns the given value to the name.
				 * Will not assign if null or undefined.
				 * @returns this object always.
				 */
				o.rename = function(on,nn){
					if((!!on || on===0 || on === "") && (!!nn || nn===0 || nn === "")){
						var v = this[on];
						if(!!v || v===0){
							delete this[on];
						}
						this[nn]=v;
					}
					return this;
				};
			}
			return o;
		}
		function unmixMutatable(o){
			delete o.rename;
			delete o.remove;
			delete o.set;
			delete o.setIfNotEmpty;
			return o;
		}
		
		function mixMutatable(o){
			o = mixRemovable(o);
			o = mixSettable(o);
			o = mixRenamable(o);
			return o;
		}

		function unmix(o){
			o = unmixMutatable(o);
			delete o.absorb;
			delete o.im13;
			return o;
		}

		return {
			prepare: prepare,
			Observable: Observable,
			JSON: _JSON,
			mixMutatable: mixMutatable,
			unmixMutatable:unmixMutatable,
			mixAbsorber: mixAbsorber,
			XJA3: XJA3,
			Resource: Resource,
			Persistable: Persistable,
			FM2:FM2,
			RC54:RC54,
			clonize: clonize,
			Cloneable:Cloneable,
            wrapWithTryCatch:wrapWithTryCatch,
			unmix: unmix
		};
	})();

/**
 * DMgr is a static class which contains methods for debugging
 * based on enabling and sending certain parts of the chat functionality
 * which is determined by the module name when passed to debug methods
 *
 * @class
 * @Static
 * @constructor
 */
function DMgr() {}

/**
 * Sends error message to TS for. Works only if debug is enabled for passed module.
 *
 * @param {string} module
 * @param {string} message
 */
DMgr.let12 = function (module, message) {
	if (DMgr.Modules[module]) {
		let12(message, true);
	}
};

/**
 * Sends warn message to TS for. Works only if debug is enabled for passed module.
 *
 * @param {string} module
 * @param {string} message
 */
DMgr.lwt12 = function (module, message) {
	if (DMgr.Modules[module]) {
		lwt12(message);
	}
};

/**
 * Sends info message to TS for. Works only if debug is enabled for passed module.
 *
 * @param {string} module
 * @param {string} message
 */
DMgr.logInfoToTagServer = function (module, message) {
	if (DMgr.Modules[module]) {
		logInfoToTagServer(message);
	}
};

/**
 * Sends debug message to TS for. Works only if debug is enabled for passed module.
 *
 * @param {string} module
 * @param {string} message
 */
DMgr.logDebugToTagServer = function (module, message) {
	if (DMgr.Modules[module]) {
		logDebugToTagServer(message);
	}
};

/**
 * Switches debug logs for passed module name
 *
 * @param {string} name - module name
 * @param {boolean} value - true will enable logs, false will disabled logs
 */
DMgr.switchForModule = function (name, value) {
	if (DMgr.Modules.hasOwnProperty(name) && typeof value === "boolean") {
		DMgr.Modules[name] = value;
		log("DMgr: debug for " + name + " switched to " + value);

		return true;
	} else {
		log(
			"DMgr: debug for " + name + " wasn't enabled, because this"
			+ " module is absent or value isn't boolean",
			LOG_LEVELS.WARN
		);

		return false;
	}
};

/**
 * The object of module names supported for debugging by logs
 *
 * @type {{VA_DATA_PASS: boolean}}
 */
DMgr.Modules = {
	VA_DATA_PASS: false
};

/**
 * We store all created iframes here to re-use
 * @type {Object}
 */
LR45.frameStorage = {};

/**
 * New frame was created, but main frame is still waiting for response from that.
 * @type {Array}
 */
LR45.pendingIFrames = {};

/**
 * Store all known postToServer.html
 * @type {Object}
 */
LR45.p2sStorage = {};

/**
 * This keeps context containing needed details about request/response
 */
LR45.contexts = {};
LR45.currFrameId = 0;
LR45.ieVersion = getBrowserMajorVer(true);

LR45.init = false;

/**
 * This manager is responsible for doing cross-domain requests via iframe-proxy
 * @constructor
 */
function LR45() {
    if (!LR45.init) LR45.init = LR45._init();
}

LR45._init = function () {
    if (window.addEventListener)
		window.addEventListener("message", LR45.handleResponse, false);
    else if (window["attachEvent"])
		window.attachEvent("onmessage", LR45.handleResponse);
    else
		window.onmessage = LR45.handleResponse;

	var postToServerHtmPath = LR45.getP2sPath();
    var postToServerHtmPathIncludedSiteID = LR45.getP2sPath(true);

	LR45.putItemToP2sStorage(urls.vanityURL, "/tagserver/" + postToServerHtmPathIncludedSiteID);
	LR45.putItemToP2sStorage(urls.cobrowseURL, "/cobrowse/" + postToServerHtmPath);
	LR45.putItemToP2sStorage(urls.mediaRootURL, "/tagserver/" + postToServerHtmPathIncludedSiteID);

    return true;
};

/**
 * Returns path to postToServer htm file
 * @param {?boolean} includeSiteID - indicates whether the siteID prameter will be included into parameter list.
 * @return {string} name of postToServer htm file
 */
LR45.getP2sPath = function(includeSiteID) {
	/** @const {string} */
	var CODE_VERSION_PARAM_NAME = "codeVersion";
	/** @type {Object} */
	var requestParameters = {};
	/** @type {string|number} */
	var codeVersion = v3Lander && v3Lander.codeVersion || Date.now();
	/** @type {string} */
	var postToServerHtmName = site.JSDebugMode ? "postToServer.dev.htm" : "postToServer.min.htm";
	if (includeSiteID) {
		requestParameters["siteID"] = getSiteID();
	}
	requestParameters[CODE_VERSION_PARAM_NAME] = codeVersion;
	return postToServerHtmName + "?" + ROM.toParamString(requestParameters, true, false);
};

/**
 * Puts postToServer path to p2sStorage
 * @param {string} url - url to component
 * @param {string} p2pPath - path to postToServer
 */
LR45.putItemToP2sStorage = function(url, p2pPath) {
	var parsedUrl = parseUrl(url);
	LR45.p2sStorage[parsedUrl.hostname] = parsedUrl.hostname + p2pPath;
};

/**
 * Handles messages coming from iframe-proxy, it calls corresponding callback function
 * @param {Object} event
 */
LR45.handleResponse = function(event) {
	if (!event.data) {
		return false;
	}
	if (event.data.error) {
		LR45.handleError(event);
	} else {
		LR45.handleSuccess(event);
	}
};

/**
 * Prepares context and calls corresponding callback function
 * @private
 * @param {Object} event
 */
LR45.handleSuccess = function (event) {
    var data;
    if (typeof(event.data) == "string") {
        // for old browser versions
        data = LR45.convertStrToArray(event.data);
    } else {
        data = event.data;
    }

    if (data && data[0]) {
        var id = data[0];
        var context = LR45.getContext(id);

        if (context) {
			//if origin doesn't match the message came from so ignoring;
			if (!LR45.frameStorage[event.origin]) {
				let12("LR45.handleSuccess."
					+ " Origin doesn't match the message came from so event "
					+ JSON.stringify(event) + " ignored.",
					true
				);
				return;
			}
            context.origin = event.origin;
            var cmd = data[1];
            context.id = id;
            if (data.length > 2) {
                context.responseStatus = data[2];
                context.responseHeaderCacheControl = data[3];

				/*
				 * Inside this function we additionally handle logging requests
				 * and our logger used image/gif" as content type for old usage
				 * of 'script-tag', and as response body in this case we have
				 * "1x1 pixel" gif image. In RTDEV-17067 was implemented the
				 * handler of callback on this response.
				 *
				 * But here we have a case when header which has been set by our
				 * server, was overwritten, and here, as "content-type" header
				 * we have "image/gif, application/json; charset=utf-8" value
				 * and as body our "1x1 pixel" gif image.
				 *
				 * Here implementation checks "application/json" inside value
				 * and try to parse gif image as JSON object, and of course we
				 * are  fail on that, and we try to log message about that. And
				 * situation was repeated it when we process response of this
				 * log message.
				 *
				 * As result we have repeating log requests to the our server
				 * where each new message bigger than previous one.
				 *
				 * As solution we ignore all cases when "content-type" header
				 * contains "image/gif" as par of their value.
				 *
				 */
				context.contentType = data[4];
				if (context.contentType.indexOf("image/gif") === -1) {
					if (context.contentType.indexOf("application/json") > -1) {
						try {
							context.data = MI8.JSON.parse(cmd);
						} catch (e) {
							logErrorInPostToTagServer("LR45.handleSuccess:" + cf21(e));
						}
					} else {
						context.data = cmd;
					}
				}
			} else {
				try {
					if (cmd && cmd.indexOf("{") === 0) {
						context.data = MI8.JSON.parse(cmd);
					} else {
						// should be used only for cookies, because they don't stringified object
						// for "ONLOAD" cmd will undefined
						context.data = cmd;
					}
				} catch (e) {
					logErrorInPostToTagServer(
						plc1("LR45.handleSuccess. cmd " + JSON.stringify(cmd)
						+ " couldn't be parsed. " + e.message)
					);
				}
			}

            if (context.callbackFun) {
                context.callbackFun.call(undefined, context);
            }

            LR45.unregisterContext(id, event.origin);
		}
    }
};

/**
 * This method called when we catch error in {@link LR45.handleResponse}
 * @param {Object} event - should contain data with id of context, error message and origin
 */
LR45.handleError = function(event) {
	var id = event.data.id;
	var key = event.origin;
	var context = LR45.getContext(id);
	if (context && typeof context.callbackFunErr === "function") {
		context.callbackFunErr(event.data.error);
	} else {
		let12(
			"LR45.handleError. "
			+ "Could not find context or error callback for data " + JSON.stringify(event.data)
			+ " with origin " + key,
			true
		);
	}
	LR45.unregisterContext(id, key);
};

/**
 * This method is always called for the sub-domain, if the frame is loaded, we do nothing.
 * Otherwise, we didn't load it, call CM47.xdPsHelper.processSavedXdCookie without data
 * that to start chat with data we have from other domains.
 * @param key - id of iframe
 */
LR45.handleIframeTimeout = function (key) {
	var frameItem = LR45.frameStorage[key];
	if (!frameItem.loaded) {
		var id = frameItem.reqQueue[0][1];
		var context = LR45.getContext(id);
		context.origin = key;
		if (typeof context.callbackFun === "function") {
			context.callbackFun(context);
		}
		LR45.unregisterContext(id, key);
	}
};

/**
 * Register context for request in LR45.contexts
 *
 * @param {string} id - the unique ID of request
 * @param {object} context - object for events
 * @param {Array} request - the command and data for the proxy-iframe
 */
LR45.registerContext = function (id, context, request) {
	if (LR45.contexts[id]) {
		logErrorInPostToTagServer(
			plc1(
				"Id: " + id + " same as in previous request. "
				+ "It will be overwritten by new request " + JSON.stringify(request)
			)
		);
	}
	LR45.contexts[id] = context;
};

/**
 * Removes context from contexts array
 * @param {string} id - request which we need remove from postedRequests array
 * @param {string} key - id of iframe from which we need to remove the processed request
 */
LR45.unregisterContext = function (id, key) {
	LoadM.removeRequestFromPostedRequestsQueue(id, key);
    delete LR45.contexts[id];
};

LR45.getContext = function (id) {
    return LR45.contexts[id];
};

/*
* @deprecated
*/
LR45.convertStrToArray = function (str) {
    var arr = str.split("||");
    for (var i = 0; i < arr.length; i++) {
        arr[i] = decodeURIComponent(arr[i]);
    }
    return arr;
};

/**
 * postRequestToIframeProxy - use an iframe-proxy to do some work
 * details:
 *    An IFRAME with source from domain of the vanity domain performs work specified by the request parameter.
 * @param {string} url    server path to postToServer.html
 * @param {Array} request       the command and data for the proxy-iframe to run the format is command||data1||data2...||datan
 * @param {string} id            the unique ID of request
 * @param {Object} context      object for events
 */
LR45.prototype.postRequestToIframeProxy = function (url, request, id, context) {
	try {
		if (id && context) {
			LR45.registerContext(id, context, request);
		}
		var parsedUrl = parseUrl(url);
		var host = parsedUrl.hostname;
		var p2pPath = LR45.p2sStorage[host];
		var key = parsedUrl.origin;
		var frameItem = LR45.frameStorage[key];
		if (!frameItem) {
			var iframeId = "post_box_" + (++LR45.currFrameId);
			var src = p2pPath
				? (parsedUrl.protocol + "//" + p2pPath)
				: url + (window.v3LanderConfig && window.v3LanderConfig.iframeSrcParams || "");
			/*
			 * customerID is required for Load Balancer logic (session persistence by customerID).
			 * Will not be added to TS iframe request since there is no customerID
			 * as this stage, customerID is set after TS request.
			 */
			if (getCustID()) {
				src = src + "&customerID=" + getCustID();
			}

			// store this iframe for future re-usage
			frameItem = {				
				loaded: false,
				name: "",
				origin: parsedUrl.origin,
				reqQueue: [],
				postedRequests: []
			};
			LR45.frameStorage[key] = frameItem;

			// Check for 1PC cookie enabled
			if(isWebSDK 
				&& !CM47.xdPsHelper.is1pcEnabled() 
				&& CM47.xdPsHelper.hostFileURLUse
				&& window.bootstrap1PCSolution) {
				frameItem.frameId = iframeId;
				FrameBridge.postMessageToBootStrap("1_PC_CREATE", {
					iframeId: iframeId,
					src: src,
					key: key
				});
			} else {
				var iframe = createHiddenIFrame(iframeId, 0, 0, 1, 1, src);
				frameItem.frame = iframe;

				if (site.noJSHosting || isWebSDK) {
					iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts');
				}
	
				if (window.addEventListener) {
					iframe.addEventListener("load", this.iframeOnLoad.bind(this, frameItem, key), false);
				}
				document.getElementsByTagName("body")[0].appendChild(iframe);
				this.setIFrameTimeout(key, iframe, p2pPath);
			}
			
		}

		if (frameItem.loaded) {
			this.sendRequest(frameItem, request);
		} else {
			// store the request in queue
			frameItem.reqQueue.push(request);
		}
	} catch (e) {
		logErrorInPostToTagServer(
			plc1("LR45.postRequestToIframeProxy: " + e.message + ".")
		);
	}
};
/**
 * called from frame-bridge to notify loadMgr that 1pc iframe is created on parent page
 * @param {string} key 
 */
LR45.prototype.bootstrapFrameLoaded = function(key) {
	var frameItem = LR45.frameStorage[key];
	frameItem.bootstrap = true;
	frameItem.loaded = true;
	this.iframeOnLoad(frameItem, key); 	
}

/**
 * Check type iFrame, if we need it, for example it chatrouter iframe, we refresh it till doesn't have answer.
 * If it sub-domain across 2 sec. we call handleIframeTimeout.
 * @param {String} key
 * @param {iframe} iframe
 * @param {String} p2pPath
 */
LR45.prototype.setIFrameTimeout = function (key, iframe, p2pPath) {
	if (p2pPath) {
		var refreshIFrameTimeoutIncrement = new TimeoutIncrement(getRefreshIframeDelayIncrement(), getMaxRefreshIframeDelay());
		LR45.pendingIFrames[key] = setTimeout(function () {
			this.refreshIFrame(key, iframe.src, refreshIFrameTimeoutIncrement);
		}.bind(this), getRefreshIframeDelayIncrement());
	} else {
		setTimeout(function () {
            LR45.handleIframeTimeout(key);
		}, getRefreshIframeDelayIncrement());
	}
};

/**
 * Refreshes iframe if postToServer.js didn't respond.
 * interval time from 2 sec. to 30 sec.
 * @param {string} key
 * @param {string} src
 * @param {TimeoutIncrement} refreshIFrameTimeoutIncrement
 */
LR45.prototype.refreshIFrame = function (key, src, refreshIFrameTimeoutIncrement) {
	if (LR45.pendingIFrames[key] && LR45.frameStorage[key]) {
		var iframeItem = LR45.frameStorage[key];
		iframeItem.frame.contentWindow.location = src + "";
		LR45.pendingIFrames[key] = setTimeout(
			function () {
				this.refreshIFrame(key, src, refreshIFrameTimeoutIncrement);
			}.bind(this),
			refreshIFrameTimeoutIncrement.getNextTimeout()
		);
	}
};

LR45.prototype.iFrameInitializationCallback = function (data) {
	if (data.id) {
		var iframeItem = LR45.frameStorage[data.id];
		if (LR45.pendingIFrames[data.id]) {
			clearTimeout(LR45.pendingIFrames[data.id]);
			delete LR45.pendingIFrames[data.id];
		}
		iframeItem.loaded = true;
		data.context.sendQueuedRequests(iframeItem);
	}
};

/**
 * Sends requests via iframe-proxy.
 * @param {object} frameItem
 * @param {Array} request - requests parameters
 */
LR45.prototype.sendRequest = function (frameItem, request) {
	try {
		if (frameItem.bootstrap) {
			this.sendRequestToBootstrap(frameItem, request);
			return;
		}
		var iframe = frameItem.frame;
		var win = iframe.contentWindow;
		if (win != null) {
			win.postMessage(request, frameItem.origin);
			log("LR45#sendRequest: posted cross-window message: " + request, LOG_LEVELS.DEBUG);
		} else {
			log(
				"LR45#sendRequest: can not post cross-window message: "
				+ "iframe.contentWindow is undefined. iframe id: " + iframe.id
				+ ". frame source: " + iframe.src,
				LOG_LEVELS.DEBUG
			);
		}
	} catch (e) {
		let12("LR45.sendRequest:" + cf21(e));
	}
};

/**
 * Request is send to bootstrap 
 * @param {Object} frameItem 
 * @param {Object} request 
 */
LR45.prototype.sendRequestToBootstrap = function(frameItem, request) {
	FrameBridge.postMessageToBootStrap("1_PC_MESSAGE", {			
		requestData: request,
		origin: frameItem.origin,
		frameId: frameItem.frameId
	});
}

/**
 * Sends requests storing in queue.
 * @param {object} frameItem
 */
LR45.prototype.sendQueuedRequests = function (frameItem) {
	var shiftedReqQueue;
	// send all waiting requests from queue
	while (frameItem.reqQueue.length > 0) {
		// If the window is accessible then post the message, otherwise fall through and make a new IFRAME
		shiftedReqQueue = frameItem.reqQueue.shift();
		frameItem.postedRequests.push(shiftedReqQueue);
		this.sendRequest(frameItem, shiftedReqQueue);
		// if iframe doesn't loaded, only "ONLOAD" request should be send
		// other requests from queue will be sent from LR45#iFrameInitializationCallback
		// when iframe will be loaded
		if (!frameItem.loaded) {
			log("LR45#sendRequest: iframe is not loaded. frame id: "
				+ frameItem.frame.id + ". frame source: " + frameItem.frame.src,
				LOG_LEVELS.DEBUG
			);
			break;
		}
	}
};

/**
 * Transfers requests from postedRequests array to reqQueue array.
 * In postedRequests array there are requests that did not have time to
 * process before reloading the iframe.
 * reqQueue array contains requests that will be sent for handling.
 * and calls {@link LR45.initRequest}
 * processed before iframe-proxy reload.
 * @param {Object} frameItem
 * @param {string} key contains origin of server path to postToServer.html
 */
LR45.prototype.iframeOnLoad = function (frameItem, key) {
	/**
	 * We need to transfer all requests
	 * from postedRequests array to reqQueue array.
	 * We place the transferred request in this variable
	 */
	var transferredRequest;
	while (frameItem.postedRequests.length > 0) {
		transferredRequest = frameItem.postedRequests.pop();
		frameItem.reqQueue.unshift(transferredRequest);
	}
	this.initRequest(frameItem, key);
};

/**
 * Register context and
 * sends ONLOAD request storing in queue via iframe-proxy
 *
 * @param {object} frameItem
 * @param {string} key contains origin of server path to postToServer.html
 */
LR45.prototype.initRequest = function(frameItem, key) {
	if (!LR45.getContext(key)) {
		LR45.registerContext(key, {
			id: key,
			callbackFun: this.iFrameInitializationCallback,
			context: this
		});
	}

	/**
	 * JSLoggingDisabled always true for now because of excessive logging
	 * https://ent-jira.nuance.com/browse/IJSF-212 
	 */ 	
	var request = [
		"ONLOAD",
		{
			rootDomainsList: getRootDomainsList(),
			id: key,
			JSLoggingDisabled: true
		},
		getSiteID()
	];
	// if 1pc iframe is owned by websdk bootstrap send to it
	if(frameItem.bootstrap) {
		this.sendRequestToBootstrap(frameItem, request);		
	}
	else if (frameItem.frame) {
		var contentWindow = frameItem.frame.contentWindow;
		if (contentWindow) {
			contentWindow.postMessage(request, frameItem.origin);
		}
	} else {
		log("Warning! frameItem.frame is undefined");
	}
};

/**
 * In this function we remove the processed request from postedRequests array
 * @param {string} id - request which we need remove from postedRequests array
 * @param {string} key - id of iframe from which we need to remove the processed request
 */
LR45.prototype.removeRequestFromPostedRequestsQueue = function (id, key) {
	var frameItem = LR45.frameStorage[key];
	for (var i = 0; i < frameItem.postedRequests.length; i++) {
		if (id === frameItem.postedRequests[i][1]) {
			frameItem.postedRequests.splice(i, 1);
			break;
		}
	}
};

/**
 * Communicate with server
 * @constructor
 */
function NR7 () {
	this.chatrouterRequestsBackup = [];
	this.requestsInProgress = {};
}

/**
 * Chooses which command should be executed.
 *
 * @param {string} url - URL to send the request to
 * @param {Array} parameters - command properties:
 *
 * <br/>&emsp;                 0 - command
 * <br/>&emsp;                 1 - request id
 * <br/>&emsp;                 2 - site id (used only for cookies)
 * <br/>&emsp;                 3 - iFrame url (currently isn't used)
 * <br/>&emsp;                 4 - request url
 * <br/>&emsp;                 5 - request body
 * <br/>&emsp;                 6 - request timeout
 * <br/>&emsp;                 7 - protection id
 *
 * @param {string} id - the unique ID of request
 * @param {Object} context - context with callback functions
 */
NR7.prototype.doCommands = function (url, parameters, id, context) {
	var command = parameters[0];
	switch (command) {
		case "POSTASYNC":
			this.sendRequest(url, parameters, id, context, true);
			break;
		// IMPORTANT!! should be used only for CR requests
		case "POSTCHAT":
			this.sendRequest(
				url,
				parameters,
				id,
				context,
				true,
				false,
				{
					errorHandler: this.errorHandlerForCR,
                    successHandler: this.successHandlerForCR,
					addRequestInProgress: this.addRequestInProgressForCR
				}
			);
			break;
		case "POSTJSON":
			this.sendRequest(url, parameters, id, context, true, true);
			break;
		case "POSTSYNC":
			this.sendRequest(url, parameters, id, context, false);
			break;
		case "ABORT":
			this.abortRequest(id);
			break;
		default:
			var err = new Error("Syntax Error. Undefined Request for [" + command + "] command");
			let12("NR7#doCommands: " + err.message
				+ ". Command caller from " + err.stack
			);
			break;
	}
}

/**
 * Chooses by which way request will be sent
 *
 * @param {string} url - URL to send request
 * @param {Object} data - payload
 * @param {string} id - context ID for Load Manager
 * @param {boolean} sync - flags about synchronous request
 * @param {function} callbackFcn - callback
 * @param {function=} errorCallback - error callback
 * @param {number=} timeout - request timeout
 * @param {object} postRequestData - request data for CM#postRequestToIframeProxy
 */
NR7.prototype.process = function (url, data, id, sync, callbackFcn, errorCallback, timeout, postRequestData) {
	if (getFlagSendDataToTSWithoutIframe() && url.startsWith(urls.vanityURL)) {
		var requestData = this.prepareRequestData(
			url,
			data,
			id,
			sync,
			callbackFcn,
			errorCallback,
			timeout
		);
		CommunicationMgr.doCommands(
			url,
			requestData["request"],
			requestData["id"],
			requestData["context"]
		);
	} else {
		try {
			CM.postRequestToIframeProxy(
				postRequestData["request"],
				postRequestData["id"],
				postRequestData["callback"],
				errorCallback
			);
		} catch (e) {
			logErrorInPostToTagServer("ROM.post ERROR:" + cf21(e));
		}
	}
}

/**
 * Sends request to server.
 *
 * @param {string} url - URL to send the request to
 * @param {Array} parameters - command properties
 * @param {string} id - the unique ID of request
 * @param {Object} context - context with callback functions
 * @param {boolean} async - is request should be async
 * @param {boolean=} isJSON - is content type json
 * @param {object=} handlers
 *
 * @private
 */
NR7.prototype.sendRequest = function (url, parameters, id, context, async, isJSON, handlers) {
	try {
		var requestBody = parameters[5];
		var method = requestBody ? "POST" : "GET";
		var timeout = parseInt(parameters[6], 10) || 0;
		var protectionId = parameters[7];
		var request = new XMLHttpRequest();
		request.open(method, url, async);

		if (async) {
			request.timeout = timeout;
		}
		if (protectionId) {
			request.setRequestHeader("X-Protection-Id", encodeURIComponent(protectionId));
		}

		request.onreadystatechange = function () {
			if (request.readyState === XMLHttpRequest.DONE) {
				if (handlers && typeof handlers.successHandler === "function") {
					handlers.successHandler.call(this, request, id);
				} else {
					this.successHandler(request, id);
				}
			}
		}.bind(this);

		if (handlers && typeof handlers.addRequestInProgress === "function") {
			handlers.addRequestInProgress.call(this, url, id, request, context, parameters);
		} else {
			this.addRequestInProgress(id, request, context, 0, parameters);
		}

		if (method === "POST") {
			if (isJSON) {
				request.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
			} else {
				request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			}
			request.send(decodeURIComponent(requestBody));
		} else {
			request.send();
		}
	} catch (e) {
		if (handlers && typeof handlers.errorHandler === "function") {
			handlers.errorHandler.call(this, e, id);
		} else {
			this.errorHandler(e, id);
		}
	}
};

/**
 * Aborts the request if it has already been sent.
 *
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.abortRequest = function (id) {
	var request = this.getRequest(id);
	this.deleteInProgressRequest(id);
	if (request) {
		request.abort();
	}
}

/**
 * Handles error.
 *
 * @param {Error} error
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.errorHandler = function (error, id) {
	var context = this.getContext(id);
	/*
	 * Request will be aborted, this will produce done status of request.
	 * When request will have done status, NR7#successHandler
	 * will be called, but at this time request will be deleted from
	 * NR7#requestsInProgress map. So context will be absent
	 * and callbackFun won't be called.
	 */
	this.abortRequest(id);
	if (context && typeof context.callbackFunErr === "function") {
		context.callbackFunErr(error);
	}

	let12("NR7.handleError. " + JSON.stringify(error));
}

/**
 * Handles error for CR's requests
 *
 * @param {Error} error
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.errorHandlerForCR = function (error, id) {
	this.errorHandler(error, id);
	this.sendNetworkBackup();
}

/**
 * Calls corresponding callback function with response data.
 *
 * @param {XMLHttpRequest} response - server response
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.successHandler = function (response, id) {
	var context = this.getContext(id);
	this.deleteInProgressRequest(id);
	if (context && typeof context.callbackFun === "function") {
		var responseData = this.prepareResponseData(id, response);

		context.callbackFun(responseData);
	}
}

/**
 * Calls corresponding callback function with response data.
 *
 * @param {XMLHttpRequest} response - server response
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.successHandlerForCR = function (response, id) {
    this.successHandler(response, id);
}

/**
 * Prepare response data for callback.
 *
 * @param {string} id - the unique ID of request
 * @param {XMLHttpRequest} response - server response
 *
 * @private
 *
 * @return {object}
 */
NR7.prototype.prepareResponseData = function (id, response) {
	var responseData = {};
	var contentType = response.getResponseHeader("Content-Type") || "";
	contentType = contentType.toLowerCase();

	responseData.id = id;
	responseData.responseStatus = response.status;
	responseData.responseHeaderCacheControl = response.getResponseHeader("Cache-Control") || "";
	if (contentType && !contentType.includes("image/gif")) {
		if (contentType.includes("application/json") && response.responseText) {
			responseData.data = JSON.parse(response.responseText);
		} else {
			responseData.data = response.responseText;
		}
	}

	// when the IE browser is in compatibility mode v7,v8 and loses connection, the status will be unknown.
	if (typeof response.status === "unknown") {
		responseData.responseStatus = 0;
	}

	return responseData;
}

/**
 * Sends all network activity with CR as error log.
 * All requests to CR was saved and will be formatted for log message.
 */
NR7.prototype.sendNetworkBackup = function () {
	var logDataList = [];
	for (var i = 0; i < this.chatrouterRequestsBackup.length; i++) {
		var currentResponse = this.chatrouterRequestsBackup[i].request;
		var logData = {
			"Id": this.chatrouterRequestsBackup[i].id,
			"Response": {
				"readyState": currentResponse.readyState,
				"responseURL": currentResponse.responseURL,
				"status": currentResponse.status,
				"timeout": currentResponse.timeout
			}
		};
		logDataList.push(logData);
	}

	let12(
		"Something went wrong with CR communication, these logs should"
		+ " be investigated. Here all information about network activity with chatrouter. "
		+ JSON.stringify(logDataList),
		true
	);

	this.resetNetworkBackup();
}

/**
 * Process chatrouter's requests. Custom timeout should be added,
 * and request should be saved for backup information.
 *
 * A lot of custom actions required for CR requests, because it basic functionality
 * if something go wrong with them customer won't be able to see agent messages
 * and customer messages won't be sent.
 *
 * @param {string} url - URL to send the request to
 * @param {XMLHttpRequest} request - request
 * @param {Array} parameters - command properties
 * @param {string} id - the unique ID of request
 * @param {Object} context - context with callback functions
 *
 * @private
 */
NR7.prototype.addRequestInProgressForCR = function (url, id, request, context, parameters) {
	var timeout = parseInt(parameters[6], 10) || 0;
	// for our custom timeout add 10s to request timeout
	var requestTimeout = timeout + 10000;

	/*
	 * Url will be got from response object for all browsers except IE,
	 * so for IE URL will be set manually.
	 */
	if (typeof request.responseURL === "undefined") {
		request.responseURL = url;
	}
	this.chatrouterRequestsBackup.push({ id: id, request: request });

	/*
	 * This timeout needed in case if timeout of XMLHttpRequest in browser
	 * doesn't work as expected. Our own timeout will generate an error.
	 * see IJSF-196
	 */
	var timeoutId = setTimeout(
		this.errorHandlerForCR.bind(
			this,
			new Error("Native XMLHttpRequest timeout did not trigger. Triggering our own custom timeout."),
			id
		),
		requestTimeout
	);

	this.addRequestInProgress(id, request, context, timeoutId, parameters);
};

/**
 * Produces required data for sending request
 *
 * @param {string} url - URL to send request
 * @param {object} data - request data
 * @param {string} id - context ID
 * @param {boolean} sync - flags about synchronous request
 * @param {function=} callbackFcn - callback
 * @param {function=} errorCallback - error callback
 * @param {number=} timeout - request timeout
 *
 * @return {object} object which contain required data
 */
NR7.prototype.prepareRequestData = function (url, data, id, sync, callbackFcn, errorCallback, timeout) {
	id = id ? id : generateRequestId("vanity");
	var body = toParamString(data, true, true);
	var command = sync ? "POSTSYNC" : "POSTASYNC";
	var requestData = [command, id, "", "", url, body, timeout];

	if (url.startsWith(vanityUrl)) {
		requestData.push(CHM.getFPSessionID());
	}

	if (!callbackFcn) {
		callbackFcn = function (resp) {
			ROM.onRemoteCallback(resp.id, resp.data);
		};
	}

	return {
		"request": requestData,
		"id": id,
		"context": {
			callbackFun: callbackFcn,
			callbackFunErr: errorCallback
		}
	};
};

/**
 * Adds context and request to in progress list based on id.
 *
 * @param {string} id - the unique ID of request
 * @param {XMLHttpRequest} request - request
 * @param {object} context - context with callback functions
 * @param {number} timeoutId - id of timeout for failing request instead of browser
 * @param {object} parameters - command properties, need for logging
 *
 * @private
 */
NR7.prototype.addRequestInProgress = function (id, request, context, timeoutId, parameters) {
	if (id) {
		if (this.requestsInProgress[id]) {
			let12(
				"Id: " + id + " same as in previous request. "
				+ "Request parameters is " + JSON.stringify(parameters),
				true
			);
		}
		this.requestsInProgress[id] = {
			request: request,
			context: context,
			timeoutId: timeoutId
		};
	} else {
		let12(
			"Id is absent for parameters " + JSON.stringify(parameters),
			true
		);
	}
}

/**
 * Returns request context.
 *
 * @param {string} id - the unique ID of request
 *
 * @private
 *
 * @return {?Object}
 */
NR7.prototype.getContext = function (id) {
	if (this.requestsInProgress[id]) {
		return this.requestsInProgress[id].context;
	}
	return null;
}

/**
 * Returns request.
 *
 * @param {string} id - the unique ID of request
 *
 * @private
 *
 * @return {?XMLHttpRequest}
 */
NR7.prototype.getRequest = function (id) {
	if (this.requestsInProgress[id]) {
		return this.requestsInProgress[id].request;
	}
	return null;
}

/**
 * Deletes request and it's context from list of progress request.
 *
 * @param {string} id - the unique ID of request
 *
 * @private
 */
NR7.prototype.deleteInProgressRequest = function (id) {
	var requestData = this.requestsInProgress[id];
	if (requestData) {
		clearTimeout(requestData.timeoutId);
	}
	delete this.requestsInProgress[id];
}

NR7.prototype.resetNetworkBackup = function () {
	this.chatrouterRequestsBackup.length = 0;
}
	/**
	 * Media Manager
	 * @class MM12
	 * @constructor
	 * @name MM12
	 * @param {Object} data containing the database chat themes and spec and c2c themes and specs.
	 * @borrows XJA3#absorb as #absorb
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @see XJA3
	 * @see FM2
	 */
	function MM12(data) {
		this._frameworkModule("mm");
		this.absorb(data);
		// make all data clonable
		for(var n1 in data){
			for(var n2 in data[n1]){
				MI8.clonize(data[n1][n2]);				
			}
		}
	}
	MI8.prepare(MM12).im13(MI8.XJA3).im13(MI8.FM2);
	MM12.prototype.start = MM12.prototype.reset = MM12.prototype.init = function(){};
	MM12.prototype.embeddedTheme = {prevWidth:0, prevHeight:0, isValid:null};
	/**
	 * Retrieves the C2C spec for a given id.
	 * @param id Number The id of the c2c spec to be retrieved. null s7.
	 * @param subtree Boolean will return the whole C2CSpec/Theme with the Chat spec/theme as subtree if true. Only the c2cSpec if false or undefined.
	 * @return Object The c2cSpec for the given id. Never null.
	 * @throws Error if no spec is found for the given id.
	 */
	MM12.prototype.getC2CSpec = function(id, subtree) {
		var val = this["c2cSpecs"][id];
		if(inu1(val)){
			throw ("MM12-> no c2c spec for id="+id);
		}
		val = MI8.mixAbsorber(val.clone());
		if(!!subtree)
			val.absorb({c2cTheme:this.getC2CTheme(val['thId']), chatSpec:this.getChatSpec(val['chSpId'], subtree)});
		return val;
	};
	/**
	 * Retrieves the C2C theme for a given id.
	 * @param id Number The id of the c2c theme to be retrieved. null s7.
	 * @return Object A clone of the c2c theme for the given id. Never null.
	 * @throws Error if no theme is found for the given id.
	 */
	MM12.prototype.getC2CTheme = function(id) {
		var val = this['c2cThemes'][id];
		if(inu1(val)){
			throw ("MM12-> no c2c theme for id="+id);
		}
		return MI8.mixAbsorber(val.clone());
	};
	
	/**
	 * Retrieves the chat spec for a given id.
	 * @param id Number The id of the chat spec to be retrieved. null s7.
	 * @return Object A clone of the chat spec for the given id. Never null.
	 * @throws Error if no spec is found for the given id.
	 */
	MM12.prototype.getChatSpec = function(id, subtree) {
		var val = this["chatSpecs"][id];
		if(inu1(val)){
			throw ("MM12-> no chat spec for id="+id);
		}
		val = MI8.mixAbsorber(val.clone());
		if(!!subtree)
			val.absorb({chatTheme:this.getChatTheme(val['ctId'])});
		return val;
	};
	/**
	 * Retrieves the chat theme for a given id.
	 * @param id Number The id of the chat theme to be retrieved. null s7.
	 * @return Object A clone of the chat theme for the given id. Never null.
	 * @throws Error if no theme is found for the given id.
	 */
	MM12.prototype.getChatTheme = function(id) {
		var val = this['chatThemes'][id];
		if(inu1(val)){
			throw ("MM12-> no chat theme for id="+id);
		}
		return MI8.mixAbsorber(val.clone());
	};
	
	/**
	 * Merges an xml c2c theme into a DB version of the c2c theme.
	 * @param the xml c2c theme to merge into the db version. Uses the c2c theme id to get the db data
	 * @returns a complete c2c theme instance with data from the c2cTheme param mixed into it
	 */
	MM12.prototype.mergeC2CTheme = function(c2cTheme) {
		var val = !!c2cTheme.id ? this.getC2CTheme(c2cTheme.id) : this.getC2CThemeByName(c2cTheme.name);
		if(!!val){
			return val.absorb(c2cTheme);
		}
		log("MM12 Error: c2cTheme not found for xml theme id="+c2cTheme.id);
		return null;
	};

	/**
	 * Merges an xml chat theme into a DB version of the chat theme.
	 * @param the xml chat theme to merge into the db version. Uses the chat theme id to get the db data
	 * @returns a complete chat theme instance with data from the chatTheme param mix into it
	 */
	MM12.prototype.mergeChatTheme = function(chatTheme) {
		var val = !!chatTheme.id ? this.getChatTheme(chatTheme.id) : this.getChatThemeByName(chatTheme.name); // db value
		if(!!val){
			for(var n in chatTheme){
				val[n] = chatTheme[n];
			}
			return val;
		}
		log("MM12 Error: chatTheme not found for xml theme id="+c2cTheme.id);
		return null;
	};

	/**
	 * Merges an xml chat spec into a DB version of the chat spec.
	 * @param the xml chat spec to merge into the db version. Uses the chat spec id to get the db data
	 * @returns a complete chat spec instance with data from the chatSpec param mixed into it. Includes
	 * merged child chat theme in return value
	 */
	MM12.prototype.mergeChatSpec = function(chatSpec) {
		var val = !!chatSpec.id ? this.getChatSpec(chatSpec.id, true) : this.getChatSpecByName(chatSpec.name, true); // gets whole subtree
		if(!!val){
			chatSpec = this.handleEmbeddedTheme(chatSpec);
			if(!!chatSpec.chatTheme){
				val['chatTheme'] = this.mergeChatTheme(chatSpec.chatTheme);
			}
			for(var n in chatSpec){
				if(n=='chatTheme')
					continue; // skip chat theme... we already have them
				val[n] = chatSpec[n];
			}
			return val;
		}
		log("MM12 Error: chatTheme not found for xml theme id="+c2cTheme.id);
		return null;
	};

	/**
	 * Embedded theme added to the xml chat spec
	 * @param the xml chat spec
	 * @returns the xml chat spec with  embeddedTheme info
	 */
	MM12.prototype.handleEmbeddedTheme = function (chatSpec) {
		try {
			if (!!chatSpec.embeddedTheme && (inu1(chatSpec.embeddedTheme.isValid) || inu1(this.embeddedTheme.isValid))) {
				var embeddedDiv = this.checkEmbeddedDivOnCI(chatSpec);
				if (embeddedDiv || (isWebSDK && window.embeddedFrameCreated)) {
					chatSpec.embeddedTheme.isValid = this.embeddedTheme.isValid = true;
					if(embeddedDiv) {
						chatSpec.embeddedTheme.w = this.embeddedTheme.prevWidth = embeddedDiv.w;
						chatSpec.embeddedTheme.h = this.embeddedTheme.prevHeight = embeddedDiv.h;
					}
					this.embeddedTheme.clientDivId = chatSpec.embeddedTheme.id;
					//handle resize of the container div by resizing the chat
					if (chatSpec.chatTheme.sv != GR34.MODERN_CI_VERSION) {
						window.parent.addEventListener('resize', this.handleEmbeddedDivResizeDebounce);
					}
					if (!!chatSpec.embeddedTheme.chatTheme) {
						if (!!chatSpec.chatTheme && !chatSpec.embeddedTheme.origTheme) {
							chatSpec.embeddedTheme.origTheme = chatSpec.chatTheme;
						}
						chatSpec.chatTheme = chatSpec.embeddedTheme.chatTheme;
					}
				} else { // this is for pages where the div id is not found in the parent page
					chatSpec.embeddedTheme.isValid = this.embeddedTheme.isValid = false;
					if (!!chatSpec.embeddedTheme.origTheme) {
						chatSpec.chatTheme = chatSpec.embeddedTheme.origTheme;
					}
				}
			}
		} catch (msg) {
			log("MM12 Error: handleEmbeddedTheme has error=" + msg);
		}
		return chatSpec;
	};

	   /**
	 * Look for the embedded div on the CI based on the div id and then determine the dimensions.
	 * @param the xml chat spec
	 * @returns embedded div element from the CI
	 */
	MM12.prototype.checkEmbeddedDivOnCI = function (chatSpec) {
		var obj = null;
		try {
			var embeddedDiv = getParentElByIDTFacade(chatSpec.embeddedTheme.id);
			if (embeddedDiv) {
                if (chatSpec.chatTheme.sv == GR34.MODERN_CI_VERSION) {
                    if (embeddedDiv.classList.contains("nuance-chat-floating-container")) {
                        return null;
                    }
                    chatSpec.embeddedTheme.chatTheme.sv = chatSpec.chatTheme.sv;
                }
				var embeddedDivSize = this.getSizeOfEmbeddedDiv(embeddedDiv);
				var embH = embeddedDivSize.h;
				var embW = embeddedDivSize.w;
				if (embH > 0 && embW > 0) {
					obj = {h: embH, w: embW};
				} else if (this.embeddedTheme.prevWidth > 0 && this.embeddedTheme.prevHeight > 0) {
					// if parent div dimensions are not valid, then see if there was any previous dimensions set and use them.
					// This scenario occurs when chat is closed and a new one automatically starts up
					obj = {h: this.embeddedTheme.prevHeight, w: this.embeddedTheme.prevWidth};
				} else if (!!chatSpec.embeddedTheme.chatTheme) {
					//get the default dimensions from embeddedTheme.chatTheme
					var val = !!chatSpec.embeddedTheme.chatTheme.id ? this.getChatTheme(chatSpec.embeddedTheme.chatTheme.id) : this.getChatThemeByName(chatSpec.embeddedTheme.chatTheme.name); // db value
					if (!!val) {
						obj = {h: val.dh, w: val.dw};
					}
				}
			}
		} catch (msg) {
			log("MM12 Error: checkEmbeddedDivOnCI has error=" + msg);
			obj = null;
		}
		return obj;
	};

	/**
	 * getSizeOfEmbeddedDiv()
	 * Merges the DB c2c spec with an xml override model. Designed to safely grab DB
	 * data and selectively override with an xml data model.
	 * @param embeddedDiv The element div
	 * @return Object The height and width of the div
	 */
	MM12.prototype.getSizeOfEmbeddedDiv = function (embeddedDiv) {
		if (doc.defaultView && doc.defaultView.getComputedStyle) {
			//RTDEV-23490: get the height and width from the computed style as this takes care of any margin or padding
			var compObj = doc.defaultView.getComputedStyle(embeddedDiv, "");
			return {h: parseInt(compObj.height), w: parseInt(compObj.width)};
		} else {
			return {h: embeddedDiv.clientHeight, w: embeddedDiv.clientWidth};
		}
	};

	/**
	 * handleEmbeddedDivResizeDebounce
	 *
	 * This compares the current dimensions of the embedded container div with it's stored old values.
	 * If there is a difference, then Resize the embedded chat by calling FlashPeer.ciResizeStage()
	 * Debouncing this call is necessary because the listener is attached to window resize event.
	 * It is assumed here that the dimensions of the div container changes when the browser window
	 * is resized.
	 *
	 * @return A debounce function
	 */
	MM12.prototype.handleEmbeddedDivResizeDebounce = debounce(function () {
		var emdTh = MM.embeddedTheme;
		if (emdTh.isValid) {
			var embeddedDiv = getParentElByIDTFacade(emdTh.clientDivId);
			if (embeddedDiv) {
				var embeddedDivSize = MM.getSizeOfEmbeddedDiv(embeddedDiv);
				var embH = embeddedDivSize.h;
				var embW = embeddedDivSize.w;
				//compare the current dimensions of the div with it's old values. Resize the chat only if there is a difference.
				if (embH > 0 && embW > 0 && (embH != emdTh.prevHeight || embW != emdTh.prevWidth)) {
					//resize the embedded chat window as per the new dimensions.
					inqFrame.Inq.FlashPeer.ciResizeStage(embW, embH);
					//set back the previous height and width with the new values
					emdTh.prevHeight = embH;
					emdTh.prevWidth = embW;
				}
			}
		}
	}, 100);

	/**
	 * Merges the DB c2c spec with an xml override model. Designed to safely grab DB
	 * data and selectively override with an xml data model.
	 * @param c2cSpec Object The c2c spec from xml. Guaranteed to have an ID defined. null s7.
	 * @param excludeChatData Boolean If true, return a model with no chat data models defined. If false
	 * or undefined, return the whole subtree.
	 * @return Object A clone of the chat theme for the given id. Never null.
	 * @throws Error if no spec is found for the given xml spec id.
	 */
	MM12.prototype.mergeC2CSpec = function(c2cSpec, excludeChatData) {
		if(!inu1(c2cSpec)){
			// grab the xml version and mix it in with the database version...
			// load c2c plugin dynamically
			var val;
			if (!!c2cSpec.id) {
				val = this.getC2CSpec(c2cSpec.id, true);
			} else if (c2cSpec.plugin) {
				val = {"plugin": c2cSpec.plugin};
			} else {
				// pure DB version with subtree.
				val = this.getC2CSpecByName(c2cSpec.name, true);
			}
			if(!!excludeChatData){
				delete val.chatSpec;
			}
			if(!!c2cSpec.c2cTheme){
				val['c2cTheme'] = this.mergeC2CTheme(c2cSpec.c2cTheme);
			}
			if(!!c2cSpec.chatSpec && !excludeChatData){
				val['chatSpec'] = this.mergeChatSpec(c2cSpec.chatSpec);
			}
			for(var n in c2cSpec){
				if(n=='c2cTheme' || n=='chatSpec')
					continue; // skip c2c theme and chat spec... we already have them
				val[n] = c2cSpec[n];
			}
			return val;
		}
		else{
			log("MM12 Error: bad c2cSpec passed. Check XML rule actions. ref="+c2cSpec)
		}
		return null;				
	};

    MM12.prototype.getModelIdByName = function(modelName, instanceName){
        var result = null;
        for(var instance in this[modelName]){
            if(this[modelName][instance].name == instanceName){
                result = instance;
                break;
            }
        }
        if(!result){
            throw ("No media for name= "  + instanceName + " found in list of " + modelName);
        }
        return result;
    };

    MM12.prototype.getChatThemeByName = function(name){
        var id = this.getModelIdByName('chatThemes', name);
        return this.getChatTheme(id);
    };

    MM12.prototype.getChatSpecByName = function(name, subtree){
        var id = this.getModelIdByName('chatSpecs', name);
        return this.getChatSpec(id, subtree)
    };

    MM12.prototype.getC2CThemeByName = function(name){
        var id = this.getModelIdByName('c2cThemes', name);
        return this.getC2CTheme(id);
    };

    MM12.prototype.getC2CSpecByName = function(name, subtree){
        var id = this.getModelIdByName('c2cSpecs', name);
        return this.getC2CSpec(id, subtree);
    };

	/**
	 * Construct a URI instance
	 * @constructor
	 * @class
	 * @param {String} uri
	 * @requires MI8.XJA3 
	 */
	function URI(uri){
		/* RU */
		this._uri=uri;
		this.parseURI();
	}
	MI8.prepare(URI).im13(MI8.XJA3);
	
	URI.partNames = ["source","protocol","authority","domain","port","path","dirPath","fileName","query","anchor"];
	/**
	 * parses a URI into component parts
	 * @static
	 * @param {string} _uri uri to be decomposed
	 * @return {Object} object that represents the "decomposed" URI. parts include: 
	 * source, protocol, authority, domain, port, path, dirPath, fileName, query, anchor
	 */
	URI.parseURI=function(_uri){
		/* RU */
		var obj = {qMap:{}};
	    var uriParts = new RegExp("^(?:([^:/?#.]+):)?(?://)?(([^:/?#]*)(?::(\\d*))?)?((/(?:[^?#](?![^?#/]*\\.[^?#/.]+(?:[\\?#]|$)))*/?)?([^?#/]*))?(?:\\?([^#]*))?(?:#(.*))?").exec(_uri);
	    for(var i = 0; i < URI.partNames.length; i++){obj[URI.partNames[i]] = (uriParts[i] ? uriParts[i] : "");}
	    if(obj.dirPath.length > 0){obj.dirPath = obj.dirPath.replace(/\/?$/, "/");}
	    if(obj.query){
			var p = obj.query.split("&");
			for (var i = 0; i < p.length; ++i){
				var kvp = p[i].split("=");
				obj.qMap[kvp[0]] = (kvp.length>1)?unescape(kvp[1]):"";
			}
	    }
	    if(obj.domain){
	    	obj.rootDomain=obj.domain;
	    	var arr = obj.domain.split('.');
	    	if(arr.length>2){
	    		for(var idx = 0;idx < arr.length-2;idx++) arr.shift();
	    		obj.rootDomain=arr.join('.');
	    	}
	    }
	    return obj;
	};
	/**
	 * parses the URI of the instance and saves the data internally
	 */
	URI.prototype.parseURI=function(){
		this.absorb(URI.parseURI(this._uri));
	};
	
	/**
	 * gets the query value of the query name string given.
	 * @param {string} q the name of the query param to be retrieved
	 * @return {string} the value of the query param. null if not existent.
	 */
	URI.prototype.getQ=function(q){
		/* RU */
		var v = this.qMap[q];
		return (typeof v=="undefined"||v==null)?null:v;
	};

	/**
	 * Manages all named functions and provides a framework to invoke
	 * functions in the customer window context
	 * @param {Object} namedFcns
	 * @returns {FcnMgr}
	 */
	function FcnMgr(namedFcns){
		this.fcns = namedFcns;
	}
	FcnMgr.idx = 0;

	/**
	 * gets a named frunction from the registered function lib.
	 * @param {String|Function} fcnOrFcnName The name of the function to retrieve. If a function is passed, then that function is returned.
	 * @throws if fcnOrFcnName param is null or undefined, if the fcn is not found, or the fcnOrFcnName
	 * is of a type other than string or function
	 */
	FcnMgr.prototype.getFcn = function(fcnOrFcnName){
		if(!fcnOrFcnName)
			throw "function name is null or undefined";
		switch(typeof fcnOrFcnName){
		case "string":
		case "function":
			break; // the above are the only types allowed
		default:
			throw "illegal parameter type: "+(typeof fcnOrFcnName);
		}
		var fcn = (typeof fcnOrFcnName=="string")?this.fcns[fcnOrFcnName]:fcnOrFcnName;
		if(!fcn)
			throw "function is null or undefined";
		return fcn;
	}

	/**
	 * @deprecated
	 * TODO FcnMgr#ex8 should be replaced by FcnMgr#callExternalHelper in the future
	 *
	 * Publishes the given function (or named function from the registered lib)
	 * to the parent window and then invokes the function with the given arguments
	 * in the parent window returning the result when complete. May throw certain exceptions.
	 * if v3Lander is undefined then return with null from the method
	 *
	 * @param {String|Function} fcnOrFcnName Either the name of the function to be invoked or the function itself.
	 * @see FcnMgr#getFcn() for errors thrown
	 * @throws if the function invocation throws an error
	 */
	FcnMgr.prototype.ex8 = function(fcnOrFcnName){
        //RTDEV-867. Issue 'win.v3Lander is undefined' is suitable for Firefox 11 and higher.
        if(!window.self.parent.v3Lander){
			let12("window.self.parent.v3Lander is undefined, ex8 returns null", true);
            return null;
        }
		var fcn = this.getFcn(fcnOrFcnName);
		var name = this.publish(fcn);
		var args = this._normArgs(arguments);
		var retval = null;
		try{
            retval = window.self.parent.v3Lander.FMProxy.getFcn(name).apply(window.self.parent, args);
		}catch(err){
			throw "function eval failed. err="+err.toString();
		}
		this.unpublish(name);
		return retval;
	};

	/**
	 * Invokes the helper function from parent window with the given arguments
	 * in the parent window returning the result when complete. May throw certain exceptions.
     * if v3Lander is undefined then return with null from the method
	 * @param fcName {String} The name of the function to be invoked
	 * @throws if the function invocation throws an error
	 */
	FcnMgr.prototype.callExternalHelper = function(fcName){
        //RTDEV-867. Issue 'win.v3Lander is undefined' is suitable for Firefox 11 and higher.
		var args = this._normArgs(arguments);
		if (isWebSDK) {
			return this.callExternalHelperForWebSDK(fcName, args)
		}
        if(!window.self.parent.v3Lander){
			let12("window.self.parent.v3Lander is undefined, callExternalHelper returns null", true);
            return null;
        }
		try{
            return window.self.parent.v3Lander.FMProxy.getHelperFcn(fcName).apply(window.self.parent, args);
		}catch(err) {
			throw "Error: Call external helper function failed." + "fcName: " + fcName + ". err=" + err.toString();
		}
	};
	/**
	 * Call parent window helper functions, but swallow errors. See Utils.s7()
	 * @param fcName {String} The name of the function to be invoked
	 * @throws if the function invocation throws an error
	 */
	FcnMgr.prototype.callExternalHelperSafe = function(fcName, dflt, sendErrorToTagServer){
		try{
			var retval = this.callExternalHelper(fcName);
            return safeResult(retval);
		}catch(err){
			log(err, "log"); //log locally is debugger enabled
			if (sendErrorToTagServer) {
				let12(cf21(err));
			}
		}
		return dflt;
	};

	FcnMgr.prototype.callExternalHelperForWebSDK = function(fcName,args) {
		try {
			return window.v3Lander.FMProxy.getHelperFcn(fcName).apply(window.self, args);
		}catch(err){
			throw "Error: Call helper function failed." + "fcName: " + fcName + ". err="+err.toString();
		}
	}
	/**
	 * Removes the first argument from the list of arguments provided. We
	 * do this because the remaining args are presumably for the target function
	 * The first arg (0 arg) is the name of the function to be invoked and should not
	 * be passed to that function as an argument.
	 */
	FcnMgr.prototype._normArgs = function(argumnts){
		var args = [];
		if(argumnts.length>1){
			for(var idx=1; idx<argumnts.length; idx++){
				args[idx-1] = argumnts[idx];
			}
		}
		return args;
	};

	/**
	 * @param fcnOrFcnName {String|Function}
	 * @see FcnMgr#getFcn() for errors thrown
	 * @throws if the function invocation throws an error
	 */
	FcnMgr.prototype.exec = function(fcnOrFcnName){
		var fcn = this.getFcn(fcnOrFcnName);
		try{
			return fcn.apply(self,  this._normArgs(arguments));
		}catch(err){
			throw "function eval failed. err="+err.toString();
		}
	};
	/**
	 * publishes a given function
	 */
	FcnMgr.prototype.publish = function(fcn, name){
		var name = !!name?name:'fcn_'+FcnMgr.idx++;
        window.self.parent.v3Lander.FMProxy.addFcn(name, fcn.toString());
		return name;
	};

	/**
	 * Deletes a named function from the parent peer.
	 */
	FcnMgr.prototype.unpublish = function(name){
        window.self.parent.v3Lander.FMProxy.removeFcn(name);
	};

		/**
		 * CM47 is responsible for saving and reading name-value pairs to/from a named cookie.
		 *
		 * @constructor
		 * @param {string} id is the identifier for this object
		 * @param {boolean} xd specifies whether this site uses cross-domain cookies
		 * @author joconner
		 * @borrows RC54#onRemoteCallback as #onRemoteCallback
		 * @borrows RC54#callRemote as #callRemote
		 * @borrows FM2#init as #init
		 * @borrows FM2#start as #start
		 * @borrows FM2#reset as #reset
		 * @see RC54
		 * @see FM2
		 * @see #getInstance(xd)
		 */
		function CM47(id, xd) {
			this._frameworkModule(id);
			this.xd = xd;
			this.cookies = {}; // used in cross-domain mode
			this.JSON = MI8.JSON;
			this.version = 3;
			this.initMessagingComplete = false; /*used to ensure initialization happens only once */
			this.set3rdPartyCookieBusy = false;
	        this.set3rdPartyCookieQueue = [];
	        this.overflowLogged = false; // flag used to avoid TS log flood (log overflow once per landing)
			this.trdPartyCookieCnt = 0;     // 3rd party cookie counter (for vital).
			this.isLSused = false;          // True if localStorage is used.
			this.cntHandlerTried = 0;       // how many times checked 3rd party cookie commited handler function.
			/* cookie cleaning detection flag to block the duplication of logging error
			 * during the one chat session in the page instance, updated when the page is refreshed */
			this.cleaningDetected = false;
			this.resourcesType = {};

			/* will try to detect the cleaning of local data
			 * (local storage, session storage and indirectly the cookie)
			 * through the setting up the listener of storage event */
			this.configureStorageListener();
		}
		MI8.prepare(CM47).im13(MI8.FM2).im13(MI8.RC54);
		CM47.CM = null;

		/**
		 * Retrieve the singleton instance of CM47. The first call to this method
		 * will determine whether cross-domain is supported. Subsequent calls will
		 * ignore the xd param.
		 * @param xd a boolean flag for cross-domain mode; true if cross-domain, false otherwise;
		 * @return the CM47 instance
		 */
		CM47.getInstance = function(xd) {
			if(CM47.CM == null) {
				CM47.CM = new CM47("CM", xd);
			}
			return CM47.CM;
		};

		CM47.prototype.init = function(){
			if (this.initialized) return;
			this.initialized = true;
			log(this.getID()+" initialized.");
			this.initMessagingComplete = this.initMessaging();
			this.initResourcesType();
			this.clearOutdatedCookies();
		};

		/**
		 * Sends CLEARSTORAGE command to remove redundant cookies
		 * if using localStorage
		 */
		CM47.prototype.clearOutdatedCookies = function() {
			if (getClearOutdatedCookies()) {
				var clearOutdatedCookiesRequest = ["CLEARSTORAGE"];
				this.postRequestToIframeProxy(clearOutdatedCookiesRequest);
			}
		};

		CM47.prototype.initResourcesType = function () {
			for (var res in resources) {
				try {
					if (typeof resources[res]["getName"] === "function") {
						this.resourcesType[resources[res].getName()] = resources[res].getStorageType();
					}
				} catch (e) {
					log(e, "error");
				}
			}
		};

		CM47.prototype.start = function() {
			if (this.started) return;
			this.started=true;
		};

		/**
		 * Obtains a reference to the CM47 "peer" in the main window if in persistent window.
		 * @returns null if not persistent win OR the broser's same origin policy prohibits communication.
		 * Otherwise it returns a ref to the CM in the main window.
		 */
		CM47.prototype.getPeer = function(){
			return (isSameOrigin() && isPersistentWindow())?window.parent.opener.inqFrame.Inq.CM : null;
		};

		/**
		 * Method that updates the name-value pair in a given cookie cache. This will only be set in memory
		 * and, when in persistent window, also updates the cookie cache of the main window (same origin permitting).
		 * If value is undefined, name-value pair is deleted from cache.
		 * @param {String} cName The cookie name for the n-v pair
		 * @param {String} name Name of the value to be set in the cookie cache.
		 * @param {Object} value the value to be set for the given name in the cookie cache.
		 * 	If undefined, name-value pair is deleted from cookie.
		 * @param {boolean} isJSON optional flag that tells the method how to treat the value.
		 * @param {boolean} update if true then tries to update cache data in another(opener/persistent) window
		 * If undefined, null or false, the value will be treated as a std pass-thru object. If true
		 * then the value will be treated as a JSON string to be parsed before processing.
		 */
        CM47.prototype.r479m = function(cName, name, value, isJSON, update){
            if (!inu1(value)) {
                value = !!isJSON?MI8.JSON.parse(decodeURIComponent(value)):value;
            }
            if(!update) {
                if(isPersistentWindow() && !this.cleaningDetected) {
                    try{
                        var cmPeer = this.getPeer();
                        if(!!cmPeer) {
                            if(cmPeer.persistentWindow != win) {
                                cmPeer.persistentWindow = win;
                            }
                            if (!inu1(value)) {
                                cmPeer.r479m(cName, name, encodeURIComponent(MI8.JSON.stringify(value)), true,true);
                            } else {
                                cmPeer.r479m(cName, name,null,null,true);
                            }
                        }
                    }catch(err) {
                        log("Error propagating value to main window from Cookie manager.");
                    }
                }
                else {
                    try {
                        if (!!this.persistentWindow && !this.persistentWindow.closed) {
                            var cmPersistent = this.persistentWindow.inqFrame.Inq.CM;
                            if (!!cmPersistent) {
                                if (!inu1(value)) {
                                    cmPersistent.r479m(cName, name, encodeURIComponent(MI8.JSON.stringify(value)), true, true);
                                } else {
                                    cmPersistent.r479m(cName, name, null, null, true);
                                }
                            }
                        }
                    } catch (err) {
                        log("Error propagating value to persistent");
                    }
                }

            }
            if (inu1(value)) {
                if (this.cookies[cName]) {
                    delete this.cookies[cName][name];
                }
            } else {
                if (!this.cookies[cName]) {
                    this.cookies[cName] = {};
                }
                this.cookies[cName][name] = value;
            }
        };

        /**
		 * Write a name-value pair to a cookie.
		 * If value is undefined, name-value pair is deleted from cookie.
		 *
		 * @param {CCD} cRes
		 * @param {String} name of a key or variable
		 * @param {Object} value of the key or variable. If undefined, name-value pair is deleted from cookie.
		 * @param {function=} callback - function which should be called when data in cookies will be saved
		 */
		CM47.prototype.write = function(cRes, name, value, callback) {
			var cObj = null;
			var cVal = null;
			var cName = cRes.getName();
			var cookieError = null;

			// PERSISTENT_COOKIE_ALLOWED resource is used to test if persistent cookie are allowed, it is excluded here to avoid recursion.
			// undefined value means cookie size won't be increased, thus no need to do overflow prediction
			// there is no need to compare Cookie size if localStorage is used
            if (cName != COOKIE_PC_NAME && value != undefined && !this.isLSused) {

				var predictedResult;
	            try{
		            predictedResult = this.pr11m(cRes, name, value);
	            }catch(err) {
		            if (err.constructor === cdsm || err.constructor === CookieSizeError) {
			            cookieError = err;
			            log(cookieError.toString()); // log the result to console
			            predictedResult = cookieError.getData().result; // record the overage
		            }
	            }
	            // if we are overflowing the cookie domain space, we need to cull cookies
	            // (and not the one we are writing to if we can help it)
				if (!!cookieError && predictedResult != 0) {
					var overflowObject = {_domain: "error", evt: "cookieoverflow", params: {custID: Inq.getCustID(), siteID: getSiteID(), resource: cName, varId: name, size: JSON.stringify(value).length, sessionId: getSessionID(), incAssignmentID: asi4(), incGroup: getIncGroupID()}};
					var msg = "Cookie overflow!";
					if(cookieError.constructor == cdsm) {
						var pruneSuccessful = this.pco12(predictedResult, cRes.getPurgePriority());
						msg += " New cookie overflows domain limit";
						if (pruneSuccessful) {
							log("ERROR: variable named '" + name + "' (size=" + value.length + ") write aborted and cookie (name=" + cName + ") overflowed and dropped. VER34: {" + name + ":\"" + value + "\"");
						}
						overflowObject["pruneSuccess"] = pruneSuccessful;
					}
					else if(cookieError.constructor === CookieSizeError){
						// at this point we are overflowing a single cookie and can't write any more data to it
						// The only thing we CAN do is to ignore the write and log the problem. Cookie is abused.
						msg += " cookie is packed to limit. Data dropped.";
						log("WARNING: Cookie overflowed when writing variable. varId="+name+", cookieName="+cName+", varSize="+value.length+", attemptedValue="+value);
					}
					if(!this.overflowLogged) {
						overflowObject["Log2ETL"] = true;
						overflowObject["params"]["msg"] = msg;
						let12(JSON.stringify(overflowObject));
						this.overflowLogged = true;
					}
					// Prevent write when exceeding cookie size
					if (cookieError.constructor === CookieSizeError) {
						if (typeof callback === "function") {
							callback();
						}
						return;
					}
				}
			}

			if (this.xd) {
				this.r479m(cName, name, value);
			}
			if (this.cleaningDetected) {
				if (typeof callback === "function") {
					callback();
				}
				return;
			}
			/* Only update the xd (cross domain) cookie if it has changed,
			 * The cookies are saved one request after another,
			 * Writing unchanged values just causes over queueing of the requests
			 * We check to see if the object has been modified by comparing the "stringify'ed" objects
			 * If the json string has any "out of order" values, we get a false difference and the cookie goes out, no problem.
			 */
			if (this.xd) {
				this.checkCookieValidity();
				// We have do it due to IE11 runs cookieValidationCallback synchronously.
				if (this.cleaningDetected) { // DO NOT DELETE THIS CHECK
					if (typeof callback === "function") {
						callback();
					}
					return;
				}
				var oldValue = this.JSON.stringify(this.cookies[cName]);				/* get the cookie value before adding new stuff */
				if( cRes.getResourceID() == "vital" ) { 		/* If this is vital, then update the version */
					this.cookies[cName]["v"] = this.version;
					this.cookies[cName]["vcnt"] = this.trdPartyCookieCnt++ ;
                    this.cookies[cName]["vtime"] = (new Date).getTime() ;
				}
				var newValue = this.JSON.stringify(this.cookies[cName]);
                /*
                 * In case we are overriding the incrementalityID value, write that error to server logs.
                 */
                try {
                    if (cRes.getResourceID() == "vital" && !inu1(oldValue) && oldValue.indexOf("_iID") != -1 ) {
                        if (inu1(newValue) || newValue.indexOf("_iID") == -1) {
                            ROM.send(urls.loggingURL, {level:'ERROR', line: ("overriding the incrAssignmentID for siteID="+Inq.getSiteID()+" customerID="+Inq.getCustID()+"oldValue="+oldValue+"newValue ="+newValue)});
                        }
                    }
                } catch(e){
                    log("Error:overriding the valid incrAssignmentID for siteID"+Inq.getSiteID()+" customerID="+Inq.getCustID());
                }

				this.s3d(
					"SCBR3_PM",
					getSiteID(),
					cName,
					this.cookies[cName],
					cRes.getLifetime(),
					null,
					callback
				);
			} else {
				var c = this._getCookie(cName);
				if(c == null) {
					cObj = {};
				} else {
					try {
						cObj = this.JSON.parse(c);
					} catch(e) {
						cObj = {};
					}
				}
				/* If (c) above is a null string and it as json parsed, we are left with cObj being null
				   So we will check to make sure cObj is at least a {} */
				if (cObj == null) cObj = {} ;
				if (inu1(value)) {
					delete cObj[name];
				} else {
					cObj[name] = value;
				}
				if( cRes.getResourceID() == "vital" ) {
					cObj["v"] = this.version;
				}
				cVal = this.JSON.stringify(cObj);
				this._setCookie(cRes, cVal);
				if (typeof callback === "function") {
					callback();
				}
			}
		};

		/**
		 * Read a value from a cookie
		 * @param {CCD} cRes defines the cookie name and its properties
		 * @param {String} name is the name/key associated with the value
		 * @return the value associated with the name, which will need to be cast inside
		 * a variable to determine true type
		 * @type Object
		 */
		CM47.prototype.read = function(cRes, name) {
			var cVal = null;
			var cName = cRes.getName();
			if (this.xd) {
				try {
					if (!inu1(this.cookies[cName])) {
						cVal = this.cookies[cName][name];
					}
				} catch(e) {
					// return default null value because
					// either the cookie or the name/value
					// have not yet been written
					log(e);
				}
			} else {
				var c=this._getCookie(cName);
				var cObj = null;
				try {
					if (c) {
						cObj = this.JSON.parse(c);
						if(cObj != null) {
							// retrieve name-value
							cVal = cObj[name];
						}
					}
				} catch(e) {
					log(e);
				}
			}
			return cVal;
		};

		/**
		 * Clear a cookie from the document. If in xd mode, this
		 * method clears the 3rd party cookie. Clearing a cookie
		 * means that its name-value pairs are removed.
		 * @param {string} cResId id of the cookie resource to clear.
		 */
		CM47.prototype.clear = function(cResId) {
			var cRes = resources[cResId];
			var storage = cRes.getStorageType();
			if (this.xd) {
				var cName = cRes.getName();
				delete this.cookies[cName];
				// clear cookie in browser
				// set date in past to expire the cookie
				this.s3d("SCBR3_PM", siteID, cName, null, -1*86400000, storage);//set date in past to expire the cookie
				// Log the clearing of the cookie in server log
				logInfoToTagServer("Clear cookie " + cName);
			} else {
				if (storage) {
					SM.clearStoredValue(cRes);
				} else {
					this.expireCookie(cResId); // make browser delete this cookie
				}
			}
		};

        /**
         * Dump all cookie values. For xd mode only
		 * Ask the IFrame-Proxy to dump the cookie value to the TagServer's log
		 * Please see: in postToServer.htm function doCommands command "DUMP"
		 * @return none
		 */
		CM47.prototype.dump = function() {
			if (this.xd) {
                var boxID = "box" + Math.floor(Math.random()*1000011);
				var postCookieRequest = ["DUMP", boxID, "", "", encodeURIComponent(secureHTTP(urls.loggingURL))];
                this.postRequestToIframeProxy(postCookieRequest, boxID);
			}
		};

		/**
		 * CookieSizeError
		 * @param cName {string} cookie name
		 * @param size {number} current size of the target 0cookie
		 * @param delta {number} size of the value to be added to the target cookie
		 * @param limit {number} cookie domain limit for the browser
		 * @param result {number} amount over limit
		 * @constructor
		 */
		function CookieSizeError(cName, size, delta, limit, result){
			this.getData = function(){return {cookieName: cName, oldSize:size, delta:delta, limit:limit, result:result};};
			this.toString = function(){return "CookieSizeError: Cookie size violated, proposed size="+(size + delta)+", limit="+limit+", result="+result;};
		}
		/**
		 * cdsm
		 * @param cName {string} cookie name
		 * @param size {number} current size of the target 0cookie
		 * @param delta {number} size of the value to be added to the target cookie
		 * @param limit {number} cookie domain limit for the browser
		 * @param result {number} amount over limit
 		 * @constructor
		 */
		function cdsm(cName, size, delta, limit, result){
			this.getData = function(){return {cookieName: cName, oldSize:size, delta:delta, limit:limit, result:result};};
			this.toString = function(){return "cdsm: Cookie domain size violated, proposed size="+(size + delta)+", limit="+limit+", result="+result;};
		}

		/**
		 * This function has the same parameters as write() and is used by write() to check if limits will be exceeded
		 * prior to actually updating cookies.
		 * @param {CCD} cRes defines the cookie name and its properties
		 * @param {String} name of a key or variable
		 * @param {Object} value of the key or variable
		 * @return {Number} 0 if limits are not expected to be exceeded, overflow byte count otherwise
		 */
		CM47.prototype.pr11m = function(cRes, name, value) {
			// calculate size of new name-value pair
			var newObj = {};
			newObj[name] = value;
			var newObjSize = encodeURIComponent(this.JSON.stringify(newObj)).length;

			// calculate size of current name-value pair
			var oldObjSize = 0;
			var cName = cRes.getName();
			var cObj = {};
			if (this.xd) {
				if (this.cookies[cName]) {
					cObj = this.cookies[cName];
				}
			} else {
				var c = this._getCookie(cName);
				if(c) {
					try {
						cObj = this.JSON.parse(c);
					} catch(e) {
						// in this unlikely case we will rely on write() function to handle the error
					}
				}
			}
			if (!inu1(cObj[name])) {
				oldObjSize = encodeURIComponent(this.JSON.stringify(cObj[name])).length;
			}

			// negative delta means cookie size will be decreased as result of write
			var predictedDelta = newObjSize - oldObjSize;
			if (predictedDelta > 0) {
				var cResSize = this.getCookieSize(cRes); // get current cookie size
				var cookieLimit = csl11();
				if (cookieLimit && (cResSize + predictedDelta > cookieLimit)) {
					throw new CookieSizeError(cName,cResSize, predictedDelta, cookieLimit, cResSize + predictedDelta - cookieLimit);
				} else {
					var totalSize = this.getCookieSize(); // get total cookies size for domain
					var cookieTotalLimit = ctl12();
					if (cookieTotalLimit && (totalSize + predictedDelta > cookieTotalLimit)) {
						throw new cdsm(cName, totalSize, predictedDelta, cookieTotalLimit, totalSize + predictedDelta - cookieTotalLimit);
					}
				}
			}
			return 0;
		};

		/**
		 * Returns size the cookie corresponding to the specified CCD occupies.
		 * If CCD is not specified, total size of cookies in current domain is returned (used for browsers
		 * that set limits for total size of cookies for a domain).
		 * It is a helper method used in cookie overflow detection and cleanup.
		 * @param {CCD} cRes defines the cookie name and its properties
		 * @return {number} size of the specified cookie
		 */
		CM47.prototype.getCookieSize = function(cRes) {
			var size = 0;
			if (!cRes) {
				if (this.xd) {
					// Calculation of total cookie size for XD mode makes assumption that only cookies created by
					// IJSF cookie resources reside in vanity domain. W/o this assumption cookie size would
					// have to be requested from IFrame proxy
					for (var res in resources) {
						if (resources[res].constructor === CCD) {
							size += this.getCookieSize(resources[res]);
						}
					}
				} else {
					size = document.cookie.length;
				}
			} else {
				var cName = cRes.getName();
				var cVal;
				if (this.xd) {
					cVal = this.JSON.stringify(this.cookies[cName]);
				} else {
					cVal = this._getCookie(cName);
				}
				if (cVal) size = cName.length + 1 + encodeURIComponent(cVal).length;
			}
			return size;
		};

		/**
		 * Performs cleanup of cookies according to RTDEV-6927 guidelines:
		 * Cookies need to be limited for XD and nonXD modes. Core cookies, especially the inqVital cookie, should be
		 * protected at all times. The other cookies should be cleared in the following order and context.
		 * Two categories of cookie space violations apply here:
		 * 1. Cookie domain limit is exceeded
		 * For Domain limit violations, we need to drop cookies in presiding order until enough space is freed to allow
		 * the current cookie write. If enough space is not harvested to allow the write, we log the situation and drop
		 * the write. The following rules apply...
		 *      1a. Non-core cookies should be dropped in order of priority.
		 *      1b. inqState cookie should be cleared first if data exceeds 4k limit on IE6/7 or safari
		 *      1c. inqSession cookie should be cleared 2nd if data exceeds 4k limit on IE6/7 or safari
		 *      1d. inqVital cookie should never be cleared...if we cannot write to the cookie without exceeding the 4k limit,
		 * 	then we should abort the write and log the issue once to the tagserver.
		 * 	For #1c, if a chat is in progress...then we should abort the write rather then purge the session cookie and
		 * 	thus the chat
		 * 2. "per cookie" limit is exceeded.
		 * For "Per Cookie" violations, we drop the write and report the condition to our servers. Core cookies should
		 * not be dropped.
		 * @param {number} byteCountToFree parameter specifying how many bytes must be freed
		 * @param {number} currentCookiePriority parameter specifying the priority of the cookie that is overflowing
		 * @return {boolean} true if required space was freed, false otherwise. If false is returned, write to cookie must be
		 * aborted.
		 */
		CM47.prototype.pco12 = function(byteCountToFree, currentCookiePriority) {
			var cookiesToPrune = [];
			var bytesFreed = 0;

			currentCookiePriority = (inu1(currentCookiePriority)?0:currentCookiePriority);
			var _resources = Object.keys(resources).map(function(k){return resources[k];}).filter(function(a){return !inu1(a) && a.constructor===CCD && (a.getPurgePriority() > currentCookiePriority); });
			_resources.sort(CCD.COOKIE_RESOURCE_PURGE_PRIORITY_SORT_FCN);

			for(var idx=0; idx<_resources.length; idx++){
				var resource = _resources[idx];
				// found an expendable resource
				log("************* "+resource.getResourceID()+" will be cleared.");
				// tally up the cookie bytes to be freed... continue if we don't have enough.
				bytesFreed += this.getCookieSize(resource);
				cookiesToPrune.push(resource); // axe the cookie
				if (bytesFreed >= byteCountToFree) {
					break; // stop chopping resources if we've freed enough space
				}
			}
			if(bytesFreed < byteCountToFree && currentCookiePriority==0) { // only scavenge our core cookies if/when we have freed others first.
				var stateRes = resources["state"]; // chop the state cookie
				bytesFreed +=  this.getCookieSize(stateRes);
				if (bytesFreed >= byteCountToFree) {
					cookiesToPrune.push(stateRes); // we have enough... stop chopping
				} else if (!CHM.isChatInProgress()) {
					// apparently we still need to cut, kill the
					// session cookie only if we are not in a chat
					var sesRes = resources["session"];
					bytesFreed += this.getCookieSize(sesRes);
					if (bytesFreed >= byteCountToFree) {
						cookiesToPrune.push(stateRes);
						cookiesToPrune.push(sesRes);
					}
				}
			}

			// prune what we can
			if (cookiesToPrune.length > 0) {
				// Log clearing of cookies in browser console and TS log
				var cookieNames = cookiesToPrune.collect(function(cres){ return cres.getName();});
				var msg = "Cookie overflow! Trying to clear following cookie(s): " + cookieNames.join(',') + ". ";
				if (!this.overflowLogged) { // log overflow to TS once per landing
					let12(msg, true);
					this.overflowLogged = true;
				}

				for (var i = 0; i < cookiesToPrune.length; i++) {
					this.clear(cookiesToPrune[i].getResourceID());
				}
			}
			return bytesFreed >= byteCountToFree; // we report if we were successful in pruning everything requested
		};

		/**
         * We will be deprecating this cookie persistance mode.
		 * Set a cookie value. This is a very low-level API that sets an entire cookie in the document. This
		 * is a <b>private</b> method.
		 * @param {CCD} cRes
		 * @param {String} cVal
		 * @param {String} cLifetime optional parameter, specifies cookie lifetime in ms; valid values integer >= 0.
		 *
		 */
		CM47.prototype._setCookie = function(cRes, cVal, cLifetime) {
			var name = cRes.getName();
			var lifetime = cRes.getLifetime();
			if (!!cLifetime) lifetime = cLifetime;
			var path = cRes.getPath();
			var domain = cRes.getDomain();

			// set time, it's in milliseconds
			var now = new Date();
			var expires_date = new Date( now.getTime() + lifetime );

			var update;

            // fix to make use non cross domain persistence work just to keep the solution running until deprecated
            domain = domain.replace(/(^\w+:|^)\/\//, '');

			// pc cookie is used to test weather the browser accepts persistent cookies or not.
			// To make the check the pc cookie has to be a persistent cookie.
			if ((name == COOKIE_PC_NAME || this.isPersistentCookiesAllowed()) && lifetime>0){
				update = name + "=" + encodeURIComponent(cVal) +
				";expires=" + expires_date.toGMTString() +
				( ( path ) ? ";path=" + path : "" ) +
				((domain) ? ";domain=" + domain : "") + "; Secure";
			} else {
				// If the browser does not accepts persistent cookies - make all cookies as session cookies
				update = name + "=" + encodeURIComponent(cVal) +
				( ( path ) ? ";path=" + path : "" ) +
				(( domain) ? ";domain=" + domain : "") + "; Secure";
			}

			document.cookie = update;
		};

		/**
		 * Retrieve an entire cookie.
		 * This is a <b>private</b> method. Access available for easy testing.
		 * @param {String} cName CookieName
		 * @param {String} data
		 * @return the value of a cookie, null if the cookie does not exist
		 * @type String
		 */
		CM47.prototype._getCookie = function(cName, data) {
			var cookies = this._getCookies(data);
			if(!!cookies && !!cookies[cName]){
				return cookies[cName];
			}
			return null;
		};

		/**
		 * Gets all cookies as name-value pairs in an object map (<String,String>).
		 * This is a <b>private</b> method. Access available for easy testing.
		 * @param {string=} data optional data parameter that represents a
		 * cookie string to be parsed
		 * @return the value of a cookie, null if the cookie does not exist
		 * @type String
		 */
		CM47.prototype._getCookies = function(data) {
			// first split this cookie up into sub-cookie pairs
			// note: document.cookie only returns name=value, not the other components
			var a_all_cookies =  (inu1(data)) ? document.cookie.split( COOKIE_DELIMITER ) : data.split( COOKIE_DELIMITER );
			var retval = null;

			a_all_cookies.forEach( function(cookie) {
				// now we'll split apart each name=value pair
                var delim_index = cookie.indexOf('=');

				// and trim left/right whitespace while we're at it
				var cookie_name = (delim_index > 0 ? cookie.substring(0, delim_index) : cookie).replace(/^\s+|\s+$/g, '');

                var cookie_value = '';

				// if the extracted name matches passed check_name
			    // we need to handle case where cookie has no value but e9 (no = sign, that is):
				if (delim_index > 0 && delim_index < cookie.length - 1) {
                    cookie_value = decodeURIComponent( cookie.substring(delim_index + 1).replace(/^\s+|\s+$/g, '') );
                }
				if(retval==null)
					retval = {};
					// note that in cases where cookie is initialized but no value, null is returned
				retval[cookie_name] = cookie_value;
			});
			return retval;
		};

		/**
		 * @param {Object} cookieData contains a JSON object contain whole cookie values
		 * {"inqState": {...}, "inqVital": {"INQ": {...}, ...}, "inqSession": {...}}
		 */
		CM47.prototype.setXDCookies = function(cookieData) {
			this.cookies = cookieData;
			this.checkDataIntegrity();
			if ( cookieData && cookieData.pc && cookieData.pc == 2 ) {
				this.isLSused = true;
			}
		};

		/**
		 * In FF we need set cache data in PersistentWindow from main page.
		 * Problem in FireFox, in iframe from third party domain it nested browsing context SessionStorage is destroyed
		 * and a new one create, when we create new windowÂ across window.open().
		 */
		CM47.prototype.checkDataIntegrity = function() {
			var cacheCookiesInParentWin = openerCall("getCachedCookies");
			if (isFF() && cacheCookiesInParentWin) {
				var cacheCookiesKeys = Object.keys(cacheCookiesInParentWin);
				for (var i = 0; i < cacheCookiesKeys.length; i++) {
					var resourceName = cacheCookiesKeys[i];
					if (!this.cookies[resourceName] && this.resourcesType[resourceName] === "sessionStorage") {
						this.cookies[resourceName] = cacheCookiesInParentWin[resourceName];
					}
				}
			}
		};

		/**
		 * Returns cookie cache, if them not been cleaned
		 * @return {?Object}
		 */
		CM47.prototype.getCachedCookies = function() {
			if (!this.cleaningDetected) {
				return this.cookies;
			}
			return null;
		};

		/**
		  *	Establish the listener for 3rd party cookie queue becoming empty
		  */
		CM47.prototype.onThirdPartyCookieQueueEmpty = null;

		/**
		  *	Establish a collection of handlers for 3rd party cookie queue becoming empty
		  */
		CM47.prototype.onThirdPartyCookieQueueEmptyHandlers = [];

		/**
		  *	Handlers can added into 3rd party cookie queue. - only one handler to keep system simple.
		  */
		CM47.prototype.on3rdPartyCookieCommittedHandler = null;

		/**
		  *	Test for third party cookie queue empty and idle (no cookie saving is in progress)
		  */
		CM47.prototype.isThirdPartyCookieQueueEmpty = function() {
			return (0==this.set3rdPartyCookieQueue.length) && !this.set3rdPartyCookieBusy;
		};

		/**
		 * s3d - sets third-party cookie via an iframe-proxy
		 * details:
		 *    An IFRAME with source from domain of the vanity domain performs the cookie setting on behalf of this domain.
		 *    Inq.CM.s3d asks the IFRAME to set the cookie on our behalf.
		 *
		 *    Use call of Inq.FlashPeer.set3rdPartyCookieFromQueue() instead of direct call of Inq.CM.s3d(...)
		 *
		 * @param {string} cmd - command for invoke the corresponding function in postToServer.js
		 * @param {number} site - site id
		 * @param {string} name - cookie name
		 * @param {Object} delta - cookie value
		 * @param {number=} expiry - lifetime in milliseconds
		 * @param {string=} storageType - is localStorage or sessionStorage
		 * @param {function=} callback - function which should be called when data in storage will be saved
		 *
		 * @author fpinn@TouchCommerce.com
		 * @see set3rdPartyCookieFromQueue
		 * @see HTML file postToServer.js which performs the cookie setting via command "SCBR3_PM" (Set Cookie BR3)
		 */
		CM47.prototype.s3d = function(cmd, site, name, delta, expiry, storageType, callback) {
		        // Current origin:            http://www.touchcommerce.com
                // Target origin for cookies: http://home.inq.com (for example)

	            if (!expiry) expiry="";
	            if(inu1(cmd) || inu1(site) || inu1(name)) return;

	            var boxID = "box" + Math.floor(Math.random()*1000011);
				var sDelta = "";
				if (!inu1(delta)) {
					if (typeof delta === "object") {
						if (storageType) {
							sDelta = this.JSON.stringify(delta);
						} else {
							sDelta = encodeURIComponent(this.JSON.stringify(delta));
						}
					} else {
						sDelta = "" + delta;
					}
				}

			// TODO remove secure flag, it is here only for backward compatibility. IJSF-233
			var postCookie = [cmd, boxID, site, "", name, sDelta, storageType, expiry, true];

			/*
			 Put the cookie message on the queue if queue is empty
			 If queue is not empty find if the cookie (by name) is in the queue and replace it
			 The new cookie trumps the old cookie, it is it's replacement
			 If the cookie name is not in the queue then put cookie at tail of queue
			 BTW: The count for the queue will never exceed the number of cookie names
			 */

			// Look for a match, check the cookie name against the name in the queue object
			for (var i = 0; i < this.set3rdPartyCookieQueue.length; i++) {
				if (this.set3rdPartyCookieQueue[i].name == name) {
					this.set3rdPartyCookieQueue[i].postCookie = postCookie;
					this.set3rdPartyCookieQueue[i].callbacks.push(callback);
					break;
				}
			}
			// If the queue length is equal to the index from the for-loop, then we did not find a match
			if (this.set3rdPartyCookieQueue.length === i) {
				this.set3rdPartyCookieQueue.push({
					name: name,
					postCookie: postCookie,
					callbacks: [callback]
				});
			}

	            /* If we are busy, leave the message queued and return */
	            if (this.set3rdPartyCookieBusy) return;

	             /* Set busy flag */
	            this.set3rdPartyCookieBusy=true;

				/* Call the function to write 3rdPartyCookie in queue */
				this.set3rdPartyCookieFromQueue();
		};

	        /**
	          * set3rdPartyCookieQueue - sets queued third-party cookie via an iframe-proxy
	          *                          if no queued third-party cookie, then set set3rdPartyCookieBusy to false
	          * called by the Iframe-Proxy postToServer.htm after cookie has been set.
	          *
	          * details:
			  *    An IFRAME with source from domain of the vanity domain performs the cookie setting on behalf of this domain.
			  *    Inq.CM.s3d asks the IFRAME to set the cookie on our behalf.
			  *
			  *    Use call of Inq.FlashPeer.set3rdPartyCookieFromQueue() instead of direct call of Inq.CM.s3d(...)
              *
	          *  1) get cookie request from queue
	          *  2) if cookie request is NOT avalable THEN set busy flag to false
	          *  3) ELSE create boxID and put it in the cookie request then post the request to the IFrame-Proxy
	          *
	          * @see s3d
	          * @see HTML file postToServer.js which performs the cookie setting via command "SCBR3_PM" (Set Cookie BR3)
	          */
	        CM47.prototype.set3rdPartyCookieFromQueue = function() {
				/** @type {Object} */
				var cookieQItem = this.set3rdPartyCookieQueue[0];
				/** @typr {?function} */
				var callback;
				if (this.set3rdPartyCookieQueue.length > 0) {
					var errorCallback = function(e) {
						this.proxyError(e);
						this.set3rdPartyCookieFromQueue()
					}.bind(this);
					this.postRequestToIframeProxy(cookieQItem.postCookie, cookieQItem.postCookie[1], null, errorCallback);
				} else {
					// We only get here if we have an empty cookie queue
					this.set3rdPartyCookieBusy = false;
					// Check to see that we have a listener for an empty queue
					if (this.onThirdPartyCookieQueueEmpty != null) {
						// fire the listener
						this.onThirdPartyCookieQueueEmpty();
					}
				}
				if (!inu1(cookieQItem)) {
					while (cookieQItem.callbacks && cookieQItem.callbacks.length > 0) {
						callback = cookieQItem.callbacks.shift();
						if (typeof callback === "function") {
							callback();
						}
					}
					this.set3rdPartyCookieQueue.shift();
				}
			};


			/** This calls supplied function once the cookies have been committed.
			 *
			 * @param {function} handler - handler to be called when committed
			 */
			CM47.prototype.whenCookiesCommitted = function(handler) {
				if (this.xd) {
					// Queue is empty, do the handler
					if (this.isThirdPartyCookieQueueEmpty()) {
						handler();
					} else {
						/*
						 We have a queue, so setup listener for cookie queue
						 empty and register the handler
						 */
						this.onThirdPartyCookieQueueEmptyHandlers.push(handler);
						// This is the listener for cookie queue empty
						this.onThirdPartyCookieQueueEmpty = this.whenCookiesFireHandlers.bind(this);
						/*
						 Check queue again, just in case the cookie came
						 in before the handler was established
						 */
						if (this.isThirdPartyCookieQueueEmpty()) {
							this.whenCookiesFireHandlers();
						}
					}
				} else {
					// Not xd mode, do the handler
					handler();
				}
			};

			 /**
			  * This function will add a handler into set3rdPartyCookieQueue to obey sequence.
			  * @param {Function} handler - handler to be called when committed
			  */
			CM47.prototype.setWhen3rdPartyCookieCommittedHandler = function(handler) {
				if (this.xd) {
					try {
						var boxID = "box" + Math.floor(Math.random()*1000011);
						var postCookieRequest = ["COMMITPOINT", boxID, getSiteID(), "", encodeURIComponent(urls.loggingURL)];

						if (handler) {
							this.on3rdPartyCookieCommittedHandler = { "vcnt": this.cookies["inqVital"]['vcnt'] , "callback" : handler } ;
						}

						this.set3rdPartyCookieQueue.push({
								name: "inqCallBack" + Math.floor(Math.random() * 1000011),
								postCookie: postCookieRequest,
								callbacks: []
							});

						if (!this.set3rdPartyCookieBusy) {
							this.set3rdPartyCookieBusy = true;
							this.set3rdPartyCookieFromQueue();
						}
					} catch (e) {
						log("exception in setWhen3rdPartyCookieCommittedHandler(): " + e.message, "error");
					}
				} else {
					return false;
				}

			};

			/**
			  * Executes handler from queue in sequence and continue the queue.
			  * @param {Number} vcnt
			  */
			CM47.prototype.when3rdPartyCookieCommitted = function(vcnt) {
				if (null != this.on3rdPartyCookieCommittedHandler) {
					try {
						if ( !this.isLSused || this.cntHandlerTried >= 120 || (typeof vcnt !== "undefined" && this.on3rdPartyCookieCommittedHandler["vcnt"] <= vcnt) )
						{
							this.on3rdPartyCookieCommittedHandler["callback"]();
							this.on3rdPartyCookieCommittedHandler = null;
							this.cntHandlerTried = 0;
							this.set3rdPartyCookieFromQueue();
						} else {
							this.cntHandlerTried += 1;
							this.set3rdPartyCookieBusy = false;
							this.setWhen3rdPartyCookieCommittedHandler();
						}
					} catch (e) {
						log("exception in CM47.prototype.when3rdPartyCookieCommitted: " + e.message, "error");
					}
				} else {
					this.set3rdPartyCookieFromQueue();
				}
			};

			/**
             * This calls all supplied functions once the cookies have been committed.
			 */
			CM47.prototype.whenCookiesFireHandlers=function(){
                log("CM47.whenCookiesFireHandlers() entered: got " + this.onThirdPartyCookieQueueEmptyHandlers.length + " handler(s).");
				this.onThirdPartyCookieQueueEmpty = null;
				while (this.onThirdPartyCookieQueueEmptyHandlers.length>0) {
					var handlerRoutine = this.onThirdPartyCookieQueueEmptyHandlers.shift();
					if (handlerRoutine){
						try {
                            handlerRoutine(); /* perform the handler */
                        } catch (e) {
                            log("exception in whenCookiesFireHandlers(): " + e.message, "error");
                        }
					}
				}
			};

	        /**
	         * postRequestToIframe - create new iframe-proxy to do some work
	         * Put the request (the command and data) in the NAME field of the new iframe
	         * details:
	         *    An IFRAME with source from domain of the vanity domain performs work specified by the request parameter.
	         *
			 * @param url - alternative path (XD mode)
	         * @param request - the command and data for the proxy-iframe to run as array
			 * @param id - iframe id (box id)
			 * @param context - callback function
	         * @author  fpinn@TouchCommerce.com
	         * @see HTML file postToServer.htm which performs the cookie setting via command in request
			 * @see authorize (cbc.js)
	         * @see checkAuthorized (cbc.js)
	         */

            CM47.prototype.postRequestToIframe = function (url, request, id, context) {
                // On 1pc persistent solution, hosted file of the domain should be continuously used.
                //postRequestToIframeProxy is getting to an infinite loop .If first party cookie is solution is enabled and hostFileURLUse is null
				if (xdAutoSelect && CM47.xdPsHelper.enabled && CM47.xdPsHelper.hostFileURLUse) { // it's a first party cookie
                    LoadM.postRequestToIframeProxy(CM47.xdPsHelper.hostFileURLUse + "?POST2SERVER", request, id, context);
				} else if (xdAutoSelect && CM47.chatSessionHelper.isEnabled && CM47.xdPsHelper.hostFileURLUse) {
					LoadM.postRequestToIframeProxy(CM47.xdPsHelper.hostFileURLUse + "?POST2SERVER", request, id, context);
				} else {
                    LoadM.postRequestToIframeProxy(url, request, id, context);
                }
            };

			/**
			 * Defines callback function for postRequestToIframe.
			 *
			 * @param request - the command and data for the proxy-iframe to run as array
			 * @param id - iframe id (box id)
			 * @param {function=} callback - callback function
			 * @param {function=} errorCallback - errorCallback function
			 */
			CM47.prototype.postRequestToIframeProxy = function (request, id, callback, errorCallback) {
                var context = {};
                context["callbackFun"] = callback || CM47.processMessage;
				context["callbackFunErr"] = errorCallback || this.proxyError;
				this.postRequestToIframe(this.getIFrameBaseURL(), request, id, context);
            };

			/**
			 *  Return iFrame base URL
			 *  Store it in this._iFrameBaseURL, change protocol to HTTPS if browser thpe is Safari and not Chrome.
			 *
			 */
			CM47.prototype.getIFrameBaseURL = function() {

                if (typeof this._iFrameBaseURL == 'undefined') {
					this._iFrameBaseURL = Inq.urls.baseURL.split("/",3).join("/") ;
                    this._iFrameBaseURL = secureHTTP( this._iFrameBaseURL );
                }

                return  this._iFrameBaseURL;
			};

          CM47.processMessage = function(context) {
                try {
					if(context.data && context.data.action) {
						/**
						 *  context.data.action value to "3rdPCQ" is set in PostToServer.js doSCBR3PMCommand function
						 */
						if(context.data.action == "3rdPCQ") {
							window.inqFrame.Inq.FlashPeer.set3rdPartyCookieFromQueue();
						} else {
							window.inqFrame.Inq.FlashPeer.when3rdPartyCookieCommitted(context.data.resp);
						}
					} else {
						ROM.onRemoteCallback(context.id, context.data);
					}
                } catch(fault){
                    ROM.post(urls.loggingURL, {level:'ERROR', line: ('CM47.processMessage>> '+cf21(fault))});
                }
            };

			/**
			 * Create new post2Server iframe-proxy to get sub-domain Cookies.
			 * Handles clientHosted flag when clients are hosting postToServer
			 * files on their own servers.
			 * 
			 * @param {Array} request - postToServer array containing command properties
			 * @param {String} baseUrl - url to post to
			 * @param {function} callBackFunction - function to call on success
			 */
			CM47.prototype.submitPost2ServerProcessRequest = function (request, baseUrl, callBackFunction) {
				/**
				 * This will call the hosted file which will load postToServer.js file.
				 * When javascript is hosted by clients, to load PostToServer.js 
				 * from their domain we had to pass the client static url domain 
				 * as URL query string. Because the IFrame does not have access to parent document.
				*/
				var frameSrc = baseUrl + "?POST2SERVER";
				if ((site.noJSHosting && site.clientStaticUrl) || isWebSDK) {
					frameSrc += "&clientHosted=true";
				}
				var context = {};
				context["callbackFun"] = callBackFunction;
				var uniqueRequestId = request[1];
				LoadM.postRequestToIframeProxy(
					frameSrc, request, uniqueRequestId, context
				);
			};

            /**
             *
             *  1pc ps sloution: 1st party cookie - persistent solution
             *
             *  Background: Safari on iOS 7 does not provide appropriate localStorage implementation
             *  and changes are lost once you move page to page.
             *  To overcome, CM47.xdPsHelper object uses 1pc ps solution
             *
             *  Requirements
             *  inqVital.vtime cookie value in number type.
             *  site.hostedfileURL must be List of fully qualified URL
             *  site.cookie policy.
             *
             */
            CM47.xdPsHelper = {};
            CM47.xdPsHelper.hostFileURLUse = "";
            CM47.xdPsHelper.enabled = false;
            CM47.xdPsHelper.isInFirstCookieProcess = false;
			CM47.xdPsHelper.checkedDomainsCount = 0;
			/**
			 CM47.xdPsHelper.errorCode
			 used to save error code.

			 Detail
			 ------------------------------------
			 0 = "No Error";
			 1 = "CM47.xdPsHelper.requestSavedXdCookies() is called with wrong arguments";
			 2 = "Not able to find host file for the current domain, CM47.xdPsHelper.hostFileURLUse is not defined";
			 */
			CM47.xdPsHelper.errorCode = 0;


			/**
             *  isIos7
             *  Return True if the device is iphone or ipad and browser is Safari.
             *
             */
            CM47.xdPsHelper.isIos7 = function( uagent ) {
                return /(iPad|iPhone).*OS 7/i.test( uagent ) ;
            };

            /**
             *  Return true if 1pc is enabled.
             *  Writes simple random number to cookie to check and delete it on success.
             *
             * @return {*}
             */
            CM47.xdPsHelper.is1pcEnabled = function () {
                var COOKIE_PCTEST_NAME = "inqPctest";
                if (typeof CM47.xdPsHelper.isUse1pcXdSolution.pc1Enabled == 'undefined') {
                    var value = Math.floor(Math.random() * 101);
                    var expiry = (new Date((new Date()).getTime() + (366 * 24 * 3600 * 1000))).toGMTString();
					var isSecure = FP.getClientPageURL().startsWith("https:");
					document.cookie = COOKIE_PCTEST_NAME + "=" + value + ";"
						+ (isSecure ? " SameSite=None; Secure;" : "")
						+ "path=/; expires=" + expiry + ";";
                    CM47.xdPsHelper.isUse1pcXdSolution.pc1Enabled = (document.cookie.indexOf(COOKIE_PCTEST_NAME + "=" + value) !== -1);
					document.cookie = COOKIE_PCTEST_NAME + "=" + value + ";"
						+ (isSecure ? " SameSite=None; Secure;" : "")
						+ "path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT";
                }
				return CM47.xdPsHelper.isUse1pcXdSolution.pc1Enabled;
            };

            /**
             *  isUse1pcXdSolution ()
             *  Return true if 1pc ps solution can be used on
             *	We also test for uiWebview so we can support Vodafone App
             */
            CM47.xdPsHelper.isUse1pcXdSolution = function( ) {
                // To test iOS 7       > CM47.xdPsHelper.isIos7( navigator.userAgent )
                // To test safari      > isSafari()
                // To test 1pc enabled > CM47.xdPsHelper.is1pcEnabled()
				var uiWebView = isIOSWebView();
				var androidWebview = /Android.*?(wv|Version\/[.0-9]+).*?Mobile/i.test(navigator.userAgent);

				if(androidWebview) {
					// Default Internet browser on Android 4.4.2
					// doesn't support 1pc solution and this code will make it use 3pc solution.
					if( /Android 4\.4\.2/i.test(navigator.userAgent) ) return false;
				}

				if(isCEAPIPostChatSurveyMode()) {
					return false;
				}
				/* We want to use this solution for uiWebview instances as well.
				 * The uiWebView is the safari PROCESSING_INSTRUCTION_NODE
				 */
				/**
				 * client who are hosting our JavaScript should be checked for first party solution first
				 */
				var is1pcClient = (uiWebView || androidWebview || isSafari() || site.noJSHosting);
				var is1pcClientEnabled = is1pcClient && CM47.xdPsHelper.is1pcEnabled();

                return (is1pcClientEnabled || (isWebSDK && !CM47.xdPsHelper.is1pcEnabled()));
            };

			/**
			 *  isUse1pcXdSolutionOnIE ()
			 *  Return true if 1pc ps solution can be used on IE
			 */
			CM47.xdPsHelper.isUse1pcXdSolutionOnIE = function( ) {
				return isIE() && CM47.xdPsHelper.is1pcEnabled();
			};

            /**
             *   An Array to hold domains and data.
             */
            CM47.xdPsHelper.domains2Check = [];

			/**
			 * Puts domains to CM47.xdPsHelper.domains2Check.
			 * Checks if URL is valid and no duplication is found.
			 * @param {string} hostedUrl
			 * @this CM47.xdPsHelper.domains2Check
			 */
            CM47.xdPsHelper.domains2Check.pushHostedFileUrl = function( hostedUrl ) {
				hostedUrl = hostedUrl.replace('*', '');
				var ob = CM47.parseUrl(hostedUrl);
				if (ob != null && !this.contains(ob, function (a, b) { return a.hostname == b.hostname; }) ) {
                    this.push( ob );
                }
            };

            CM47.xdPsHelper.domains2Check.assignDataByOrigin = function(origin, context) {
                for (var i = 0; i < this.length; i++ ) {
                    if ( origin.indexOf(this[i].origin)!==-1 ) {
                        this[i].context = context;
                    }
                }
                return null;
            };

			/**
			 *  findLastCookieData()
			 *  returns the latest data among all sub-domain cookies.
			 *
			 */
			CM47.xdPsHelper.domains2Check.findEntryWithLatestCookie = function() {
				var date = null;
				var latestDate = null;
				var theobj = null;

				for (var i = 0; i < this.length; i++) {
					date = this[i] && this[i].context && this[i].context.data && getDateFromData(this[i].context.data);
					if (!inu1(date) && date > latestDate) {
						theobj = this[i];
						latestDate = date;
					}
				}

				if (inu1(theobj)) {
					for (var j = 0; j < this.length; j++) {
						if (this[j].domain == (inqFrame.location.domain ? inqFrame.location.domain : CM47.parseUrl(inqFrame.location.href).domain )) {
							theobj = this[j];
						}
					}
				}

				return theobj;

				/**
                 *  getDateFromData(data)
                 *  Return time from inqVital.vtime which should be last updated time of inqVital.
                 */
                function getDateFromData(data) {
                    var date = null;
                    var dateStr = decodeURIComponent(data);
                    var dateReg = /vtime(\")?:([0-9]*)/i;
                    if ( dateReg.test(dateStr) ){
                        date = dateReg.exec(dateStr)[2];
                    }
                    return date;
                }
            };

            /**
             *  requestSavedXdCookie:
             *  Examines all domains to the given site and find the latest cookie created.
             *
             *  Back ground info:
             *  Safari on iOS 7 does not provide access to 3pc localStorage correctly.
             *  3pc localStorage created on one main domain(parent) will lost on another main domain.
             *
             *  To work around this issue:
             *  Safari considers a sub-domain as 1pc cookie and a cookie from other doamin is always readable.
             *  Sub-domain 1pc cookie is used to persist variables and chat continues on a site page in a different domain
             *
             *  Note FF does not support sub-domain 1pc cooke.
             */
            CM47.xdPsHelper.requestSavedXdCookies = function() {
				// checking all domains for the site including same domain
				// then compare timestamp to get latest cookie entries.
				// then call main function.
				if (!CM47.xdPsHelper.populateDomains2Check()) {
					//If no domains available for fist party cookie solution , try to get chat working with 3rdParty
					if (site.noJSHosting || isWebSDK) {
						CM47.xdPsHelper.isUse1pcXdSolution.pc1Enabled = false;
						CM.requestCookie(function (context) {
							Inq.IFrameProxyCallback(context.data);
						});
					}
					return;
				}
				CM47.xdPsHelper.enabled = true;
                CM47.xdPsHelper.isInFirstCookieProcess = true;
                for (var i = 0; i < CM47.xdPsHelper.domains2Check.length; i++ ) {
                    CM47.xdPsHelper.callFirstPostRequestToIframeProxy(CM47.xdPsHelper.domains2Check[i].href);
                }
            };

            // Create box id and submit xd cookie process request.
			CM47.xdPsHelper.callFirstPostRequestToIframeProxy = function (hostedURL) {
                var boxID = "box" + Math.floor(Math.random()*1000011);
                var postCookieRequest = ["GCBR3", boxID, null, "", "no action"];
				CM.submitPost2ServerProcessRequest(
					postCookieRequest,
					hostedURL,
					CM47.xdPsHelper.processSavedXdCookie
				);
			};

            /**
             *  Populates hostedUrls and CM47.xdPsHelper.domains2Check
             *  hosted file URLs are used as is without Protocol change since
             *  some clients do not provide https protocol or vise versa.
             */
            CM47.xdPsHelper.populateDomains2Check = function () {
                var result = false;
                // sample: var hostedUrls = [ "http://www.touchcommerce.com/TouchCommercetop.html", "https://tc.inq.com/TouchCommercetop.html" ];
                var hostedUrls = (typeof urls.siteHostedFileURL === "string") ? urls.siteHostedFileURL.split(",") : [];
				var domainsList = urls.siteHostedFileDomains ? urls.siteHostedFileDomains.split(",") : [];
                if(hostedUrls.length > 1 || hostedUrls[0].trim() != "")  {
					for (var j = 0; j < hostedUrls.length; j++ ) {
						/*
						 * hostedUrls[j] will be NOT added into CM47.xdPsHelper.domains2Check[]
						 * if hostedUrls[j] contains a duplicated hosted file in a same domain
						 */
						CM47.xdPsHelper.domains2Check.pushHostedFileUrl(hostedUrls[j].trim());
					}

					var parsedUrl;
					if (isWebSDK) {
						parsedUrl = CM47.parseUrl(window.pageUrl);
					} else {
						parsedUrl = CM47.parseUrl(inqFrame.location.href);
					}

					if (CM47.xdPsHelper.findHostFileURLByHost(parsedUrl)
						|| CM47.xdPsHelper.findHostFileURLByDomain(parsedUrl, domainsList)
					) {
						result = true;
	                }
                }

                if (inu1(CM47.xdPsHelper.hostFileURLUse) || CM47.xdPsHelper.hostFileURLUse == "") {
                    CM47.xdPsHelper.errorCode = 2;
                    result = false;
                }
                return result;
            };

			/**
			 * Tries to find host file url by matching host
			 * @param {URL|Object} parsedUrl - parsed inqFrame.location.href
			 * @return {boolean} return true if hostFileURL was found
			 */
			CM47.xdPsHelper.findHostFileURLByHost = function (parsedUrl) {
				var domains2Check = CM47.xdPsHelper.domains2Check;

				for (var i = 0; i < domains2Check.length; i++) {
					// double check needed because cookies can be store in
					// parent domain, even if in domains2Check list we have
					// only a sub-domains
					if ( CM47.xdPsHelper.isURLsMatch(domains2Check[i].hostname, parsedUrl.hostname)
						|| CM47.xdPsHelper.isURLsMatch(parsedUrl.hostname, domains2Check[i].hostname)
					) {
						CM47.xdPsHelper.hostFileURLUse = domains2Check[i].href;
						return true;
					}
				}
				return false;
			};

			/**
			 * Tries to find host file url by matching domain
			 * @param {Object} parsedUrl - parsed inqFrame.location.href
			 * @param {Array} domainsList - array of domains
			 * @return {boolean} return true if hostFileURL was found
			 */
			CM47.xdPsHelper.findHostFileURLByDomain = function (parsedUrl, domainsList) {
				var domains2Check = CM47.xdPsHelper.domains2Check;
				var result = false;
				var currentDomain;
				var i;

				for (i = 0; i < domainsList.length; i++) {
					// double check needed because cookies can be store in
					// parent domain, even if in domains2Check list we have
					// only a sub-domains
					if (CM47.xdPsHelper.isURLsMatch(domainsList[i], parsedUrl.hostname)
						|| CM47.xdPsHelper.isURLsMatch(parsedUrl.hostname, domainsList[i])
					) {
						currentDomain = domainsList[i];
						result = true;
						break;
					}
				}

				if (!currentDomain) {
					if (domainsList.length === 0) {
						currentDomain = parsedUrl.domain;
					} else {
						lwt12(
							"Domain of current url: " + parsedUrl.href
							+ " doesn't contains in domain list"
						);
						return result;
					}
				}

				for (i = 0; i < domains2Check.length; i++) {
					if (domains2Check[i].domain.lastIndexOf(currentDomain) > -1
						|| currentDomain.lastIndexOf(domains2Check[i].domain) > -1
					) {
						if (!result) {
                            logInfoToTagServer(parsedUrl.href + " url " + domains2Check[i].href
								+ " will be use for host file, entry missing in ciSettings hostedFileDomains"
							);
						}
						CM47.xdPsHelper.hostFileURLUse = domains2Check[i].href;
						result = true;
						break;
					}
				}

				return result;
			};

			/**
			 * Checks if URLs match.
			 * Matched part should be in the end of first url
			 * and it should be a whole domain.
			 * @param {string} firstURL
			 * @param {string} secondURL
			 * @return {boolean}
			 */
			CM47.xdPsHelper.isURLsMatch = function (firstURL, secondURL) {
				if (!firstURL.endsWith(secondURL)) {
					return false;
				}
				// the previous character after the match must be '.',
				// then we can be sure that this is not an attackerâ€™s domain
				var wholeDomainMatched = firstURL.charAt(firstURL.lastIndexOf(secondURL) - 1) === ".";
				var domainsEquals = firstURL === secondURL;
				return wholeDomainMatched || domainsEquals;
			};

            CM47.xdPsHelper.processSavedXdCookie = function(context) {
                CM47.xdPsHelper.domains2Check.assignDataByOrigin(context.origin, context);
                var theob;
				CM47.xdPsHelper.checkedDomainsCount += 1;
                // When we have cookies from all domains of a site, select latest data and start chat process.
				if (CM47.xdPsHelper.checkedDomainsCount >= CM47.xdPsHelper.domains2Check.length) {
                    theob = CM47.xdPsHelper.domains2Check.findEntryWithLatestCookie();
	                var data = theob ? theob.context.data : context.data;
                    CM47.xdPsHelper.isInFirstCookieProcess = false;
	                Inq.IFrameProxyCallback(data);
                }
            };

            /**
             *  firstRequestCookie: Check if 1pc ps solution can be used (mush for iOS 7)
             *  then initiate the process,
             *  or try to use conventional localStorage ps solution.
             *  For webSDK since its already a 3rd Party to the parent page, IPC supported logic for safari is blocked.
             *  We have fall back logic to check if 3rd Party tagserver domain is blocked then force First Party cookie solution to be used
             */
            CM47.firstRequestCookie = function(){
				if (CM47.xdPsHelper.isUse1pcXdSolution()) {
					// Use cached key id method for noJSHosting and localStorage
					if ((site.noJSHosting || isWebSDK) && isSafari()) {
						CM47.chatSessionHelper.startCachePersistentSolution();
					} else {
						// Use 1pc persistent XD solution.
						CM47.xdPsHelper.requestSavedXdCookies();
					}

                } else if ((window.forceFPCookie && CM47.xdPsHelper.is1pcEnabled())
                    || (isWebSDK && !CM47.xdPsHelper.is1pcEnabled())) {
					CM47.xdPsHelper.requestSavedXdCookies();
                } else {
                    CM.requestCookie(function(context) {
	                    /* Forwards the context to IFrameProxyCallback handler with the correct "this" context.
	                     * When this handler is invoked, "this" is pointing to the window, not the Inq context.
	                     * @see LR45.handleSuccess
	                     * We correct that by calling the IFrameProxyCallback via the anonymous function.
	                     */
	                    Inq.IFrameProxyCallback(context.data);
                    });
                }
            };

	      /**
	        * requestCookie: get the cookie datas from the third party cookies
	        * Ask an iframe-proxy to get the cookie settings
	        * An IFRAME with source from domain of the vanity domain performs the cookie retrieval on behalf of this domain.
	        *
			* @param callback - callback function
	        * @param param - param used as a prefix for the cookie names
	        * @see HTML file postToServer.htm which performs the cookie retrieval via command "GCBR3" (Get Cookie BR3)
	        *
	        */
	        CM47.prototype.requestCookie = function(callback, param) {
				param = param || "";
	            var boxID = "box" + Math.floor(Math.random()*1000011);
				var postCookieRequest = ["GCBR3", boxID, param, "", "no action"];
	            this.postRequestToIframeProxy(postCookieRequest, boxID, callback);
	        };

			/**
			 * Calls CM47#requestCookie when all cookies from CookiesMgr
			 * queue will be sent to postToServer.
			 *
			 * @param {function} callback - callback function
			 * @param {string} param - param used as a prefix for the cookie names
			 *
			 * @see CM47#requestCookie
			 */
			CM47.prototype.requestCookieSynchronously = function(callback, param) {
				this.whenCookiesCommitted(this.requestCookie.bind(this, callback, param));
			};

			/**
			 * @deprecated by RTDEV-29434 and RTDEV-29652
			 * <br/> updateCACookie
			 * <br/> Updates chatActive value of GR34 instance from cookie.
			 * <br/> Note: chatActive cookie is used only in "XD" mode.
			 *
			 * @param callbackFunc {function}
			 */
			CM47.prototype.updateCACookie = function(callbackFunc){
				if (this.xd) {
					var param = "inqCA_"+ Inq.siteID;
					var callback = function(context) {
                        var cObj = this._getCookies(context.data);
                        this.setV3ActiveValue(cObj[param]);
						callbackFunc();
					};
					this.requestCookieSynchronously(callback.bind(this), param);
				} else {
					callbackFunc();
				}
			};

			/**
			 * In xd mode - send request to postToServer for inqSession, invoke updateChatData.
			 * <br/> In non-xd mode - invoke updateChatData.
			 *
			 * @param {function} callbackFunc
			 */
			CM47.prototype.requestSessionData = function (callbackFunc) {
				if (this.xd) {
					this.requestCookieSynchronously(
						this.updateChatData.bind(this, callbackFunc),
						"inqSession_"  + getSiteID()
					);
				} else {
					this.updateChatData(callbackFunc);
				}
			};

			/** Update chat data in GR34.
			 * @param {function} callbackFunc
			 * @param {Object=} context of callback object from LR45
			 */
			CM47.prototype.updateChatData = function (callbackFunc, context) {
				/** @type {Object} */
				var data = {};
				if (this.xd) {
					data = parseCookieData(this._getCookies(context.data));
				} else {
					data = parseCookieData(this._getCookies());
				}
				var chatData = data["inqSession"] ? data["inqSession"]["chat"] : null;
				CHM.updateChatData(chatData);
				callbackFunc();
			};

	       /**
	        * initMessaging: creates the re-usable iframe-proxies.
	        * a) Check to ensure that this initialization happens only once.
	        * b) Ensure that postMessage is available for our use
	        * c) Establish message handler for receiving posted messages
	        * d) Create a bunch of iframe-proxies for our use.
	        * @return {boolean}
	        */

	        CM47.prototype.initMessaging = function(){
	            if (this.initMessagingComplete) return true;
				/* Publish the proxy error routine
				 * BTW: This is how GWT does it,
				 * this way we do not have to put it in FlashPeer,
				 */
	            Inq["proxyError"] = this.proxyError;
				return true;
	        };

		/**
		 * Function proxyError - Logs the stack trace into the tag server log
		 * The stack trace is sent to the tagserver via POST not GET
		 * this is necessary do to the size of the trace.
		 * @param {String} errorText - the text describing the error
		 */
		CM47.prototype.proxyError = function(errorText) {
            ROM.post(urls.loggingURL, {level:"ERROR", line: encodeURIComponent(errorText)});
        };

		CM47.prototype.onRemoteCallback = function(data) {
			this.setXDCookies(data);
		};

		/**
		 * Expires cookie stored by a resource with specified id which makes browser delete this cookie.
		 * @param cookieResourceId id of cookie resource to expire
		 */
		CM47.prototype.expireCookie = function(cookieResourceId) {
			log("EXPIRING COOKIE \"" + cookieResourceId + "\"");
			var cRes = resources[cookieResourceId];
			this._setCookie(cRes, "", -1);
		};

		/**
		 * isPersistentCookiesAllowed is to know weather the browser accepts persistent cookies or not
		 *
		 * In some browsers users can select the option of not accepting persistent cookies.
		 * This function helps to cross check if the browser accepts persistent cookies or not.
		 */
		CM47.prototype.isPersistentCookiesAllowed = function() {
			if (inu1(this.isPersistentCookiesEnabled)) {
				/*
				 * This is used only for nonXD mode. For xd mode
				 * isPersistentCookiesEnabled will be set in
				 * IFrameProxyCallback or in IFrameTSCallback
				 */
				var pcVar = new VER34(
					PERSISTENT_COOKIE_ALLOWED,
					{},
					resources[PERSISTENT_COOKIE_ALLOWED]
				);
				pcVar.z3({});
				var enabled = !!this.read(resources[PERSISTENT_COOKIE_ALLOWED], PERSISTENT_COOKIE_ALLOWED);

				if (enabled) {
					this.expireCookie(PERSISTENT_COOKIE_ALLOWED);
				}
				this.isPersistentCookiesEnabled = enabled;
			}
			return this.isPersistentCookiesEnabled;
		};

		CM47.isSessionCookiesEnabled = null;
		/**
		 * Return true if session cookie is enabled in browser.
		 * Note This test does not tell persistent cookie status.
		 *
		 */
		CM47.isSessionCookiesAllowed = function() {
			if (CM47.isSessionCookiesEnabled == null) {

				var c_value = Math.floor(Math.random()*1001), c_name = 'sPc';

				CM47.isSessionCookiesEnabled = false;
				document.cookie=c_name + "=" + c_value;

			    if ((document.cookie.indexOf(c_name) != -1) && (document.cookie.indexOf(c_value) != -1)) {
		    		CM47.isSessionCookiesEnabled = true;
		    		document.cookie=c_name + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
			    }
			}
			return CM47.isSessionCookiesEnabled;
		};

		CM47.prototype.getV3ActiveValue = function() {
			return this.cookies["inqCA"];
		};

		CM47.prototype.setV3ActiveValue = function(value) {
			if (!this.cleaningDetected) {
				this.cookies["inqCA"] = value;
			}
		};

		/**
		 * Add the handler on "storage" event to track the changes of local storage,
		 *    and track the case when clearing of storage leads to removing data of chat session.
		 *    For example, when user clears the all cookies and data in browser.
		 *
		 * @see CM47.prototype.onStorageChange
		 */
		CM47.prototype.configureStorageListener = function() {
			if (storageAvailable("localStorage")) {
				this.setStorageTracker();
				attachListener(window, "storage", this.onStorageChange.bind(this), false);
			}
		};

		/**
		 * Set the beacon to track the "storage" event.
		 * It is needed only if the local storage is empty,
		 * because if local storage is empty then event "storage" will be not fired.
		 * Will use the "sessionStorage" because we don't need to have a persistent value for tracking.
		 */
		CM47.prototype.setStorageTracker = function() {
			if (localStorage.length == 0) {
				localStorage.setItem("inqTracking", 0);
			}
		};

		/**
		 * Fired on storage event and calls the function to validate the current cookie state.
		 *
		 * @see CM47.prototype.configureStorageListener
		 * @see CM47.prototype.checkCookieValidity
		 * @this CM47
		 * @param {Object} e - The storage event (StorageEvent) is fired when a storage area
		 *                     (localStorage or sessionStorage) has been modified.
		 * @returns {void}
		 */
		CM47.prototype.onStorageChange = function(e) {
			this.checkCookieValidity();
			this.setStorageTracker();
		};

		/**
		 *   Checks the state of chat on the page and if chat is active
		 * and when earlier on this chat session cookie cleaning was not detected,
		 * then requests the cookie value from iframe and validates it by the callback.
		 *
		 *   The cookie saved mainly in the 3rd party domain,
		 * but anyway we working with them by proxy iframe,
		 * thus we can validate it only asynchronously.
		 * Therefore the validation will be done in the callback.
		 *
		 * @see CM47.prototype.requestCookie
		 * @see CM47.prototype.cookieValidationCallback - this is a callback function
		 * @returns {void}
		 */
		CM47.prototype.checkCookieValidity = function() {
			if (!this.cleaningDetected && CHM && CHM.isChatInProgress()) {
				this.requestCookie(this.cookieValidationCallback.bind(this));
			}
		};

		/**
		 * Checks that the previous value of the cookie matches the current state of CM47.
		 * If not - then sends the log-error to TagServer about invalid cookie state.
		 *
		 * @this CM47
		 * @param {Object} context - see LR45.getContext
		 */
		CM47.prototype.cookieValidationCallback = function(context) {
			/* Check the state of chat (the chat activity)
			 * and the detection of cookie cleaning during the chat session,
			 * to avoid the duplication of logging error,
			 * because this function is invoked asynchronously,
			 * and thus can be invoked multiple times till the processing.
			 */
			if (!this.cleaningDetected && CHM.isChatInProgress()) {
				/** @type {object} */
				var cookies = {};
				/** @type {object} */
				var cookieSource = this._getCookies(context.data);
				for (var name in cookieSource){
					var value = cookieSource[name];
					if (value){
						var cookieName = name.replace(/_\d+$/, "");
						if (cookieName == "JSESSIONID" || cookieName === "inqCA" || cookieName === "inqLT") {
							cookies[cookieName] = value;
						} else {
							try {
								cookies[cookieName] = MI8.JSON.parse(value);
							} catch(e) {
								// This error is not matter because
								// some foreign cookies can contain the unexpected value,
								// e.g., in case of 1pc solution.
								// Continue looping to parse all other cookies.
							}
						}
					}
				}

				if (
					(getCustIDfromCookieObject(this.cookies) != getCustIDfromCookieObject(cookies)
						|| getChatIDfromCookieObject(cookies)
						&& getChatIDfromCookieObject(this.cookies) != getChatIDfromCookieObject(cookies)
					) && !CHM.isAsyncChat()
				) {
					this.cleaningDetected = true;
					if (isPersistentWindow()) {
						openerCall("cookiesCleaningDetected");
					}
					// need to close chat monitor to avoid the updating of cookie in postToServer.js
					CHM.closeChatMonitor();
					var expiry = 24 * 3600 * 1000;

					for (var cName in this.cookies) {
						if (cName == "inqCA" || cName == "inqLT") {
							// ignore cookies value because they are updated only in the postToServer IFrame
							continue;
						}
						if (cookies[cName]) {
							this.s3d("SCBR3_PM", getSiteID(), cName, cookies[cName], expiry, this.resourcesType[cName]);
						} else {
							// remove cookie
							this.s3d("SCBR3_PM", getSiteID(), cName, null, -1 * expiry, this.resourcesType[cName]);
						}
					}
					lmt12(
						"Detected clearing of cookies in the active chat.",
						LOG_LEVELS.WARN,
						null,
						true
					);
				}
			}

			/**
			 * Returns the value of customer ID from cookie object "inqVital".
			 * @returns {string|undefined} customer ID
			 */
			function getCustIDfromCookieObject(cookies) {
				return cookies["inqVital"]
					&& cookies["inqVital"].INQ
					&& cookies["inqVital"].INQ.custID;
			}

			/**
			 * Returns the value of engagement ID from cookie object "inqSession".
			 * @returns {string|undefined} chat ID (engagement ID)
			 */
			function getChatIDfromCookieObject(cookies) {
				return cookies["inqSession"]
					&& cookies["inqSession"].CHM
					&& cookies["inqSession"].CHM.chat
					&& cookies["inqSession"].CHM.chat.id;
			}
		};

        var COOKIE_DELIMITER = ';';

		CM47.chatSessionHelperIsChatInProgress = function() {
			return CM47.chatSessionHelper.isChatInProgress();
		};

		CM47.isCachePersistentEnabled = function () {
			return CM47.chatSessionHelper.isEnabled;
		};

		/**
		 * Setts flag detecting clearing of cookies to true
		 */
		CM47.prototype.cookiesCleaningDetected = function () {
			this.cleaningDetected = true;
		};

/**
 * Maps url to object with extracted parts (origin, protocol, domain, hostname, port, pathname)
 * 1PC solution needs parent domain identified and can be different than strict definition of domain.
 * Since 1PC solution is for Safari/ Safari on iPhone. Sibling domain on Cookie and LocalStorage need to be tested.
 *
 * @param {string} str
 * @return {{origin: String, href: String, protocol: String, hostname: String, port: number, domain: String}}
 */
CM47.parseUrl = function(str) {
	var url = customParseUrl(str);
	var host = url.hostname;
	url.domain = (host.indexOf('.') >= 0		// Sanity check.
		&& (host.split('.').length) >= 3)			// One dot domain name (e.g. tc.com) will be used as is
		? host.split('.').slice(1).join('.')	// Strip the host name.
		: host; // Default.
	return url;
};

/**
 * Cached Persistent Solution Helper
 */
CM47.chatSessionHelper = {
	cookie1pcXdData: null,
	isEnabled: false,
	isPersistentChat: false,
	customerId: null,
	protectionId: null,
	isContinueChat: false,
	serverDataForCookiesMap: {
		"agentGroupID": [
			"inqSession.chat.agID",
			"inqVital.CHM.lastChat.agentGroupID"
		],
		"agentGroupName": [
			"inqSession.chat.agName",
			"inqVital.CHM.lastChat.agentGroupName"
		],
		"businessRuleID": [
			"inqSession.CHM.chat.ruleID",
			"inqSession.chat.ruleID",
			"inqVital.CHM.lastChat.brID"
		],
		"businessUnitID": [
			"inqSession.chat.buID",
			"inqVital.CHM.lastChat.businessUnitID"
		],
		"engagementID": [
			"inqSession.CHM.chat.id",
			"inqSession.chat.id",
			"inqSession._ecID",
			"inqSession._icID"
		],
		"owningAgent": [
			"inqSession.CHM.chat.aid",
			"inqSession.chat.aid",
			"inqSession.agID",
			"inqVital.CHM.agentID"
		],
		"persistent": [
			"inqSession.pc",
			"inqSession.chat.pC"
		],
		"saleQualified": ["inqVital._ss"]
	},

	/**
	 * Start cache persistent solution sequence.
	 * Check that 1pc domains are available and try to get 1pc data
	 * from hostFileURLUse. If no data is found a server side cachedId
	 * solution is used. 
	 * 
	 * See: launch/initCustCachedId and launch/readChatOnCustomerCachedId
	 */
	startCachePersistentSolution: function () {
		log("Starting Cache Persistent solution");
		if (CM47.xdPsHelper.populateDomains2Check()) {
			this.read1SPC(CM47.xdPsHelper.hostFileURLUse);
		} else {
			log("No sibling domain available to use Cache Persistent solution");
		}
	},

	/**
	 * This function makes request customer id to Tagserver and response (customer id) is cached used as key
	 * cached customer id is returned when a user navigate to different domain.
	 */
    initCustomerCachedId: function (callbackFunction) {
		ROM.get(
			urls.vanityURL + "/tagserver/launch/initCustCachedId",
			generateRequestId("initCustomerCachedId"),
			45000,
			callbackFunction
		);
	},

	/**
	 * send chat info request to Tagserver with customer id
	 */
	readServerSavedChatInfo: function () {
		if (CM47.chatSessionHelper.customerId != null) {
			var postUrlPath = urls.vanityURL + "/tagserver/launch/readChatOnCustomerCachedId";
			var dataPayload = "custId=" + CM47.chatSessionHelper.customerId + "&siteId=" + getSiteID();

			if (getFlagSendDataToTSWithoutIframe()) {
				ROM.post(
					postUrlPath,
					dataPayload,
					generateRequestId("readChatSession"),
					false,
					CM47.chatSessionHelper.readServerSavedChatInfoCallBack,
					null,
					45000
				);
			} else {
				LoadM.postRequestToIframeProxy(
					urls.vanityURL,
					[
						"POSTCHAT",
						"readChatSession",
						"",
						"",
						postUrlPath,
						dataPayload,
						45000
					],
					"readChatSession",
					{"callbackFun": CM47.chatSessionHelper.readServerSavedChatInfoCallBack}
				);
			}
		}
	},

	/**
	 * handel chat information from Tagserver
	 * @param data
     */
    readServerSavedChatInfoCallBack: function (data) {
        CM47.chatSessionHelper.isEnabled = true;
		Inq.IFrameTSCallback(data.data);
    },

	/**
     Callback function of read 1st Sibling Party Cookies
	*/
    read1SPCCallBack: function (ev) {
		CM47.chatSessionHelper.cookie1pcXdData = ev.data;

		if (ev.data && ev.data === "no-cookie") {
			log("Cookies are blocked and chat can't be offered");
			return;
		}
		// Init customer cached id method (ask server for an id with a cache header)
		CM47.chatSessionHelper.initCustomerCachedId(function(data) {
			CM47.chatSessionHelper.customerId = data.data.custId;
			CM47.chatSessionHelper.protectionId = data.data.protectionId;

			var referrerURL = "", pageUrl = "";
			if (isWebSDK) {
				referrerURL = window.pageReferrer || "";
				pageUrl = window.pageUrl;
			} else  {
				referrerURL = top.document.referrer;
				pageUrl = inqFrame.location.href;
			}
	
			var topDocReferrerParsed = CM47.parseUrl(
				referrerURL
			);
			var inqFrameLocationHrefParsed = CM47.parseUrl(
				pageUrl
			);
	
			if (ev.data && referrerURL
				&& topDocReferrerParsed.hostname == inqFrameLocationHrefParsed.hostname
			) {
				Inq.IFrameProxyCallback(ev.data);
			} else {
				CM47.chatSessionHelper.readServerSavedChatInfo();
			}
		});
    },

	/**
     Test 2, test if 2spc is enabled and have saved data.
     @see IFrameProxyCallback - caller.
	*/
    read1SPC: function (hostedURL) {
		CM47.chatSessionHelper.isEnabled = true;
        var boxID = "box" + Math.floor(Math.random() * 1000011);
        // Get all cookies cmd
        var postCookieRequest = ["GCBR3", boxID, null, "", "no action"];
		CM.submitPost2ServerProcessRequest(
			postCookieRequest,
			hostedURL,
			CM47.chatSessionHelper.read1SPCCallBack
		);
    },

	/**
	 * Parses server response and returns null if data or engagement is empty.
	 * @param {Object} data from server
	 * @return {?Object}
	 */
	parseDataFromServer: function (data) {
		if (!data) {
			return null;
		} else {
			return data.engagement;
		}
	},

	/**
	 * Merges the data received from server and data restored from cookie.
	 *
	 * @param {object} currentCookiesObject - current cookies object
	 * @param {object} engagement - server data
	 *
	 * @returns {object}
	 */
	buildCookieFromAPI: function (currentCookiesObject, engagement) {
		CM47.chatSessionHelper.isContinueChat = true;

		CM47.chatSessionHelper.setParametersFromServer(currentCookiesObject, engagement);
		CM47.chatSessionHelper.setParametersFromCookiesOrDefault(currentCookiesObject, engagement);

		var engagementKeys = [];

		for (var engagementKey in engagement) {
			if (engagement.hasOwnProperty(engagementKey)
				&& !CM47.chatSessionHelper.serverDataForCookiesMap.hasOwnProperty(engagementKey)
			) {
				engagementKeys.push(engagementKey);
			}
		}

		if (engagementKeys.length > 0) {
			lwt12(
				"Unexpected fields from server: "
				+ JSON.stringify(engagementKeys) + " it won't be used anywhere."
				+ " New ticket should be created for updating code."
			);
		}

		return currentCookiesObject;
	},

	/**
	 * Updates cookies object by data from server.
	 * Data from current cookies has more priority. If data exist in cookies
	 * then it won't be overwritten.
	 *
	 * @private
	 *
	 * @param {object} currentCookiesObject - current cookies object
	 * @param {object} serverData - server data
	 */
	setParametersFromCookiesOrDefault: function (currentCookiesObject, serverData) {
		var sessionID = CM47.chatSessionHelper.customerId + "1";
		var brID = parseInt(serverData.businessRuleID, 10);
		var chatSpec;
		if (jsSDKEnabled) {
			chatSpec = this.getChatSpecFromBusinessRulesJsSDK(brID);
		} else {
			chatSpec = this.getChatSpecFromBusinessRules(brID);
		}

		setParamToObjectIfParamAbsent(
			currentCookiesObject,
			"inqVital.INQ.custID",
			CM47.chatSessionHelper.customerId
		);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqVital._iID", sessionID);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession._ssID", sessionID);
		setParamToObjectIfParamAbsent(
			currentCookiesObject,
			"inqSession.chat.fpID",
			CM47.chatSessionHelper.protectionId
		);
		CM47.chatSessionHelper.setToCookies(
			currentCookiesObject,
			"engagementID",
			serverData.engagementID,
			true
		);
		CM47.chatSessionHelper.setToCookies(
			currentCookiesObject,
			"businessRuleID",
			brID,
			true
		);
		setParamToObjectIfParamAbsent(
			currentCookiesObject,
			"inqSession.chat.chatType",
			getChatType(currentCookiesObject, brID)
		);
		// create new field if it is not exist in the object
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.ci.msgcnt", 1);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.aMsgCnt", 0);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.cMsgCnt", 1);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.ci.c", 1);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.ci.eng", true);
		/*
		 * Set opener script count value to 1 if there are no cntOS cookie.
		 * Without this cookie the opener scripts won't be loaded on a new domain page
		 */
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.ci.cntOS", 1);
		setParamToObjectIfParamAbsent(currentCookiesObject, "inqSession.chat.ci.lf", Date.now());

		setParamToObjectIfParamAbsent(
			currentCookiesObject,
			"inqSession.chat.xmlSpec.id",
			parseInt(chatSpec["id"], 10)
		);
		setParamToObjectIfParamAbsent(
			currentCookiesObject,
			"inqSession.chat.xmlSpec.chatTheme.id",
			parseInt(chatSpec["ctId"], 10)
		);

		/**
		 * Gets chat type. First tries to get it from rule,
		 * then if is absent tries to get chat type from current cookies
		 * and if it is still absent then chat type will be "C2C".
		 *
		 * @param {object} currentCookiesObject
		 * @param {number} brID - business rule id
		 * @return {string} - chat type
		 */
		function getChatType (currentCookiesObject, brID) {
			var currentChatType = null;

			if (currentCookiesObject && currentCookiesObject.inqSession
				&& currentCookiesObject.inqSession.chat
			) {
				currentChatType = currentCookiesObject.inqSession.chat.chatType;
			}

			var ruleType = BRM.rb41(brID) ? BRM.rb41(brID).ruleType : null;
			var chatType = ruleType ? ruleType : currentChatType;

			return chatType || "C2C";
		}

	},
	
	/**
	 * Updates cookies object by data from server.
	 * Data in cookies will be overwritten by data from server.
	 *
	 * @private
	 *
	 * @param {object} currentCookiesObject - current cookies object
	 * @param {object} serverData - server data
	 */
	setParametersFromServer: function (currentCookiesObject, serverData) {
		if (serverData.persistent === "true") {
			CM47.chatSessionHelper.isPersistentChat = true;
		}

		CM47.chatSessionHelper.setToCookies(
			currentCookiesObject,
			"businessUnitID",
			serverData.businessUnitID
		);

		/*
		 * Here we need check if AG enabled before set it, because some sites
		 * can have AG OFF in their settings.
		 * Look RTDEV-24525 for more info.
		 */
		if (serverData.agentGroupID) {
			CM47.chatSessionHelper.setToCookies(
				currentCookiesObject,
				"agentGroupID",
				serverData.agentGroupID
			);
			CM47.chatSessionHelper.setToCookies(
				currentCookiesObject,
				"agentGroupName",
				serverData.agentGroupName
			);
		}

		CM47.chatSessionHelper.setToCookies(
			currentCookiesObject,
			"owningAgent",
			serverData.owningAgent
		);
		CM47.chatSessionHelper.setToCookies(
			currentCookiesObject,
			"persistent",
			CM47.chatSessionHelper.isPersistentChat
		);

		if (serverData.saleQualified === "true") {
			CM47.chatSessionHelper.setToCookies(
				currentCookiesObject,
				"saleQualified",
				"assisted"
			);
		}
	},

	/**
	 * Sets given data to given cookies object.
	 * Uses cookies fields from CM47.chatSessionHelper.serverDataForCookiesMap.
	 *
	 * @see CM47.chatSessionHelper.serverDataForCookiesMap
	 * @private
	 */
	setToCookies: function (currentCookiesObject, name, value, createOnly) {
		var cookiesFields = CM47.chatSessionHelper.serverDataForCookiesMap[name];

		for (var i = 0; i < cookiesFields.length; i++) {
			setParamToObject(currentCookiesObject, cookiesFields[i], value, createOnly);
		}
	},

	/**
		 * Get the chatSpec information from the given business rule id.
		 * Extracts the information from the JSON api data object
		 * see LandingFramework.jsp (jsonAPIData)
		 * 
	 * @param {number} businessRuleID - Target business rule id
		 * @returns {object} - Object containing the full chatSpec from mediaMgr
		 */
	getChatSpecFromBusinessRulesJsSDK: function(businessRuleID) {
			var chatSpec = {};
			var isDataAvailable = (
				jsSDKEnabled 
				&& jsonAPIData["business-rules"] 
				&& (jsonAPIData["business-rules"].rules !== undefined)
			);
			if (!isDataAvailable) {
				return chatSpec;
			}

			var rules = jsonAPIData["business-rules"].rules;
			for (var i = 0; i < rules.length; i++) {
				var ruleItem = rules[i];

				if (ruleItem.rule.id == businessRuleID && ruleItem.rule.actions) {
				chatSpec = this.getChatSpecFromBusinessRuleActionsJsSDK(
						ruleItem.rule.actions
					);
					break;
				}
			}
			return chatSpec;
	},

		/**
		 * Extracts the chatSpec from the BR actions array
		 * @param {Array} businessRuleActions - The BR actions array
		 * @returns {object} - Object containing the full chatSpec from mediaMgr
	 */
	 getChatSpecFromBusinessRuleActionsJsSDK: function(businessRuleActions) {
			var chatSpec;

			for (var i = 0; i < businessRuleActions.length; i++) {
				var actionItem = businessRuleActions[i];

				if (actionItem.chatSpec && actionItem.chatSpec.value) {
					chatSpec = this.getChatSpecFromValueObject(actionItem.chatSpec);
					break;

				} else if (actionItem.c2cSpec) {

					if (actionItem.c2cSpec["chat-spec"] && actionItem.c2cSpec["chat-spec"].value) {
						chatSpec = this.getChatSpecFromValueObject(actionItem.c2cSpec["chat-spec"]);
						break;

					} else if (actionItem.c2cSpec["c2c-spec-id"]) {
						/**
						 * If could not find chat spec in the rule, find the c2cId
						 * and get the chat spec and theme from MM12
						 */
						var c2cSpec = MM.getC2CSpec(actionItem.c2cSpec["c2c-spec-id"]);

						if (c2cSpec && c2cSpec.chSpId) {
							chatSpec = MM.getChatSpec(c2cSpec.chSpId);
							break;
						}
					}
				} 				
			}
			return chatSpec || {};
	},

	/**
	 * Extract chatSpec value object (id or name) and get chatSpec object from MM12
	 * @param {object} chatSpecObject - ChatSpec object with value object
	 * @returns {object} chatSpec
	 */
	getChatSpecFromValueObject: function(chatSpecObject) {
		var chatSpec = {};
		if (chatSpecObject && chatSpecObject.value) {
			if (chatSpecObject.value.id) {
				chatSpec = MM.getChatSpec(chatSpecObject.value.id);
			} else if(chatSpecObject.value.name) {
				chatSpec = MM.getChatSpecByName(chatSpecObject.value.name);
			}
		}
		return chatSpec;
	},

		/**
		 * Get the chatSpec information from the given business rule id
		 * via the business rules array. See LandingFramework.jsp (initRulesData)
		 * 
	 * @param {number|string} businessRuleID - Target business rule id
		 * @returns {object} - Object containing the full chatSpec from mediaMgr
		 */
	getChatSpecFromBusinessRules: function(businessRuleID) {
			var chatSpec;
			var af3 = "";

		var rule = BRM.rb41(businessRuleID);
		if (rule && rule.af3) {
			af3 = rule.af3.toString();
		}

			var chatSpecReg = /chatSpec:{(name|id):(.*?),/;
			var idReg = /{id:(\d*)/;
			try {
				if (chatSpecReg.test(af3)) {
					var chatSpecIdOrName = chatSpecReg.exec(af3)[2];

					if (chatSpecIdOrName) {
						chatSpec = (
							MM.getChatSpec(chatSpecIdOrName)
							|| MM.getChatSpecByName(chatSpecIdOrName)
						);
					}
				} else if (idReg.test(af3)) {
					/*
					 * If could not find chat spec in the rule, find the c2cId
					 * and get the chat spec and theme from MM12
					 */
					var c2cId = idReg.exec(af3)[1];
					if (c2cId) {
						var chatSpecId = MM.getC2CSpec(c2cId).chSpId;
						if (chatSpecId) {
							chatSpec = MM.getChatSpec(chatSpecId);
						}
					}
				}
			} catch (e) {
				let12(
					"CM47#buildCookieFromAPI. Chat spec won't be set, because "
					+ e + ". Ticket for investigation this problem should be created.",
					true
				);
			}

			if (!chatSpec) {
				chatSpec = {};
				log("Chat spec is absent, chat won't be restored if it is absent in cookies", LOG_LEVELS.WARN);
			}

			return chatSpec;
    },

	isChatInProgress : function() {
		return CM47.chatSessionHelper.isEnabled && CM47.chatSessionHelper.isPersistentChat;
	}
};

/**
 * StorageMgr is responsible for saving and reading name-value pairs to/from a storage.
 *
 * @param {string} id is the identifier for this object
 * @param {CM47} CM
 * @constructor
 * @see FM2
 */
function StorageMgr(id, CM) {
	this._frameworkModule(id);
	this.CM = CM;
	this.storageAvailability = {
		"localStorage": storageAvailable("localStorage"),
		"sessionStorage": storageAvailable("sessionStorage")
	};
	this.initialized = false;
}

var STORAGE_EXPIRE_PREFIX = 'LSCACHE-'; //Prefix of localStorage item name to store its item's expiration date.

StorageMgr.prototype = Object.create(CM47.prototype);
StorageMgr.prototype.constructor = StorageMgr;

/**
 * Check availability storage
 * @param {string} storage
 * @return {boolean}
 */
StorageMgr.prototype.isStorageAvailable = function (storage) {
	return !!storage && this.storageAvailability[storage];
};

/**
 * Sets initialized flag to true to indicate that StorageMgr was initialize.
 */
StorageMgr.prototype.init = function() {
	if (this.initialized) {
		return;
	}
	this.initialized = true;
	log(this.getID() + " initialized.");
};

/**
 * Store the value into the localStorage or sessionStorage with the <resourceName>
 * along with LSCACHE-<resourceName>-expirationDate(item with data lifetime this value).
 * @param {LocalStorageResource} res The resource
 * @param {string} value which need to set
 * @private
 */
StorageMgr.prototype._setStoredValue = function (res, value) {
	var storage = res.getStorageType();
	if (this.isStorageAvailable(storage)) {
		var today = Date.now();
		var lifetime = res.getLifetime();
		if (lifetime > 0) {
			window[storage].setItem(STORAGE_EXPIRE_PREFIX + res.getName(), today + lifetime);
		}
		window[storage].setItem(res.getName(), value);
	}
};

/**
 * Retrieve the value of the given localstorage item name
 * @param {LocalStorageResource} res The resource
 * @param {string} cName The item name
 * @private
 * @return {?Object} the value of the given cName
 */
StorageMgr.prototype._getStoredValue = function (res, cName) {
	var storage = res.getStorageType();
	if (this.isStorageAvailable(storage) && !this._isDataExpired(cName, storage)) {
		return window[storage].getItem(cName);
	} else {
		return null;
	}
};

/**
 * Check data for relevance. If data in storage expired we need to remove them
 * @param {string} cName The item name
 * @param {string} storage, sessionStorage or localStorage.
 * @private
 * @return {boolean} true if data expired, false else data is actual
 */
StorageMgr.prototype._isDataExpired = function (cName, storage) {
	var now = Date.now();
	var expired = window[storage].getItem(STORAGE_EXPIRE_PREFIX + cName);
	if (expired != null) {
		expired = parseInt(expired, 10);
		if (!isNaN(expired) && expired < now) {
			window[storage].removeItem(cName);
			window[storage].removeItem(STORAGE_EXPIRE_PREFIX + cName);
			return true;
		}
	}
	return false;
};

/**
 * Clear all values in the given resource.
 * @param {LocalStorageResource} res The resource of interest.
 */
StorageMgr.prototype.clearStoredValue = function (res) {
	var storage = res.getStorageType();
	if (this.isStorageAvailable(storage)) {
		window[storage].removeItem(STORAGE_EXPIRE_PREFIX + res.getName());
		window[storage].removeItem(res.getName());
	}
};

/**
 * Write a name-value pair to a storage.
 * If value is undefined, name-value pair is deleted from storage.
 *
 * @param {LocalStorageResource} cRes - resource
 * @param {string} name of a key or variable
 * @param {Object} value of the key or variable. If undefined, name-value pair is deleted from storage.
 * @param {function=} callback function which should be called when data in storage will be saved
 */
StorageMgr.prototype.write = function (cRes, name, value, callback) {
	var cObj = null;
	var cVal = null;
	var cName = cRes.getName();

	if (this.CM.xd) {
		this.r479m.call(this.CM, cName, name, value);
	}
	if (this.CM.cleaningDetected) {
		if (typeof callback === "function") {
			callback();
		}
		return;
	}

	if (this.CM.xd) {
		this.checkCookieValidity.call(this.CM);
		// We have do it due to IE11 runs cookieValidationCallback synchronously.
		if (this.CM.cleaningDetected) { // DO NOT DELETE THIS CHECK
			if (typeof callback === "function") {
				callback();
			}
			return;
		}
		this.s3d.call(
			this.CM,
			"SCBR3_PM",
			getSiteID(),
			cName,
			this.CM.cookies[cName],
			cRes.getLifetime(),
			cRes.getStorageType(),
			callback
		);
	} else {
		var c = this._getStoredValue(cRes, cName);
		try {
			cObj = MI8.JSON.parse(c) || {};
		} catch (e) {
			cObj = {};
		}
		if (inu1(value)) {
			delete cObj[name];
		} else {
			cObj[name] = value;
		}
		cVal = MI8.JSON.stringify(cObj);
		this._setStoredValue(cRes, cVal);
		if (typeof callback === "function") {
			callback();
		}
	}
};

/**
 * Read a value from a localStorage or sessionStorage
 * @param {LocalStorageResource} cRes
 * @param {string} name is the name/key associated with the value
 * @return {?Object} the value associated with the name, which will need to be cast inside
 * a variable to determine true type
 */
StorageMgr.prototype.read = function (cRes, name) {
	var cVal = null;
	var cName = cRes.getName();
	if (this.CM.xd) {
		try {
			if (!inu1(this.CM.cookies[cName])) {
				cVal = this.CM.cookies[cName][name];
			}
		} catch (e) {
			// return default null value because
			// either the cookie or the name/value
			// have not yet been written
			log(e);
		}
	} else {
		var c = this._getStoredValue(cRes, cName);
		var cObj = null;
		try {
			if (c) {
				cObj = MI8.JSON.parse(c);
				if (cObj != null) {
					// retrieve name-value
					cVal = cObj[name];
				}
			}
		} catch (e) {
			log(e);
		}
	}
	return cVal;
};

/**
 * Support for storageResource interface
 * @param {(CM47|StorageMgr)} manager
 * @param {string} id is the identifier for this object
 * @constructor
 */
function StorageResource(manager, id) {
	this.manager = manager;
	this._resource(id);
	this._observable();
}

MI8.prepare(StorageResource).im13(MI8.Resource).im13(MI8.JSON).im13(MI8.Observable);

StorageResource.prototype.getName = function () {
	return null;
};
StorageResource.prototype.getPath = function () {
	return null;
};

StorageResource.prototype.getLifetime = function () {
	return null;
};

StorageResource.prototype.getDomain = function () {
	return null;
};

StorageResource.prototype.getPurgePriority = function () {
	return null;
};

/**
 * Determines if a given object is an acceptable listener for this class.
 * @param {Object} l
 * @returns {boolean}
 */
StorageResource.prototype.isListener = function (l) {
	return !!(l && (l.onResourceReset && typeof l.onResourceReset == "function"));
};

/**
 * Generic event firing method for use by any Observable mixin
 */
StorageResource.prototype.fireResourceResetEvent = function () {
	function f(l, evt) {
		try {
			if (!!l.onResourceReset) {
				l.onResourceReset(evt);
			}
		} catch (e) {
			log("Error firing event ResourceReset on " + l.getName() + ":" + e);
		}
	}

	var event = {customerID: Inq.getCustID()};

	this._fireEvt(f, event);
};

/**
 * Write variable value
 *
 * @param {string} name variable
 * @param {Object} value variable
 * @param {function=} callback - function which should be called
 *                               when data in storage will be saved
 *
 * @see Resource
 */
StorageResource.prototype.write = function (name, value, callback) {
	if (this.manager) {
		this.manager.write(this, name, value, callback);
	}
};

/**
 * Read variable value
 * @param {string} name variable
 * @returns {Object}
 * @see Resource
 */
StorageResource.prototype.read = function (name) {
	if (this.manager) {
		return this.manager.read(this, name);
	}
};

/**
 * Helper method to serialize values.
 * @param {Object} value object to be serialized
 * @return {string} string value of the object
 * @see Resource
 */
StorageResource.prototype._serialize = function (value) {
	return this.stringify(value);
};

/**
 * Helper method to de-serialize strings to objects.
 * @param {string} value string to be deserialized
 * @return {Object} object or null if either not deserialzable or not found
 * @see Resource
 */
StorageResource.prototype._unserialize = function (value) {
	return this.parse(value);
};

/**
 * Obtains the resource id for the resource
 * @returns {string}
 * @see Resource
 */
StorageResource.prototype.getResourceID = function () {
	return this._rsrcID;
};

/**
 * Overridable method to retrieve the storage type.
 * @returns {null}
 */
StorageResource.prototype.getStorageType = function () {
	return null;
};

	/**
	 * Instantiates a cookie resource for a single named cookie.
	 * @class CCD represents a single, named cookie for a specific domain.
	 * @param {string} id the unique identifier for the resource
	 * @param {string} name the cookie name
	 * @param {string} path the path is typically '/' but can be a more specific resource location in the domain if needed
	 * @param {number} lifetime the number of ms which this cookie resource should remain available.
	 * 			A null/undefined lifetime creates a cookie that lives only during the browser session
	 * @param {string} domain the host domain is interested in these cookies
	 * @param {number=} overflowPriority number between 0 and 9 (inclusive) indicating the overflow expiration priority
	 * in case any cookie space is overflowed. Lower numbers indicate higher value cookies. High numbered resources will
	 * be expired first.
	 * @param {CM47} cm
	 * @constructor
	 * @class CCD
	 */
	function CCD(id, name, path, lifetime, domain, overflowPriority, cm) {
		StorageResource.call(this, cm, id);
		/*
		 * Provides the name of this particular cookie, not
		 * any specific variable or name/value pair value.
		 */

		/** @override*/
		this.getName = function () {
			return name;
		};

		/** @override*/
		this.getPath = function () {
			return path;
		};

		/** @override*/
		this.getLifetime = function () {
			if (gc7("USE_SESSION_COOKIE_PERSISTENCE", false)) {
				return "";
			}
			return lifetime;
		};

		/** @override*/
		this.getDomain = function () {
			return domain;
		};

		/** @override*/
		this.getPurgePriority = function () {
			return overflowPriority;
		};
	}

	CCD.prototype = Object.create(StorageResource.prototype);
	CCD.prototype.constructor = CCD;
	
	/**
	 * Comparison function to sort CookieResources by purge priority order.
	 * @param {CCD} a
	 * @param {CCD} b
	 * @returns {number} 0 if equal, negative if a>b, positive if a<b. Will sort from largest purge priority to least.
	 */
	CCD.COOKIE_RESOURCE_PURGE_PRIORITY_SORT_FCN = function(a,b){
		return b.getPurgePriority() - a.getPurgePriority();
	};
	
	CCD.prototype.setCookieMgr = function(cm) {
		this.manager = cm;
	};

	/**
	 * Instantiates a web resource for a single url.
	 * @class WebResource Allows access to data as RPC (Remote Procedure Call) paradigm
	 * @param {String} id the unique identifier for the resource
	 * @param {String} url destination url for resource
	 * @param {String} permissions
	 * @param {String} method
	 * @constructor
	 */
	function WebResource(id, url, permissions, method ) {
		this._resource(id);
        this.url = url;
		this.permissions = permissions;
		this.method = method;
	}
	MI8.prepare(WebResource).im13(MI8.Resource).im13(MI8.JSON).im13(MI8.RC54);
	
	/**
	 * Being a Resource, this object must implement this 
	 * method. Stubbed.
	 */
	WebResource.prototype.write = function(name, value) {};
	
	/**
	 * Being a Resource, this object must implement this 
	 * method. Stubbed.
	 */
	WebResource.prototype.read = function(name) {};
	
	/**
	 * 
	 * Being a Resource, this object must implement this 
	 * method.
	 */
	WebResource.prototype._serialize = function(value) {
		return value;
	};
	
	WebResource.prototype._unserialize = function(value) {
		return value;
	};

	/**
	 * store js variables
	 * @class JSResource Allows to store js variables
	 * @param {String} id the unique identifier for the resource
	 * @constructor
	 */
	function JSResource(id, permissions) {
		this._resource(id);
        this.data = [];
	}
	MI8.prepare(JSResource).im13(MI8.Resource);

	/*
	 * Add a name-value pair to the cookie if the pair's
	 * name doesn't exist, otherwise update the name with
	 * the new value.
	 *
	 * Being a Resource, this object must implement this
	 * method.
	 */
	JSResource.prototype.write = function(name, value) {
        this.data[name] = value;
	};

	/*
	 *
	 * Being a Resource, this object must implement this
	 * method.
	 */
	JSResource.prototype.read = function(name) {
        try {
            return this.data[name];
        }
        catch(e) {
            
        }
        return null;
	};

	/*
	 *
	 * Being a Resource, this object must implement this
	 * method.
	 */
	JSResource.prototype._serialize = function(value) {
		return value;
	};

	JSResource.prototype._unserialize = function(value) {
		return value;
	};

/**
 * Instantiates a localStorage resource for a single named item.
 * @class LocalStorageResource represents a single, named storage item for a specific domain.
 * @param {string} id the unique identifier for the resource
 * @param {string} name the store item.
 * @param {number} lifetime the number of ms which this data in storage resource should remain available.
 *            A zero lifetime creates a storage that lives only during the browser session if it sessionStorage and always if it localStorage
 * @param {boolean} sessionStorage, used sessionStorage or localStorage
 * @param {StorageMgr} storageMgr
 * @constructor
 * @class LocalStorageResource
 */
function LocalStorageResource(id, name, lifetime, sessionStorage, storageMgr) {
	StorageResource.call(this, storageMgr, id);

	/**@override
	 * @return {string}
	 */
	this.getName = function () {
		return name;
	};

	/**@override
	 * @return {number}
	 */
	this.getLifetime = function () {
		return lifetime;
	};

	/**@return {boolean}*/
	this.isSessionStorage = function () {
		return !!sessionStorage;
	};
}

LocalStorageResource.prototype = Object.create(StorageResource.prototype);
LocalStorageResource.prototype.constructor = LocalStorageResource;

/**
 * Returns the storage type.
 * @override
 * @returns {string} "sessionStorage" or "localStorage"
 */
LocalStorageResource.prototype.getStorageType = function () {
	if (this.isSessionStorage()) {
		return "sessionStorage";
	} else {
		return "localStorage";
	}
};

	/**
	 * Create an instance of VER34
	 *
	 * @constructor
	 * @param {string} name the name of this variable
	 * @param {object} dfltValue the initial value of this variable
	 * @param {Resource} resource the Resource that will be the repository for this variable
	 * @param {string=} shortName short name of a variable instance, used for persistence.
	 * @param {function=} fnCast a function to cast this variable to a specific type
     * @param {function=} fnSer a function to serialize variable
	 * @requires Resource
	 *
	 */
	function VER34(name, dfltValue, resource, shortName, fnCast, fnSer) {
		this.name = name;
		this.resource = resource;
		this.dfltValue = dfltValue;
		this.shortName = shortName;

		if (typeof fnCast == "function") {
			this._cast = fnCast;
		}

		if (typeof fnSer == "function"){
			this._serialize = fnSer;
		}
       
		if (!inu1(resource) && resource.observable)	{
			resource.addListener(this);
		}
				
	}

	MI8.prepare(VER34).im13(MI8.XJA3);

	/**
	 * Factory that produces instances of VER34 based on data specs.
	 * @param data {Object} data object that specifies type of VER34 to produce
	 * @returns {*}
	 * @throws Error if data does not sport a proper type.
	 * @static
	 */
    VER34.getInstanceFromData = function(data) {
        var getResource = function(id) {
            return id ? resources[id] : null;
        };

        switch (data.type) {
            case "generic":
                return new VER34(data.name, data.defVal, getResource(data.rId), data.shName, data.fnCast, data.fnSer);
            case "String":
                return new StringVariable(data.name, data.defVal, getResource(data.rId), data.shName, data.fnCast, data.fnSer, data.maxSize);
            case "Date":
                return new DateVar(data.name, data.defVal, getResource(data.rId), data.shName);
            case "List":
                return new ListVariable(data.name, data.defVal, getResource(data.rId), data.shName, data.maxEntr);
            case "DateList":
                return new DateListVar(data.name, data.defVal, getResource(data.rId), data.shName, data.maxEntr);
            case "Map":
                return new MapVariable(data.name, data.defVal, getResource(data.rId), data.shName, data.maxEntr);
        }
        throw ("ERROR: Cannot instantiate variable for data: name=" + data.name + ", type=" + data.type);
    };

	/**
	 * Converts a data array to an array of proper variable types.
	 * @param datArray {Array} array of variable data that is to be used to produce Variables through factory.
	 * @returns {Array} Array of variables produced from datArray
	 * @throws when one of the data array elements does not sport a type or an incorrect/unsupported VER34 type
	 * @see VER34.getInstanceFromData
	 * @static
	 */
	VER34.getInstancesFromData = function(datArray) {
		var retArr=[];
		for(var i=0; i<datArray.length; i++){
			retArr[i] = VER34.getInstanceFromData(datArray[i]);
		}
		return retArr;
	};

	/**
	 * Reset the variable instance.
	 * @param evt
	 */
	VER34.prototype.onResourceReset = function(evt){
	    this.init();
	};

	/**
	 * Retrieve the name of a variable instance
	 * @return the name of the variable
	 * @type string
	 */
	VER34.prototype.getName = function(){
		return this.name;
	};

	/**
	 * Retrieve the optional short name of a variable instance, used for persistence.
	 * @return the short name of the variable
	 * @type string
	 */
	VER34.prototype.getShortName = function(){
		return this.shortName;
	};

	/**
	 * Returns name of variable instance used to persist variable - short name if available, otherwise usual (long) name.
	 * @return the short name of the variable
	 * @type string
	 */
	VER34.prototype.getPersistentName = function(){
		if (inu1(this.getShortName())) {
			return this.getName();
		} else {
			return this.getShortName();
		}
	};

	/**
	 * Retrieve the resource of a variable instance
	 * @return the resource of the variable
	 * @type Resource
	 */
	VER34.prototype.getResource = function(){
		return this.resource;
	};


	/**
	 * Resets the var value to default value provided at construction.
	 */
	VER34.prototype.reset = function(){
		this.z3(this.dfltValue);
	};
	/**
	 * initializes the value of the variable from the resource when resource is ready.
	 */
	VER34.prototype.init = function(){
		if(this.z0()==null) {
			this.z3(this.dfltValue);
		}
	};
	/**
	 * Default cast for this variable instance
	 * @param {Object} v the variable to cast
	 * @return the casted value
	 */
	VER34.prototype._cast = function(v) {
		return v;
	};

	/**
	 * Default serialize method for this variable instance
	 * @param {Object} v the variable to cast
	 * @return the casted value
	 */
	VER34.prototype._serialize = function(v) {
		return v;
	};

	/**
	 * Retrieve the value of this variable
	 * @return the variable's value using the casting function if available, null if name doesn't exist
	 * @type Object
	 */
	VER34.prototype.z0 = function() {
		var r = this.getResource();
		var val = null;

		// if a "short name" e9 and a value is stored under the long (original) name, replace long name with short
		if(!!this.getShortName() && (this.getShortName()!=this.getName())){ // if short and long names are same, don't bother
			var valByName = r.read(this.getName());
			var valByPerName = r.read(this.getShortName());				
			if(!inu1(valByName)) {
				// we shouldn't store under long name if short name is available
				// deleting long name by supplying undefined value parameter to write invocation
				r.write(this.getName());

				// if some value stored under short name then it is newer than value under long name
				// otherwise store removed value under short name
				if(!valByPerName && !(valByPerName===0)) {
					r.write(this.getShortName(), valByName);
					valByPerName = valByName;
				}
			}
			val = valByPerName;
		}
		else {
			val = this.getResource().read(this.getPersistentName());
		}

		return (inu1(val)) ? null : this._cast(val);
	};

    /**
	 * Retrieve the value of this variable or its default value if it e9
     * @returns {Object} the value of this variable or its default value if it e9
     */
	VER34.prototype.getValueOrDefault = function() {
		var val = this.z0();
		return val == null ? this.dfltValue : val;
	};

	/**
	 * Set the variable to a new value
	 *
	 * @param {Object} newValue the new value of this variable
	 * @param {function=} callback - function which should be called
	 *                               when data in storage will be saved
	 *
	 * @return {object} the new value of this variable
	 */
	VER34.prototype.z3 = function(newValue, callback) {
		this.getResource().write(this.getPersistentName(), this._serialize(newValue), callback);
		return newValue;
	};

	function ListVariable(name, dfltValue, resource, shortName, maxEntries) {
		this.name = name;
		this.dfltValue = dfltValue;
		this.resource = resource;
		this.shortName = shortName;
		if(!!maxEntries) {
			this.maxEntries = maxEntries;
		}
	}
	ListVariable.prototype = new VER34();
	ListVariable.prototype.constructor = ListVariable;
    
	ListVariable.prototype.append = function(arrayParam){
		var arr = this.z0();
		arr.append(arrayParam);
		arr.constrain(this.maxEntries);
		this.z3(arr);
	};

	ListVariable.prototype.prepend = function(arrayParam){
		var arr = this.z0();
		arr.prepend(arrayParam);
		arr.constrain(this.maxEntries);
		this.z3(arr);
	};

	/**
	 * Date VER34 class extending generic VER34 with specific and predefined serialize and cast(deserialize) methods.
	 */
	function DateVar(name, dfltValue, resource, shortName) {
		this.name=name;
		this.dfltValue = dfltValue;
		this.resource = resource;
		this.shortName = shortName;
	}

	DateVar.prototype = new VER34();
	DateVar.prototype.constructor = DateVar;
	DateVar.prototype._serialize = function(o){
		return (o && o.constructor===Date)?Math.floor(o.getTime()):o;
	};
	DateVar.prototype._cast = function(o){   
		return (typeOf(o)=="number")?new Date(o):o;
	};

	/**
	 * Date List VER34 class extending generic ListVariable with date specific serialize and cast(deserialize) methods.
	 */
	function DateListVar(name, dfltValue, resource, shortName, maxEntries) {
		this.name = name;
		this.dfltValue = dfltValue;
		this.resource = resource;
		this.shortName = shortName;
		if(!!maxEntries) {
			this.maxEntries = maxEntries;
		}
	}
	DateListVar.prototype = new ListVariable();
	DateListVar.prototype._serializeElement = DateVar.prototype._serialize;
	DateListVar.prototype._castElement = DateVar.prototype._cast;

    /**
     * Map variable class extending generic ListVariable with map specific methods.
     * @param {string} name
     * @param {string} dfltValue
     * @param {Resource} resource the Resource that will be the repository for this variable
     * @param {string=} shortName short name of a variable instance, used for persistence.
     * @param {number=} maxEntries number of maximum entries to be added to map
     */
    function MapVariable(name, dfltValue, resource, shortName, maxEntries) {
        this.name = name;
        this.dfltValue  = dfltValue;
        this.resource = resource;
		this.shortName = shortName;
        this.maxEntries = maxEntries;
	}

    MapVariable.prototype = new VER34();
    MapVariable.prototype.constructor = MapVariable;

    MapVariable.prototype.set = function(key, value) {
        var map = this.z0();
	    if(map == null || typeof map != "object") {
		    map = [];
	    }

	    if(this.maxEntries) {
		    if(this.maxEntries > Object.keys(map).length) {
			    map.set(key, value);
			    this.z3(map);
		    } else {
			    log("Can't add new entry to a map variable " + this.getPersistentName() + " , max entries number is " + this.maxEntries);
		    }
	    } else {
		    map.set(key, value);
		    this.z3(map);
	    }
    };

    MapVariable.prototype.unset = function(key) {
        var map = this.z0();
        map.unset(key);
        this.z3(map);
    };
    MapVariable.prototype.clear = function() {
        var map = this.z0();
		if (map != null) {
			map.clear();
			this.z3(map);
		}
    };
    MapVariable.prototype.each = function(fnc) {
        var map = this.z0();
        map.each(fnc);
        this.z3(map);
    };

    /**
     * Create an instance of StringVariable
     *
     * @constructor
     * @param {string} name the name of this variable
     * @param {object} dfltValue the initial value of this variable
     * @param {Resource} resource the Resource that will be the repository for this variable
     * @param {string=} shortName short name of a variable instance, used for persistence.
     * @param {function=} fnCast a function to cast this variable to a specific type
     * @param {function=} fnSer a function to serialize variable
     * @param {number=} maxSize maximum number of chars in value
     * @requires Resource
     *
     */
    function StringVariable(name, dfltValue, resource, shortName, fnCast, fnSer, maxSize){
        this.name = name;
        this.resource = resource;
        this.dfltValue = dfltValue;
        this.shortName = shortName;
        this.maxSize = maxSize;

        if (typeof fnCast == "function") {
            this._cast = fnCast;
        }

        if (typeof fnSer == "function"){
            this._serialize = fnSer;
        }

        if (!inu1(resource) && resource.observable)	{
            resource.addListener(this);
        }
    }

    StringVariable.prototype = new VER34();
    StringVariable.prototype.constructor = StringVariable;

    StringVariable.prototype.z3 = function(newValue) {
        if(!inu1(newValue) && typeof newValue != "string"){
            log("StringVariable.z3: format of data to set is wrong, it will not be set, data = " + newValue);
            return newValue;
        } else if(newValue && this.maxSize && this.maxSize < newValue.length){
            log(this.getPersistentName() + " cannot write value bigger that max size of " + this.maxSize + " and will be truncated");
            newValue = newValue.substring(0, this.maxSize);
        }

        this.getResource().write(this.getPersistentName(), this._serialize(newValue));
        return newValue;
    };

	/**
	 * X4334rtf in charge of all variables and manages resources as well.
	 * @class Persistence Manager. Charged with maintaining persistence access for all 
	 * framework managers including cookie based persistence.
	 * @constructor
	 * @param {String} id Unique framework id
	 * @param {Object} xd true if cross-domain active, else false
	 * @borrows Observable#addListeners as #addListeners
	 * @borrows Observable#clearListeners as #clearListeners
	 * @borrows Observable#_fireEvt as #_fireEvt
	 * @borrows Observable#addListener as #addListener
	 * @borrows Observable#isListener as #isListener
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @borrows JSON#stringify as #stringify
	 * @borrows JSON#parse as #parse
	 */
	function X4334rtf(id, xd){
		this._frameworkModule(id);
		this.xd = xd;
		this._observable();
		this._vartable = {};
		this.CM = CM47.getInstance(this.xd);
		
		/**
		 * Obtains a ref to a variable (for an optional given rule)
		 * @param {String} varName Name of the variable to seek.
		 * @param {Rule} rule Optional rule name to which the variable sought belongs.
		 */
		this.getVar = function(varName, rule){
			var rv = this._vartable[varName+(rule?("_"+rule.getID()):"")];
			if(!rv) {
				rv = this._vartable[varName];
			}
			return !!rv?rv:null;
		};
		
		/**
		 * Adds an array of variables for a given rule name
		 * @param {Array} varArr array of variables to manage
		 */
		this.addVars = function(varArr){
			for(var i=0; i<varArr.length; i++){
				this.addVar(varArr[i]);
			}
		};
		/**
		 * Adds a variables for a given rule name
		 * @param {VER34} v object of type {@link VER34} to manage
		 * If undefined or null, only the rule name will be used to index the var.
		 */
		this.addVar = function(v){
			this._vartable[v.getName()] = v;
		};

		/**
		 *  Upon reInitChat() call, reset all temp variables to default.
		 *  Some of the temp values are from function return and need to be called again with function call.
		 */
		this.resetTmpVars = function() {
			var akey;
			var loc_site = initSiteData();
			var loc_businessVars;
			var loc_tmpVars = {};

			if( loc_site ) {
				loc_businessVars = loc_site.businessVars();
			}

			var endi = loc_businessVars ? loc_businessVars.length : 0;
			for(var i = 0; i < endi; i++) {
				if(loc_businessVars[i].rId === "tmpVars") {
					loc_tmpVars[loc_businessVars[i].name] = loc_businessVars[i].defVal;
				}
			}

			for(akey in this._vartable) {
				try {
					if (this._vartable[akey].resource._rsrcID === "tmpVars") {
						this.getVar(akey).z3( (loc_tmpVars && loc_tmpVars.hasOwnProperty(akey) )
							? loc_tmpVars[akey] : this._vartable[akey].dfltValue);
					}
				} catch(err) { /* continue with next one */}
			}
		};

		/**
		 * fires data calls for X4334rtf
		 * @memberOf X4334rtf.prototype
		 * @override
		 */
		this.fireDataReady= function(){
			for(var idx=0; idx<this._listeners.length; idx++){
				try {
					this._listeners[idx].agrtyer({});
				} catch(e) {
					log(e);
					// continue alerting listeners
				}
			}
		};
		
		/**
		 * 
		 */
		this.isListener = function(l){
			return (l && l.agrtyer)?true:false;
		};
		
		/** 
		 * initializes X4334rtf
		 */
		this.init = function(){
			if (this.initialized) return;
			this.initialized=true;
			for(var aVar in this._vartable) {
				this._vartable[aVar].init();
			}
			log(this.getID()+" initialized.");
		};
						
		/** 
		 * resets resource
		 * @param {String} resourceID  
		 */
		this.reset = function(resourceID){
			if (!inu1(resourceID))	{
				this.CM.clear(resourceID);
				var resource = resources[resourceID];
				if (!inu1(resource))	{
					resource.fireResourceResetEvent();
					log("resource reset for resourceID : "+resourceID);
				}	
			}
		};	
		
		/** 
		 * startup call for X4334rtf
		 */
		this.start = function() {
			if (this.started) return;
			this.started=true;
		};

		this.getCookieMgr = function() {
			return this.CM;
		};
	}
	
	/**
	 * Static field instance of the singleton X4334rtf
	 */
	X4334rtf.PM = null;
	
	/**
	 * Create an instance of the X4334rtf. This singleton creation
	 * pattern should ALWAYS be used by other objects instead of creating
	 * a PM with its constructor.
	 * @param {boolean} xd true if site is configured for cross-domain, false otherwise
	 * @return a singleton instance of X4334rtf
	 */
	X4334rtf.getInstance = function(xd) {
		if (X4334rtf.PM == null) {
			X4334rtf.PM = new X4334rtf("PM", xd);
		}
		return X4334rtf.PM;
	};
		

	MI8.prepare(X4334rtf).im13(MI8.Observable).im13(MI8.FM2);
	X4334rtf.im13(MI8.JSON).im13(MI8.XJA3);

	/**
	 * takes a js object of n-v pairs and serializes them to a URL type params string.
	 * @param {Object} d Data in n-v pair format. For example: {dat1:"value1",num:3424}
	 * @param {boolean} avoidRand  flag if it true than we don't add "_rand" param
	 * @param {boolean} addCheckSum - flag if it true then we add "checksum" parameter
	 * @return {string}
	 */
	function toParamString(d, avoidRand, addCheckSum){
		var rv = "";
		/** @type {Array} */
		var dataArray = [];
		if(!d) return rv;
		var separator  = "&";
		if (!avoidRand) {
			dataArray.push("_rand=" + encodeURIComponent(randStr()));
		}
		if (typeof d === "object") {
			for (var idx in d) {
				if (typeof d[idx] != "function" && !inu1(d[idx])) {
					dataArray.push(encodeURIComponent(idx) + "=" + encodeURIComponent(d[idx]));
				}
			}
		} else {
			dataArray.push(d.toString());
		}

		rv = dataArray.join(separator);

		if (addCheckSum) {
			rv = "checksum=" + genCheckSumBy(rv) + separator + rv;
		}
		return rv;
	}

	function randStr() {
		return (Math.round(Math.random()*1000000000000)).toString(36);
	}

	/**
	 * Summarizes hashcodes of each parameters in string of parameters.
	 * @param {string} parameters
	 * @returns {number} integer
	 */
	function genCheckSumBy(parameters) {
		var separator = "&";
		var checkSum = 0;
		if (parameters.length > 0) {
			var paramsArray = parameters.split(separator);
			for (var i = 0; i < paramsArray.length; i++) {
				checkSum += decodeURIComponent(paramsArray[i]).hashCode();
			}
		}
		return checkSum;
	}

	/**
	 * Channel
	 * A communications "get" channel to our server. Sends data to a URL destination with
	 * error checking. Will attempt to resend 3 times.
	 * @param {function} onComplete Callback when message is sent. May optionally support an event
	 * @param {function} onError Callback when message is fail. May optionally support an event.
	 * object of form {state:"SUCCESS"|"ERROR", evt:<imageEvent>}
	 * @constructor
	 * @class Channel
	 */
	function Channel(onComplete, onError){
		this.addCheckSum = true; // RTDEV-16956
		if (typeof onComplete == "function") {
			this.onComplete = onComplete;
		}
		if (typeof onError == "function") {
			this.onError = onError;
		}
		this.resendCount = 0;
		this.img = this._newImage();
	}

	Channel.prototype.getCallback = function(){
		return this.onComplete;
	};

	Channel.prototype.getResendCount = function(){
		return this.resendCount;
	};

	Channel.prototype.getUrl = function(){
		return this.url;
	};

	/**
	 * gets the url of the channels img source
	 * @return {string} url of the Image object src url
	 */
	Channel.prototype.getSrcUrl = function(){
		return this.img.src;
	};

	/**
	 * Factory to produce a correctly configured image for channel instances.
	 * @return {Image} customized image instance that will report errors and successes dutifully
	 * @private
	 */
	Channel.prototype._newImage = function(){
		var img = new Image();
		img.channel = this;
		img.onload = function(evt){
			this.channel.done(evt);
		};
		img.onerror = function(e){
			this.channel.fail(e);
		};
		return img;
	};

	/**
	 * resends data on error condition from "send" method
	 * @param {object} err Error object
	 * @private
	 * @see Channel#send
	 */
	Channel.prototype._resend = function(err){
        var maxResend = this.maxResendTimes ? this.maxResendTimes : 3;
		if(!!this.resendOnError && ++this.resendCount<maxResend){
			this.img = this._newImage();
			if(!!this.data){
				this.data["resendCount"] = this.resendCount;
			}
            if(this.timeout) {
                var _this = this;
                setTimeout(function() { _this.send(_this.url, _this.data, _this.noCacheBust, _this.resendOnError, _this.maxResendTimes, _this.timeout);}, _this.timeout);
            } else {
                this.send(this.url, this.data, this.noCacheBust, this.resendOnError, this.maxResendTimes, this.timeout);
            }
		}else{
			if (typeof this.onComplete == "function") {
				var errObj =  {
					state:"ERROR",
					url:this.getFullUrl(), //TODO: URL will be contain a new "_rand" parameter thus log-line will be different from original URL with error
					attempts: this.resendCount
				};
				if(err && err["type"]) {
					errObj.evt = {type:err["type"]};
				}
				this.onComplete(errObj);
			}
		}
		let12("Send Error: Could not send data to service. retry count=" +
			this.resendCount + ", url=" +
			this.getFullUrl() +
			(this.resendCount > 2 ? ", Failed!" : ""), true);
	};

	/**
	 * Returns the full URL, including data payload and cachebust random number.
	 * @return {String} Full url with data and cachebust
	 */
	Channel.prototype.getFullUrl = function(){
		return this.url + (!!this.data ? ("?" + this.toParamString(this.data, this.noCacheBust, this.addCheckSum)) : "");
	};

	/**
	 * Send data to a given URL, optional cache-busting. No callback provided here.
	 * @public
	 * @param {string} url Full url with no data or "?" char. Must be a valid url with protocol:[port], domain, and path
	 * @param {object} data map of name-value pairs to send attached to the given url
	 * @param {boolean} noCacheBust true for now _rand var attached to bust cache
	 * @param {boolean} resendOnError if true, will retransmit on error condition. If undefined,
     * @param {Number} [maxResendTimes]  override max request times (default is 50, set in XSD).
     * @param {Number} [timeout]  provide timeout to send request after interval (default is null, requests will be sent one by one immediately)
     * null, or false then will only attempt to send once.
	 */
	Channel.prototype.send = function(url, data, noCacheBust, resendOnError, maxResendTimes, timeout){
		if (isLogToServerDisabled() && url === urls.loggingURL) {
			return;
		}
		this.url = url;
		this.data = data;
		this.noCacheBust = noCacheBust;
		this.resendOnError = resendOnError;
        this.maxResendTimes = maxResendTimes;
        this.timeout = timeout;
		this.img.src = this.getFullUrl(); // triggers http request
	};
	Channel.prototype.toParamString = toParamString;
	Channel.prototype.rand = randStr;

	/**
	 * Handler of successful response
	 * @param {object} evt
	 */
	Channel.prototype.done = function(evt) {
		if (typeof this.onComplete == "function") {
			this.onComplete({
				state: "SUCCESS",
				evt: evt,
				url: this.url
			});
		}
	};

	/**
	 * Handler of failing
	 * @param {object} err
	 */
	Channel.prototype.fail = function(err) {
		if (typeof this.onError == "function") {
			this.onError({
				state:"ERROR",
				err: err
			});
		} else {
			this._resend(err);
		}
	};

	/**
	 * Conducts all remote operations. Singleton class.
	 * @class RM91 (ROM). All remote operations (chat launch requests etc) are called through
	 * this class.
	 * @constructor
	 * @param {String} id
	 * @param {Object} data initial data for the ROM
	 * @borrows XJA3#absorb as #absorb
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @see RC54
	 */
	function RM91(id, data) {
		this._frameworkModule(id);
		/** queue for all waiting remote ops */
		this.waitingQ = {};
		this.ch = [];
		this.i = 0;
        this.pIdx = 0;
		this.ridx = 0;
        this.isIE = isIE();
		this.absorb(data);
		this.addCheckSum = true; // RTDEV-16956
		this.transcriptRequestCount = 0;
		this.transcriptRequestStartTime = 0;

        /**
         * Detects overflow of the IE url GET request length limit.
         * add all needed data, and check size of all data
         * @param {String} url The base protocol/server/port combo to be used to construct the URL
         * @param {Object} data the name-value pairs to be placed on the URL as parameters.
         * @return true if request length > limit.
         */
        this.isOversizeRemoteCall = function (url, data) {
            this.pd1d(data, null);
            return this.isOversizeCall(url, data);
        };

		/**
		 * Compares passed URL with vanity URL taken from the closure (see LandingFramework.js).
		 * Because of security concerns we can't take urls.vanityURL value because it can be
		 * overridden by the malicious script (see overrideDomainsIfAny() in LandingFramework.js)
		 * @param {string} url
		 * @return {boolean}
		 */
		this.isVanityUrl = function (url) {
			return url.indexOf(vanityUrl) === 0;
		};

		/**
		 * Compares given url with tagserver url.
		 *
		 * @param {string} url - url
		 * @return {boolean} true if given url includes vanityURL (tagserver url)
		 */
		this.isTSUrl = function (url) {
			return url.includes(urls.vanityURL);
		};

        /**
         * Detects overflow of the IE url GET request length limit.
         * @param {String} url The base protocol/server/port combo to be used to construct the URL
         * @param {Object} data the name-value pairs to be placed on the URL as parameters.
		 * @link http://support.microsoft.com/kb/208427
         */
		this.isOversizeCall = function(url, data){
			var pstr = this.toParamString(data);
			pstr = ((pstr && pstr.length>0)?"?":"") + pstr;
			var reqURL = url+pstr;
			return (this.isIE && reqURL.length>2048);
		};


		/**
		 * Sends data to a server (no callback)
		 * If this is going to the vanity domain we will "POST" the data via the IFrame/Proxy
		 *    this avoids the problem of length restrictions in "GET" methodology
		 * @param {String} url target URL without parameters
		 * @param {Object} data the name-value pairs to be placed on the URL as parameters
         * @param {boolean} [logOnError] set to true to log data to server on error
		 * @param {boolean} [resendOnError]  set to true if retries are wanted. null or undefined will not resend.
         * @param {Number} [maxResendTimes]  override max request times (default is 50, set in XSD).
         * @param {Number} [timeout]  provide timeout to send request after interval (default is null, requests will be sent one by one immediately)
		 * @param {Function=} [onSuccessCallback] to call on success
		 * ONLY WORKS FOR GET REQUESTS
		 */
		this.send = function(url, data, logOnError, resendOnError, maxResendTimes, timeout, onSuccessCallback){
			if (isLogToServerDisabled() && url === urls.loggingURL) {
				return;
			}

            var hasLogdata = url.indexOf("/logdata") != -1;
			/*
			 * RTDEV-1238: "codeVersion" parameter is used for investigation only
			 * and contains a time of inqChatLaunch***.js and tcFramework***.js
			 * generation as number.
			 * The parameter is defined in inqChatLaunch***.js in v3Lander object
			 * (see code of inqChatLaunch.jsp) and is added as URL parameter
			 * for tcFramework***.js and InqFramework.js.
			 */
			if (this.isTSUrl(url) && hasLogdata && (data) && (v3Lander)) {
                data["codeVersion"] = v3Lander.codeVersion;
            }
			try {
				/* RTDEV-16037 Make Vanity domain requests to be sent via our
				 * proxy iframe and with POST requests. Added callback function
				 * for requests onEvent/logdata.
				 */
				// If status is differ to 200 then log WARN to tagserver.
				if (this.isTSUrl(url)) {
					return this.post(url, data, data.rid);
				}

                if (this.isOversizeCall(url, data)) {
                    this.postToServer(url, data);
                    return;
                }

				var rom = this;
				var channel = new Channel(function (evt) {
					if (evt.state === "ERROR") {
						if (logOnError) {
							lmt12("Channel send failed: siteID=" + Inq.getSiteID() + ",customerID=" +
								Inq.getCustID() + ",url=" + this.getFullUrl(), LOG_LEVELS.ERROR);
						}
					} else {
						if (typeof onSuccessCallback === "function") {
							onSuccessCallback();
						}
					}
					rom.ch.remove(channel);
				});
				channel.send(url, data, null, resendOnError, maxResendTimes, timeout);
				this.ch.push(channel);
			} catch (e){
				let12("RM91.send >> making HTTP Request. URL: " + url + cf21(e));
			}
		};

		/**
		 * Posts data to a server
		 *
		 * If we are uiWebview, do not do post.  Under uiWebview, focus is stolen upon attachment of an IFRAME.
		 * .. So this steels focus from the text input in iOS applications using uiWebview
		 * .. This change is made for the VodaFone application.
		 * @param {string} url - URL to send request
		 * @param {Object} data - payload
		 * @param {string} id - context ID for Load Manager
		 * @param {boolean} sync - flags about synchronous request
		 * @param {function} callbackFcn - callback
		 * @param {function=} errorCallback - error callback
		 * @param {number=} timeout - request timeout
		 */
		this.post = function(url, data, id, sync, callbackFcn, errorCallback, timeout) {
			if (isLogToServerDisabled() && url === urls.loggingURL) {
				return;
			}

			if (url.indexOf("onEvent") > -1 && !data.siteID) {
				return;
			}

			CommunicationMgr.process(
				url,
				data,
				id,
				sync,
				this.getCallbackForEvent(url, toParamString(data, true, true), callbackFcn),
				errorCallback,
				timeout,
				this.preparePostRequestData(url, data, id, sync, callbackFcn)
			);
		};

		/**
		 * Sends Get Request to server
		 *
		 * @param {string} url - URL to send request
		 * @param {string} id - context ID
		 * @param {number} timeout - request timeout
		 * @param {function} callbackFcn - callback
		 * @param {function=} errorCallback - error callback
		 */
		this.get = function (url, id, timeout, callbackFcn, errorCallback) {
			id = id || generateRequestId("vanity");
			timeout = timeout || 0;
			var postRequestData = ["POSTCHAT", id, "", "", url, null, timeout, CHM.getFPSessionID()];

			CommunicationMgr.process(
				url,
				null,
				id,
				false,
				this.getCallbackForEvent(url, toParamString(data, true, true), callbackFcn),
				errorCallback,
				timeout,
				{
					request: postRequestData,
					id: id,
					callback: callbackFcn
				}
			);
		};

		/**
		 * Sends request to Chat Router without iFrame and postToServer
		 * @param {string} url URL to send request
		 * @param {string|object} data
		 * @param {string} id context ID
		 * @param {function=} callbackFcn - callback
		 */
		this.sendToChatrouter = function (url, data, id, callbackFcn) {
			data = this.toParamString(data, true, false);
			var requestData = ["POSTCHAT", id, "", "", url, data, 0, CHM.getFPSessionID()];
			var callback = callbackFcn ? { callbackFun: callbackFcn } : null;
			CommunicationMgr.doCommands(url, requestData, id, callback);
		};

		/**
		 * Produces required data to send request via proxy IFrame
		 * @param {String} url URL to send request
		 * @param {Object} data payload
		 * @param {String} id context ID for Load Manager
		 * @param {Boolean} sync flags about synchronous request
		 * @param {Function} callbackFcn callback
		 *
		 * @return {Object} object which contain required data for Load Manager sender
		 */
		this.preparePostRequestData = function(url, data, id, sync, callbackFcn) {
			try {
				var headers = {};
				id = id ? id : generateRequestId("vanity");
				var pstr = this.toParamString(data, true, this.addCheckSum);
				var command = sync ? "POSTSYNC" : "POSTBR30";
				var postCookieRequest = [command, id, "", "", encodeURIComponent(url + "?" + pstr)];

				if (this.isVanityUrl(url)) {
					headers["X-Protection-Id"] = CHM.getFPSessionID();
				}

				postCookieRequest.push(JSON.stringify(headers));

				return {
					"request": postCookieRequest,
					"id": id,
					"callback": this.getCallbackForEvent(url, pstr, callbackFcn)
				};
			} catch (e) {
				let12("ERROR while preparing post context:" + e.message, true);
			}
			return {};
		};

		// if 'callback' variable is not defined then use 'callbackFcn' as default callback function
		// if 'callbackFcn' also is not defined,
		// it's not matter because it's checking in CM47#postRequestToIframeProxy
		this.getCallbackForEvent = function (url, pstr, callbackFcn) {
			if (url.indexOf("onEvent") > -1
				|| url.indexOf(urls.logDataURL) > -1
				|| url.indexOf("surveyReport") > -1
			) {
				return function (resp) {
					ROM.onRemoteCallback(resp.id, resp.data);
					if (resp && parseInt(resp.responseStatus) !== 200) {
						lwt12(
							"RM91.post >> Bad response status: " +
							resp.responseStatus + ". Params: " + url + "?" + pstr + " ."
						);
					}
					if (typeof callbackFcn == "function") {
						callbackFcn();
					}
				};
			}
			return callbackFcn;
		};

		/**
		 * posts JSON data to a server
		 */
		this.postJson = function (url, data) {
			var id = generateRequestId("vanity");
			var pstr = JSON.stringify(data);
			var command = "POSTJSON";
			var postRequestData;
			if (getFlagSendDataToTSWithoutIframe() && this.isTSUrl(url)) {
				postRequestData = [command, id, "", "", url, pstr];
				CommunicationMgr.doCommands(url, postRequestData, id);
			} else {
				try {
					postRequestData = [command, id, "", "", encodeURIComponent(url + "?" + pstr)];
					CM.postRequestToIframeProxy(postRequestData, id);
				} catch (e) {
					logErrorInPostToTagServer("ROM.postJson ERROR:" + cf21(e));
				}
			}
		};

		/**
		 * <p>We use this function for send POST requests if standard
		 * function has been failed. See also {@link RM91#post}.</p>
		 *
		 * <p>Current implementation of this function create "div" element on the page
		 * and than create and put in this div "iframe" element and "form".<p>
		 *
		 * <p>This "form" filling with data in time when we create it. Than we
		 * submit this form to "iframe".</p>
		 *
		 * <p>We replace old realization because if form was created in "iframe"
		 * directly, "Chrome" browser sets "Origin" header for this request to null
		 * as a string and this requests are rejected by server-side CORS filter.</p>
		 *
		 * Should be used only by postToServer realisation (LR45),
		 * for other cases CORS requests should be used.
		 *
		 * @param action {string} URL of data sending
		 * @param data {object} in name-value pair format. For example: {dat1:"value1",num:3424}
		 * @return {void}
		 */
		this.postToServer = function(action, data) {
			if (inu1(data) || inu1(action)) {
				return;
			}
			var idx = ++this.pIdx;
			var divId = "inqPostBox" + idx;
			var formId = "aform" + idx;
			var iframeId = "box" + idx;
			var iframeSrc = "javascript:false";
			var div = createFloatingDiv(divId, 0, 0, 1, 1);
			var iframe = createHiddenIFrame(iframeId, 0, 0, 1, 1, iframeSrc);
			div.appendChild(iframe);
			var form = this.createFormToPost(action, data, iframeId, formId);
			div.appendChild(form);
			iframe.onload = function () {
				div.parentNode.removeChild(div);
			};
			form.submit();
		};

		/**
		 * Sends data about AuthenticatedUser
		 *
		 * @param authenticatedUser {object} contains the information for authentication user
		 * Consists of persistentCustomerID object, can also have additional fields.
		 * For example:
		 * {"persistentCustomerID":{"email":"aaa@gmail.com"}, "name":"aaa"}
		 */
		this.sendAuthenticatedUser = function(authenticatedUser) {
			var data = {
				siteID: getSiteID(),
				customerID: Inq.getCustID(),
				engagementID: CHM.getChatID(),
				authenticatedUser: JSON.stringify(authenticatedUser),
				conversationChannel: "WEB"
			};
			this.post(urls.authUserURL, data);
		};

        /**
         * Sends data to specified agent
         * @param agentID {string} agentID to check if it e9
         * @param data {Object} data to be sent to agent
         */
        this.sendDataToAgent = function (agentID, data){
            if (!data.siteID) {
                data.siteID = Inq.getSiteID();
            }
            if (CHM.isVAChat()) {
                data.customerID = CHM.getChat().getCustID();
            }

			if(data != null && (getIOSNativeSDKInstance() || typeof NuanIJSFBridge != "undefined")) {
				delete data["agentID"];
				delete data["siteID"];
				delete data["engagementID"];
				delete data["customerID"];
				if(getIOSNativeSDKInstance()) {
					data["reqType"] = "datapass";
					getIOSNativeSDKInstance().postMessage(JSON.stringify(data));
				} else {
					NuanIJSFBridge.dataPass(JSON.stringify(data));
				}
			} else if (agentID) {
                this.post(urls.baseURL + "/tracking/agent", data);
            }
        };

		this.sendCobrowseMessage = function (engagementID, agentID, customerId, cobrowseEvent,
											 cobrowseMessageText, resendToClient, siteID){
			this.post(urls.baseURL+"/tracking/cobrowse", {
				engagementID: engagementID,
				agentID: agentID,
				customerId: customerId,
				cobrowseEvent: cobrowseEvent,
				cobrowseMessageText: cobrowseMessageText,
				visibility: top.document.visibilityState,
				resendToClient: !!resendToClient,
				siteID: siteID
			});
		};

        /**
		 * composes a url from data
		 * @param {String} url Url part of the URL to be assembled.
		 * @param {Object} data Map of name-value pairs to be "ampersand" appended to the given url
		 * @param {boolean} avoidRand shows wether we should do not add "_rand"
		 * @TODO RhinoUnit Tests
		 */
		this.composeURL = function (url, data, avoidRand){
			var p = this.toParamString(data, avoidRand);
			var idx = url.indexOf('?');
			if(p.length>0){
				if(idx < 0){
					p = "?" + p;
				}
				else if(idx < (url.length-1)){
					p = '&' + p;
				}
				return url + p;
			}
			return url;
		};
        /**
         * Add needed data
         * @param data data to send
         * @param caller - caller, if caller = null, then check mode
         */
		this.pd1d = function(data, caller) {
            if (inu1(caller)) {
                data.rid = "r1234567890";
			} else {
                data.rid = this._queueCaller(caller);
            }

        };

		/**
		 * Sends data to remote destination url with callback.
		 * data payload
		 * If this is going to the vanity domain we will "POST" the data via the IFrame/Proxy
		 * this avoids the problem of length restrictions in "GET" methodology
		 */
		this.doRemoteCall = function(url, data, caller) {
            this.pd1d(data, caller);
			var pstr = this.toParamString(data);

			if (this.isTSUrl(url)) {
                this.post(url, pstr, data.rid);
			} else {
                /* We should never get here, unless we are doing a remote call to a url that is NOT our vanity domain
                 * This is always an error and should never happen
                 */
                var fault = new Error("remote call to non-vanity domain");
                ROM.post(urls.loggingURL, {level:'ERROR', line:('VANITY DOMAIN ERROR: ' + cf21(fault))});
            }
        };

		/**
		 * Generates a new remote id string (randomly) so unique callbacks may be made
		 * to the calling RC54.
		 */
		this.newRID= function(){
			return "r" + Math.floor(Math.random() * 1000011);
		};
		this._queueCaller= function(caller){
			var rid = this.newRID();
			if(caller && caller.onRemoteCallback){
				this.waitingQ[rid]=caller;
			} else {
				throw "caller null or not an instance of RC54";
			}
			return rid;
		};
		this._dequeueCaller= function(rid){
			var c = this.waitingQ[rid];
			if(c){
				delete this.waitingQ[rid];
				return c;
			}
			return null;
		};
		/** 
		 * Universal callback for all remote ops. Used by the remote server to "call back" the
		 * calling RC54 object.
		 */
		this.onRemoteCallback= function(rid, data){
			if(rid){
				var caller = this._dequeueCaller(rid);
				if(caller!=null){
					try{
						caller.onRemoteCallback(data);
					}
					catch(err){
						let12(err, true);
					}
				}
			}
		};
		this.init = function() {
			if (this.initialized) {return;}
			this.initialized = true;
		};
		
		this.start = function() {
			if (this.started) {return;}
			this.started = true;
		};
	}
	MI8.prepare(RM91).im13(MI8.XJA3).im13(MI8.FM2);
	RM91.prototype.toParamString = toParamString;

	RM91.prototype.rand = randStr;


	RM91.toParamString = toParamString;

	/**
	 * Returns conversation transcript messages from APIService to restore active async chat
	 * @param {Function} callback callback to call opener scripts if no messages retrieved or error occurred
	 */
	RM91.prototype.Glk4 = function(callback) {
		this.transcriptRequestCount++;

		//callback for conversation transcript request
		function callbackFcn(response) {
			var transcriptRequestEndTime = Date.now();

			if (response.responseStatus < 200 || response.responseStatus > 299) {
				if (ROM.transcriptRequestCount > gc7("CONVERSATION_TRANSCRIPT_RETRY_COUNT")) {
					//in the case of unsuccessful request log error and show openers
					ROM.transcriptRequestCount = 0;
					callback();
					let12("Can't get conversation transcript, response status code: " + response.responseStatus, true);
				} else {
					//try to get transcript one more time
					setTimeout(ROM.Glk4.bind(ROM, callback), gc7("CONVERSATION_TRANSCRIPT_RETRY_INTERVAL"), callback);
				}
				return;
			}
			//parse and update chat transcript
			if (window["Application"] && typeof window["Application"]["processConversationTranscriptResponse"] == "function") {
				if (Application.processConversationTranscriptResponse(response, callback)) {

					CHM.fireTranscriptReceivedEvent({
						requestCount: ROM.transcriptRequestCount,
						responseTime: transcriptRequestEndTime - ROM.transcriptRequestStartTime
					});

					ROM.transcriptRequestCount = 0;
					ROM.transcriptRequestStartTime = 0;
				} else {
					let12("Can't parse conversation transcript ", true);
				}
			} else {
				let12("Can't process conversation transcript, CI is unavailable ", true);
			}

		}

		var url = urls.conversationTranscriptURL + "/getTranscript";
		var conversationTranscriptMode = CHM.getChat() && CHM.getChat().getRule() ? CHM.getChat().getRule().conversationTranscriptMode : null;
		var conversationTranscriptDays = CHM.getChat() && CHM.getChat().getRule() ? CHM.getChat().getRule().conversationTranscriptDays : null;
		var data = prepareBaseBodyForAsyncChatDataRequest();
		data.businessUnitID = CHM.getBusinessUnitID();
		if (CHM.getAgentGroupID()) {
			data.agentGroupID = CHM.getAgentGroupID();
		}
		if (!CHM.getChat().isAsyncReconnect() || CHM.getChat().getCustMsgCnt() > 0) {
			data.excludeEngagementID = CHM.getChatID();
        }
		if (conversationTranscriptMode) {
			data.mode = conversationTranscriptMode.toLowerCase();
		}
		if (conversationTranscriptDays) {
			data.days = conversationTranscriptDays;
		}

		//Check if we have conversation tokens for cross channel option and pass them along
		CONVM.appendConversationIDsTo(data);
		// Track total time before valid transcript received
        if (this.transcriptRequestCount == 1) {
	        this.transcriptRequestStartTime = Date.now();
        }		
		this.post(url, data, generateRequestId("getTranscript"), false, callbackFcn);
	};

	/**
	 * Active async chatroom lookup
	 * @param {function} successCallback function to update chatID and continue to establish connection to Chat Router
	 * @param {function} errorCallback function continue to establish connection to Chat Router
	 */
	RM91.prototype.getActiveChatroomId = function(successCallback, errorCallback) {
		function callbackFcn(response) {
			if (response.responseStatus < 200 || response.responseStatus > 299) {
				let12("Error response when trying to get active async chatroom", true);
				errorCallback();
			} else if (response.data) {
				var responseData = response.data;
				if (responseData.chatID) {
					//we found active chatroom with offline client (agent loaded chat from follow up)
					CHM.updateChat(responseData.chatID, true);
					if (responseData.customerID) {
						setCustID(responseData.customerID, true);
					}
				} else if (CHM.getChat().isAsyncReconnect() && responseData.newChatID) {
					//there is no longer offline client/chatroom after we click on c2c (agent closed chat or client reconnected from another device)
					CHM.updateChat(responseData.newChatID, false);
				}
				successCallback(CHM.getChatID(), Inq.getCustID(), CHM.getChat().isAsyncReconnect());
			} else {
				//even if there is error we need to establish connection with server
				errorCallback();
			}
		}

		var url = urls.getExistingChatDataForReconnectOrNewChatId;
		var data = {"siteID": getSiteID(), "customerID": Inq.getCustID(), "businessUnitID": CHM.getBusinessUnitID()};
		if (CHM.getAgentGroupID()) {
			data.agentGroupID =  CHM.getAgentGroupID();
		}
		if (getUserObject()) {
			data.user_object = JSON.stringify(getUserObject());
		}
		if (getAuthUser()) {
			data.authenticatedUser = JSON.stringify(getAuthUser());
		}
		if (getPersistCustID()) {
			//need format for logging because server cache has the same format (not JSON)
			data.persistentCustomerID = FP.getPersistentCustomerID();
		}

		this.post(url, data, generateRequestId("getExistingChatDataForReconnectOrNewChatId"), false, callbackFcn);
	};

	/**
	 * Checks if customer has active conversations.
	 * Sends request to TagServer->API Service and get's historic/realtime data about customer conversations
	 */
	RM91.prototype.hasActiveConversations = function() {

		function callbackFcn(response) {
			if (response.responseStatus < 200 || response.responseStatus > 299) {
				let12("Error returned for active conversation request, status code " + response.responseStatus, true);
				CONVM.reset();
			} else {
				if (response.data) {
					var responseData = typeof response.data == 'string' ?  JSON.parse(response.data) : response.data;
					if (responseData.customerID) {
						CONVM.setInitialCustomerID(responseData.customerID);
					}
					var conversationsLength = responseData.conversations.length;
					setConversationActive(conversationsLength > 0);
					if (conversationsLength > 0) {
						CONVM.setLastBusinessUnitAndAgentGroup(responseData.conversations[0]["lastBusinessUnitID"], responseData.conversations[0]["lastAgentGroupID"]);
					} else {
						CONVM.reset();
					}
				} else {
					let12("Empty response returned for active conversation request", true);
					CONVM.reset();
				}
			}
			if (!gc7(DEFERRED_START_OF_MANAGERS_KEY) || !isPersistentChatLaunchingLimited()) {
				startMgrs.call(Inq, mgrList);
			}
		}

		var url = urls.conversationTranscriptURL + "/customerActiveConversations";
		var data = prepareBaseBodyForAsyncChatDataRequest();
		this.post(url, data, generateRequestId("customerActiveConversations"), false, callbackFcn);
	};

	/**
	 * Augment each of the given event with required chat data depends on the event type.
	 * Then, post the stringified events to the given url.
	 * depends on the evt.evt type.
	 * @param rule The rule that called this method.
	 * @param evts Either a single event object or and object that contains fields:
	 *        eventList - array of event objects from ACIF custom event data,
	 *        callback  - a callback function.
	 *        errorCallback  - a error Callback function.
	 *
	 * @param url The url to the /logDataArray IJSFLoggingController endpoint.
	 */
	RM91.prototype.logEventsToDW = function(rule, evts, url) {
		if (inu1(rule) || inu1(evts) || inu1(url)) {
			logErrorInPostToTagServer(
				plc1("'logEventsToDW' the rule, evts or url must be defined. rule:["
				+ rule + "], evts: [" + evts + "] url:[" + url + "].")
			);
			return;
		}
		var cbFunction = evts.callback;
		var errorCallback = evts.errorCallback;
		var eventList = evts.eventList;
		if (!e9(eventList)) {
			eventList = [evts];
		}
		var events = [];
		// Add CHM and rule data fields to each event depends on the event type.
		for (var i=0; i<eventList.length; i++) {
		    var augmentedEvent = this.prepareDataFieldsForETL(rule, eventList[i]);
			if (augmentedEvent != null) {
			    events.push(augmentedEvent);
			} else {
				logErrorInPostToTagServer(
					plc1("'logEventsToDW' custom event must contain both a '_domain'" +
					" property and an 'evt' (event name) property.")
				);
				return;
			}
		}
		this.post(
			url,
			{stringifiedDataArray: JSON.stringify(events)},
			generateRequestId("logEventsToDW"),
			true,
			cbFunction,
			errorCallback
		);
	};

	/**
	 * Add chat, rule data fields to the given event depends on the event type.
	 * @param rule The rule.
	 * @param evt The given event object
	 * @returns Object that augmented the given evt with chat and rule data.
	 */
	RM91.prototype.prepareDataFieldsForETL = function (rule, evt) {
		if (e9(evt, false, true) &&
			e9(evt._domain, false, true) &&
			e9(evt.evt, false, true)) {
			return EDB.build(evt, rule);
		}
		return null;
	};

	/**
	 * This function create HTML element "form" which we will use for send
	 * data to TS by submit this form.
	 *
	 * @param action {string} URL on which we do POST.
	 * @param data {object} which we use to fill the form.
	 * @param target {string} the name of the iframe into which we will submit the form.
	 * @param formId {string} some string for create unique id.
	 * @returns {HTMLElement} this function return HTMLElement "form" which already completed with data.
	 */
	RM91.prototype.createFormToPost = function (action, data, target, formId) {
		var doc = document;
		var form = doc.createElement("form");
		form.setAttribute("name", formId);
		form.setAttribute("id",formId);
		form.setAttribute("action", action);
		form.setAttribute("method", "POST");
		form.setAttribute("target", target);
		for (var name in data) {
			if (typeof data[name] !== "function" && !inu1(data[name])) {
				var textArea = doc.createElement("textarea");
				textArea.setAttribute("name", name);
				textArea.value = data[name];
				form.appendChild(textArea);
			}
		}
		return form;
	};

	/**
	 * Verify if the given tokenID is a valid cross channel token, if valid the returned payload is to
	 * be used with /getTranscript calls.
	 *
	 * Details: Cross channel option allows a user to continue a previous discussion that
	 *          occurred on another channel (sms, fb, etc)
	 *
	 * @param {string} tokenID - the received cross channel hop url token to check
	 * @param {function=} onSuccessCb - successful callback
	 * @param {function=} onErrorCb - error callback
	 *
	 * @fires: fires CONVM.fireVerifyTokenSuccessEvent or CONVM.fireVerifyTokenErrorEvent
	 */
	RM91.prototype.verifyToken = function (tokenID, onSuccessCb, onErrorCb) {
		function callbackFcn (response) {
			if (response.responseStatus === 200) {
				if (typeof onSuccessCb === "function") {
					onSuccessCb();
				}
				CONVM.setConversationIDs(response.data.conversationTokenID, response.data.conversationObjectID);
				CONVM.fireVerifyTokenSuccessEvent(response.data);
			} else {
				if (typeof onErrorCb === "function") {
					onErrorCb();
				}
				CONVM.setConversationIDs(null, null);
				CONVM.fireVerifyTokenErrorEvent(response.data);
			}
		}

		var data = {
			siteID: getSiteID(),
			customerID: Inq.getCustID(),
			conversationTokenID: tokenID
		};
		this.post(urls.verifyTokenURL, data, generateRequestId("verifyToken"), false, callbackFcn);
	}

	/**
	 * EXCBTT class
	 * @class Represents a custom event definition
	 * @constructor
	 * @borrows XJA3#absorb as #absorb
	 * @borrows Cloneable#clone as #clone
	 * @see XJA3
	 * @param {Object} cEvtData custom event data definition
	 * Incoming data defined as follows:
	 * {name:"Converted", getEvtData: function(){ return {products:PM.getCookie("productsCookie")};}, aliases:[{name:"onSoldEvent", getEvtData: function(){return {"products":Inq.s7("inqSalesProducts")};}}]}
	 */
	function EXCBTT(cEvtData){
		this.absorb(cEvtData);
	}

	/**
	 * Checks any given object to see if any of it's methods
	 * are supported listeners of this custom event.
	 * @returns {boolean} True if the given object sports listener
	 * methods of the custom event or any of its aliases. False otherwise.
	 */
	EXCBTT.prototype.supportsListener = function(l){
		if(l){
			var lFcn = l["on"+this.name];
			if(lFcn && typeof lFcn=="function"){
				return true;
			}
			if (this.aliases && this.aliases.length) {
				for(var idx=0; idx<this.aliases.length; idx++){
					lFcn = l[this.aliases[idx].name];
					if(lFcn && typeof lFcn=="function"){
						return true;
					}
				}
			}
		}
		return false;
	};

	/**
	 * Invokes all methods supported by the EXCBTT on a given object with proper data.
	 * @param {object} rule the rule that fired the custom event
	 * @param {object} evt event object that triggered the rule firing this custom event.
	 * It is a source of contextual data that may be used to compose custom event data.
	 */
	EXCBTT.prototype.getData = function(rule, evt){

		// getEvtData method is expected in every EXCBTT object instance
		// The method itself is not available from object prototype, it is generated when business rules are rendered
		var data = this.getEvtData(rule, evt);

		// evtDataSupplement object is optional and is added if rule firing this custom event decides
		// to provide additional data
		if (this.evtDataSupplement) {
			MI8.mixAbsorber(data);
			data.absorb(this.evtDataSupplement);
		}
		return data;
	}

	/**
	 * Invokes all methods supported by the EXCBTT on a given object with proper data.
	 * @param {object} l Observer object on which to invoke the methods for the customer event
	 * @param {object} rule the rule that fired the custom event
	 */
	EXCBTT.prototype.invoke = function(l, rule, evt){
		if(this.supportsListener(l)){
			var lFcn = l["on"+this.name];
			if(lFcn && typeof lFcn=="function"){
				l["on"+this.name](this.getData(rule, evt));
			}
			if(this.aliases){
				for(var idx=0; idx<this.aliases.length; idx++){
					var aliasEvt = this.aliases[idx];
					lFcn = l[aliasEvt.name];
					if(lFcn && typeof lFcn=="function"){
						try {
							var s;
							var sName;
							if (isAliasesNoEvalToggleEnable()) {
								s = aliasEvt.getEvtData(rule, evt);
								sName = aliasEvt.name;
								if (typeof sName === "string") {
									l[sName](s); // invoke the alias methods too on the listener with alias data definitions.
								} else {
									lmt12("Failure in EXCBTT: Invalid name of aliasEvt: " + JSON.stringify(sName) +
										" RuleId: " + rule.id +
										" SiteId: " + getSiteID(), LOG_LEVELS.WARN);
								}
							} else {
								s = MI8.JSON.stringify(aliasEvt.getEvtData(rule, evt));
								sName = MI8.JSON.stringify(aliasEvt.name);
								/* l is a local variable and not known to the eval function [on all browsers]
								 * So we must define a label for it temporarily in the client page and
								 * ... run it as belonging to the parent
								 * This then will run in the client window
								 */
								var label4l = "_inq_el_" +  (Math.round(Math.random()*982451653)).toString(36) ;
								win[label4l] = l ;	/* Publish (l) in the client window so it can be accessed in web-kit browsers and IE */
								var code = "(parent)."+label4l+"[" + sName + "]("+s+")"; /* Note: parent is in parenthesis so "this" will point to it ! */
								evaluateLegacySettings(code); // invoke the alias methods too on the listener with alias data definitions.
								try {win[label4l] = null ; delete win[label4l];} catch(e){}	/* Unpublish (l) in the client window*/
							}
							lmt12("Alias was run. RuleId: " + rule.id +
								" SiteId: " + getSiteID() +
								" Alias name: " + aliasEvt.name +
								" aliasesNoEvalToggleEnable enabled: " + isAliasesNoEvalToggleEnable() , LOG_LEVELS.INFO);
						}catch(err){
							err["within"] = "EXCBTT.invoke";		/* Specify where the problem is for the trace information */
							var sErr = cf21(err) ;			/* Have catchFormater format the stack trace for log and for sending to the tagserver host */
							log("Error while calling the client side listeners"+decodeURIComponent(sErr));
							lmt12("Failure in EXCBTT invoke " + sErr, LOG_LEVELS.ERROR);
						}
					}
				}
			}
		}
	};

	/**
	 * Returns string representation of this object.
	 */
	EXCBTT.prototype.toString = function(){
		return "EXCBTT " + this.name;
	};

	MI8.prepare(EXCBTT).im13(MI8.XJA3).im13(MI8.Cloneable);

	/**
	 * Returns copy of this object.
	 */
	EXCBTT.prototype.clone = function(){
		return new EXCBTT(this);
	};

	/**
	 * Singleton class that routes all observers to their respective observables. 
	 * Mitigates linkage amongst framework managers through delegation.
	 * @class Event Manager is a singleton class that routes all observers to their respective observables
	 * @constructor
	 * @borrows XJA3#absorb as #absorb
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @see XJA3
	 * @see FM2
	 */
	function EMT5(id){
		this._frameworkModule(id);
		this._observable(); // contract with MixIn.Observable
		this.initialized = false;
		this.observables = [];
		this.cEvts={};

		this.init = function(){
			if(!this.initialized){
				this.initialized=true;
			}
		};
		
		/**
		 * Appends an array of observables to the internal array of managed observables.
		 * @param {Object} ol Object whose children MAY be {@link Observable} instances to be appended.
		 * This method will test for observables and manage them when found.
		 * @see Observable
		 */
		this.addObservables = function(o){
			if(o){
				for(var idx in o){
					// avoid a recursive addListeners call later by not placing EVM into its own observables list
					if(o[idx].observable && o[idx] != this){
						this.observables.push(o[idx]);
					}
				}
			}
		};
		
		this.start = function() { 
			if(this.started) { return;}
			this.started = true;
		};
		
		
		/**
		 * Routes an array of observers to their correct respective {@link Observable}
		 * @param {Array} list An array of observers to be routed.
		 */
		this.addListeners = function(list){
			if(list && list.length){
				for(var i=0; i < list.length; i++){
					this.addListener(list[i]);
				}
			}
		};
		
		/** 
		 * Determines if a given object is an acceptable listener for this class.
		 * Overrides MixIn.Observable.isListener method.
		 * @see MixIn.Observable.isListener
		 */
		this.isListener = function (l){
			// Iterate over all custom events and look for
			for(var cEvtName in this.cEvts){
				var cEvt = this.cEvts[cEvtName];
				if(cEvt.supportsListener(l)) {
					return true;
				}
			}
			return false;
		};
	}

	/**
	 * Adds definition of custom event to the registry of custom events.
	 * @param {Object} customEvt object of EXCBTT class
	 */
	EMT5.prototype.addCustomEvent = function (customEvt) {
		if(customEvt && !this.cEvts[customEvt.name]){
			this.cEvts[customEvt.name] = customEvt;
		}
	};

	/**
	 * Adds all custom events from provided array.
	 * @param {Array} array of EXCBTT objects
	 */
	EMT5.prototype.addCustomEvents = function (customEvtsArr) {
		if(customEvtsArr) {
			for(var idx=0; idx < customEvtsArr.length; idx++){
				this.addCustomEvent(customEvtsArr[idx]);
			}
		}
	};

    EMT5.prototype.getCustomEvent = function (name) {
        return this.cEvts[name];
    };
	/**
	 * Removes definition of custom event from the registry of custom events.
	 * @param {Object} customEvt object of EXCBTT class
	 */
	EMT5.prototype.removeCustomEvent = function (customEvt) {
		if(customEvt)
			delete this.cEvts[customEvt.name];
	};

	/**
	 * Custom event fire action.
	 * @param eventName name of the custom event to fire
	 * @param {object=} rule the rule object that fires this event
	 * @param evt Event object that triggered the rule firing this custom event.
	 * It is a source of contextual data that may be used to compose custom event data.
	 * Optional but used a lot for service lifecycle events.
	 * @param {function=} evtDataSupplementFcn - function generating additional data supplied at the time of custom event firing.
	 * These data are used to supplement/override data defined in the custom event definition.
	 * Does not apply to data in aliases.
	 * @param context {boolean} optional. Only in force when in persistent window. If defined and the event is fired in the persistent window 
	 * context, then the evtmgr will attempt to delegate the call to the main window's framework so that externally registered listeners
	 * may be notified.  If null, false or undefined, then the call is made normally (in current javascript context).
	 * @throws UnsupportedEventError when the event mgr is told to throw a CEvt it can't find.
	 * @throws MissedEventError when onPageLanding event not fired.
	 */
	EMT5.prototype.fireCustomEvent = function (eventName, rule, evt, evtDataSupplementFcn, context) {
        if (!isInqInitialized)
            throw ("MissedEventError: " + eventName);
		if(!!context && CHM.isPersistentWindow()){
			try{
				parent.opener.Inq.fireCustomEvent(eventName, evt, rule);
			}catch(err){
				log("failed to fire custom event \""+eventName+"\" from persistent window: "+err);
			}
		}else{
			var cEvt = this.cEvts[eventName];
			if(cEvt){
				if (evtDataSupplementFcn) {
					cEvt = cEvt.clone();
					cEvt["evtDataSupplement"] = evtDataSupplementFcn(rule, evt);
				}
				this._fireEvt(
					function(l, evt) {
						if (l){
							cEvt.invoke(l, rule, evt); // using closures to invoke here
						}
					},
					evt
				);
				return;
			}
			throw ("UnsupportedEventError: " + eventName);
		}
	};
	
	EMT5.prototype.fireManualInvocationEvent = function(rule) {
		BRM.fireManualInvocationEvent(rule);
	};
	
	MI8.prepare(EMT5).im13(MI8.FM2).im13(MI8.Observable);	

	/**
	 * Links a given observer to its correct observable.
	 * @param {Object} l Observer (listener) to be connected. If no {@link Observable} supports
	 * the listener, then no connection is made.
	 */
	EMT5.prototype.addListener = function(l){
		if(l){
			for(var i=0; i<this.observables.length; i++){
				this.observables[i].addListener(l);
			}
			if(this.isListener(l)){
				this._listeners.push(l);
			}
		}
	};

	/**
	 * Returns string representation of this object.
	 */
	EMT5.prototype.toString = function(){
		return "EMT5(\"" + this._id + "\")";
	};

	/**
	 * Landing Manager handles all page landing history and
	 * history questions including landing zones or content groups.
	 * @class Landing Manager class that handles all page landing history and
	 * history questions including landing zones or content groups.
	 * @implements {DataExporter}
	 * @param {String} id Manager unique id
	 * @param {Object} data Static data defined by TC BR30 xml.
	 */
	function LE12(id, data){
		this.lh = [];
		this._frameworkModule(id);
		this._observable();
		this.initialized = false;
		this.page = null;
        this.quickCGIndex = {};
        var cgIndex = 0;
        this.reinitialized = false;
		this.absorb(data);
        for (var cgId in this.contentGroups) {
	        this.contentGroups[cgId] = CG.c(this.contentGroups[cgId]);
            this.quickCGIndex[cgId] = cgIndex++;
        }
	}
	MI8.prepare(LE12).im13(MI8.FM2).im13(MI8.XJA3).im13(MI8.Observable).im13(MI8.Persistable);

	/**
	 * @inheritDoc
	 */
	LE12.prototype.getData = function(){
		var thisRef = this;
		return {
			pageMarker: this.getPageMarker(),
			pageID: this.getPageID(),
			pageURL: this.getCurrentPageURL(),
			landingHistory: this.getLandingHistory(),
			checkCG:function(cgID, optPgIdx){ return thisRef.checkCG(cgID, optPgIdx);}
		};
	};

	/**
	 * initializes the landing manager once instantiated. Resolves the url to a mapped page from the pages provided in
	 * data (seeded by constructor). Initializes persistence variables when invoked.
	 * @param {Boolean} [doReinit] set to true if it is desired to reinitialize the state of the landing manager to simulate a
	 * new page landing.
	 * @see MI8.FM2
	 * @see reinitChat()
	 */
	LE12.prototype.init = function(doReinit) {
		if(!!doReinit) {
			this.page=null;
			this.reinitialized = true;
		}
		if(!this.initialized){
			this.stateVar = new VER34(this.getID(),{lh:[]}, resources["state"]);
			this.stateVar.init();
			this.load();
		}
		this.initialized = true;
		if (v3Lander.isRplMode) {
			this.page = win.v3Lander.getPage();
			this.restorePagesByIds();
		} else {
			this.overridePage();
		}
		this.addPageToLH();
	};

	LE12.prototype.overridePage = function () {
		var orID = Inq.overridePageID;
		if (orID > 0) {
			this.page = (this.pages[orID] ? this.pages[orID] : null );
		} else if (!v3Lander.isRplMode) {
			this._resolvePage();
		}
	};

	/**
	 * Getting "Page" objects from TS by page ids from lh (landing history ids).
	 */
	LE12.prototype.restorePagesByIds = function () {
		var visitedPages = [];
		this.lh.forEach(function (element) {
			if (element.id !== -1 && !visitedPages.includes(element.id)) {
				visitedPages.push(element.id);
			}
		});
		if (this.page && !visitedPages.includes(this.page.id)) {
			visitedPages.push(this.page.id);
		}
		if (visitedPages.length > 0) {
			var data = {
				pages: visitedPages,
				siteID: getSiteID(),
				url: document.URL,
				codeVersion: v3Lander.codeVersion
			};
			var url;
			if (isResolvePageServiceEnabled()) {
				url = urls.resolvePageWSURL;
			} else {
				url = urls.resolvePageURL;
			}
			ROM.post(url, data, null, null, function (context) {
				if (typeof context.data == "string") {
					context.data = JSON.parse(context.data);
				}
				if (context.data && context.data.pages) {					
					this.pages = context.data.pages;
				}
				this.onPageResolution();
			}.bind(this));
		} else {
			this.onPageResolution();
		}
	};

	/**
	 * Internal use only. Resolves page for non-bup mode.
	 * @private
	 */
	LE12.prototype._resolvePage = function(){
		var pages = this.pages;
		var pageURL = isWebSDK ? window.pageUrl : win.location.href;
		for(var i in pages) {
			var re = pages[i].re;
			if (re === "") {//skip empty regexs to improve performance.
				continue;
			}
			// Hack Alert: "prepend directives" ex. (?i) in javascript are not supported but they
			// may exist in these regexps... consequently we need to strip them off and raise the
			// "case insensitive" flag as a javascript flag.
			var caseInsensitive = false;
			if (re.indexOf("(?i)") === 0) {
				re = re.substr(4);
				caseInsensitive = true;
			}
			var r = new RegExp(re, caseInsensitive ? "i" : undefined);
			var mat = r.exec(pageURL); // we need a precise match... the RegExp.test() method won't cut it.
			if (!!mat && mat[0] == pageURL) { // the regexp "consumed" the WHOLE URL... this is an exact match.
				this.page = pages[i];
				break;
			}
		}
	};

	/**
	 * Obtains the page url for the current page. If in persistent window, will return the url of the main context parent URL.
	 * @return {String} site main page url. Null if any error occurs. Should never throw error.
	 */
	LE12.prototype.getCurrentPageURL = function(){
		if (isWebSDK) {
			return CHM.isPersistentWindow() ? o1p().pageUrl : window.pageUrl;
		} else {
			try {
				return CHM.isPersistentWindow() ? top.opener.location.href : win.location.href;
			} catch (e) {
				return win.location.href;
			}
		}
	};

	/**
	 * Obtains a page marker for a given page history idx.
	 * @param {number} idx Index of the page history queue. 0 is current page.
	 * May be null or undefined. Will return current page marker if undefined. If it is a persistent window then
     * return value from origin
	 * @return {String} page marker for the given page idx."unmarked page" if page not found.Should never throw error.
	 */
	LE12.prototype.getPageMarker = function(idx, evt) {
        var p = null;
        if(CHM.isPersistentWindow()) {
            try {
				p = (evt && evt.page) || openerData.page || openerCall("getPage", [idx]);
				this.getPageMarkerErrorLog = false;
            } catch(err) {
				if( !this.getPageMarkerErrorLog ) {
					lmt12("Can't get opener page marker data for ChatID = " + CHM.getChatID() + ". CustomerID = " + getCustID(), LOG_LEVELS.WARN);
					this.getPageMarkerErrorLog = true;
				}
            }
        }
        if(!p) {
            p =  this.getPage(idx);
        }
        return p?p.mID:"unmarked page";
	};
	/**
	 * Obtains a page id for a given page history idx.
	 * @param {number} idx Index of the page history queue. 0 is current page.
	 * May be null or undefined. Will return current page id if undefined. If it is a persistent window then
     * return value from origin
	 * @return {Number} page id for the given page history idx. -1 if page not found. Should never throw error.
	 */
	LE12.prototype.getPageID = function(idx, evt) {
		if (isCEAPIPostChatSurveyMode()) {
			return inu1(parent.CEAPI_POST_CHAT_SURVEY_DATA.pageID) ? -1 : parent.CEAPI_POST_CHAT_SURVEY_DATA.pageID;
		}

        var p = null;
        if(CHM.isPersistentWindow()) {
            try {
				p = (evt && evt.page) || openerData.page || openerCall("getPage", [idx]);
				this.getPageIdErrorLog = false;
            } catch(err) {
				if( !this.getPageIdErrorLog ) {
					lmt12("Can't get opener page id data for ChatID = " + CHM.getChatID() + ". CustomerID = " + getCustID(), LOG_LEVELS.WARN);
					this.getPageIdErrorLog = true;
				}
            }
        }
        if(!p) {
            p =  this.getPage(idx);
        }
        return p?p.id:-1;
	};
	/**
	 * Obtains a page marker for a given landing history queue index.
	 * @param {Number} idx Index of the page history queue. 0 is current page.
	 * May be null or undefined. Will return current page (idx = 0) if undefined or null.
	 * @return {Object} Page object consisting of id, mID and regex. Null if not found or queue is empty.
	 * Should not throw errors on any input.
	 */
	LE12.prototype.getPage = function(idx) {
		var tempPage = null;
		if (inu1(idx)) {
			tempPage = this.page;
		} else {
			if (this.lh && this.pages) {
				var page = this.lh[idx];
				if (page) {
					tempPage = this.pages[page.id] ? this.pages[page.id] : {id: 0, mID: "unmarked page", re: "(.*)"};
				}
			}
		}
		return tempPage;
	};

	/**
	 * Obtains a page marker for a given page id.
	 * @param id Page id.
	 * @returns {String} Page marker. "unmarked page" if no corresponding marker for the page id.
	 */
	LE12.prototype.getPageMarkerById = function (id) {
		var page = this.pages[id];
		if (page) {
			return page.mID;
		} else {
			return "unmarked page";
		}
	};

	/**
	 * Checking current page and add id and content groups ids of this page in the
	 * start of landing history. Landing history is clipped on {@link qsize}.
	 * Storing that in cookie.
	 */
	LE12.prototype.addPageToLH = function() {
		var pageId = this.page ? this.page.id : -1;
		/* array indexes of corresponded CG */
		var cgIdsArray;

		/**
		 * use content groups that resolved at tagserver if isRplMode and loaded
		 * (see also {@link #applyPage} and {@link LaunchController.java#resolvePage})
		 */
		if (v3Lander.isRplMode
			&& win.v3Lander.getContentGroupIDs()
			&& win.v3Lander.page
			&& this.page
			&& win.v3Lander.page.mID === this.page.mID) {
			cgIdsArray = this.getCorrespondedCGIndexes(win.v3Lander.getContentGroupIDs());
		} else {
			cgIdsArray = this.findCorrespondedCG(pageId);
		}
		this.lh.unshift({id: pageId, cg: cgIdsArray});
		if(this.lh.length > this.qsize){
			this.lh.length = this.qsize > 0 ? this.qsize : 1;
		}
		this.save();
	};

	LE12.prototype.load = function() {
		this.absorb(this.stateVar.z0());
	};
	LE12.prototype.save = function() {
		this.stateVar.z3({lh: this.lh});
	};

	/**
	 * Obtains an array of marker id strings in the landing order.
	 * @return {Array} array of marker strings for the landing history.
	 * Never null. May be empty.
	 */
	LE12.prototype.getLandingHistory = function(){
		var retval = [];
		for(var idx=0;idx<this.lh.length;idx++){
			retval[idx] = this.getPageMarker(idx);
		}
		return retval;
	};

	LE12.prototype.start = function() {
		isInqInitialized = true;
		/** RTDEV-19195 added this code to fire pagelanding only after rpl lookup is done, but this is not applicable in ceapi postchat survey as there is no rpl lookup need for the ceapipostchatsurvey page */
		if (!v3Lander.isRplMode || isCEAPIPostChatSurveyMode() || this.postponedOnPageLanding) {
			this.onPageResolution();
			this.postponedOnPageLanding = false;
		}
	};

	LE12.prototype.onPageResolution = function() {
		if (!isInqInitialized) {
			this.postponedOnPageLanding = true;
			return;
		}
		if (isPersistentChatLaunchingLimited()) {
			this.fireOnPageLandingEventForPersistentWindow(this.page);
		} else {
			this.fireOnPageLandingEvent(this.page);
		}
	};

	LE12.prototype.pageCheck = function(pageID) {
		if (inu1(this.page)) {
			return false;
		} else {
			return this.page.id==pageID;
		}	
	};
	LE12.prototype.reset = function() {};

	LE12.prototype.fireOnPageLandingEvent = function(dat) {
		function onPageLanding(l, evt) {
			try {
				if (l.onPageLanding) {
					l.onPageLanding(evt);
				}
			} catch(e) {
				log(e);
			}
		}
		this._fireEvt(onPageLanding, {page:this.page, data:dat, reinitialized:this.reinitialized});
	};

	LE12.prototype.fireOnPageLandingEventForPersistentWindow = function(dat) {
		function onPageLandingForPersistentWindow(listener, evt) {
			try {
				if (listener.onPageLanding) {
					if (listener instanceof BusinessRule || listener instanceof Rule && listener.getID() > 1000) {
						// in the persistent window will execute only Program Rules
					} else {
						listener.onPageLanding(evt);
					}
				}
			} catch(e) {
				log(e);
			}
		}
		// When flag DEFERRED_START_OF_MANAGERS is TRUE chat will be restored in agrtyer event.
		// See: GR34.prototype.agrtyer
		// But for backward compatibility we need support the launching of chat in common way.
		var skipRestoreChat = gc7(DEFERRED_START_OF_MANAGERS_KEY);
		this._fireEvt(onPageLandingForPersistentWindow, {page:this.page, data:dat, reinitialized:this.reinitialized, isChatLaunched: skipRestoreChat});
	};

	LE12.prototype.isListener = function(l) {
		return (l && l.onPageLanding);
	};

	LE12.prototype.getPersistentID = function() {
		return this.getID();
	};

	LE12.prototype.agrtyer = function() {
		log("LE12#agrtyer");
	};
    /**
     * find CG which contains pgId
     * @param pgId
     */
    LE12.prototype.findCorrespondedCG = function (pgId) {
        var out = [];
        var url = this.getCurrentPageURL();
        var index = 0;
        for (var cgId in this.contentGroups) {
            var cg = this.contentGroups[cgId];
            if (cg.contains(pgId, url, this.contentGroups)) {
                /* save index of passed CG */
                out[out.length] = index;
            }
            index ++;
        }
        return out;
    };

	/**
	 * get indexes of CG that described by content group ids
	 * @param cgIDs content group ids for current page
	 */
	LE12.prototype.getCorrespondedCGIndexes = function (cgIDs) {
		var out = [];
		for (var i = 0; i < cgIDs.length; i++) {
			out.push(this.quickCGIndex[cgIDs[i]]);
		}
		return out;
	};

	LE12.prototype.checkCG = function(cgID, optPgIdx) {
		var page = this.lh[optPgIdx&&optPgIdx<this.lh.length ? optPgIdx : 0];
		var cgIndex = this.quickCGIndex[cgID];
        if (inu1(cgIndex) || inu1(page)) {
            return false;
        }
        var passedCG = page.cg;
        for (var index = 0; index < passedCG.length; index ++) {
	        if (passedCG[index] == cgIndex) {
                return true;
            }
        }
        return false;
	};

    /**
     * Returns business units associated which content groups which contain current page id
     * @return {Array} array with business units set for content groups
     */
    LE12.prototype.getCGBusinessUnits = function () {
        var result = [];
        for (var cg in this.contentGroups) {

            var buIDs = null;
            if (this.contentGroups[cg].contains(this.getPageID(), this.getCurrentPageURL(), this.contentGroups)) {
                buIDs = this.contentGroups[cg].getBusinessUnits();
                if (buIDs) {
                    for (var i = 0; i < buIDs.length; i++) {
                        result.push(buIDs[i]);
                    }
                }
            }
        }
        return result;
    };

     /**
	 * Business Rules Manager
	 * @class G3R3
	 * @constructor
	 * @name G3R3
	 * @param {String} id
	 * @param {Object} data containing field "rules" with rules and business rules and field globalRAtts with
	 * @param {Boolean} disableMutationObservation
	 * global rule attributes.
	 * @implements {DataExporter}
	 * @borrows XJA3#absorb as #absorb
	 * @borrows Observable#addListeners as #addListeners
	 * @borrows Observable#clearListeners as #clearListeners
	 * @borrows Observable#_fireEvt as #_fireEvt
	 * @borrows Observable#addListener as #addListener
	 * @borrows Observable#isListener as #isListener
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @see Observable
	 * @see XJA3
	 * @see FM2
	 */
	function G3R3(id, data, disableMutationObservation) {
		 this._frameworkModule(id);
		 this._observable();
		 this._domRules = [];

        // MAINT24-159: rule overriding support: <override-rule> defined in business section overrides
        // <overridable-rule> with the same id defined in program section.
        // Note that validation of section where appropriate rules were declared and
        // matching of their ids is performed by XSD constaints, see br30.xsd for documentation.
        var rulesIndexes = {};
		var onDomMutation = debounce(function onDomMutation() {
				BRM.refreshDomRules();
			}, 100);
		/**
		  Observing MutationObserver will crash in IE if client script is modifying element textContent directly.

		  observer = new MutationObserver(function(){})
		  observer.observe(document, {childList: true, subtree: true})

		  el = document.getElementsByTagName('strong')[0]
		  el.textContent = '-'
		  el.textContent = '-t'
		  **/
		if(!isWebSDK && !!window.MutationObserver && !disableMutationObservation){
			domObserver = new MutationObserver(onDomMutation);
			domObserver.observe(doc.body, {childList: true, subtree: true, attributes: true});
			doc.body.setAttribute('data-inq-observer', '1');
		}
        if(data && data.rules){
            for(var i = 0; i < data.rules.length; i++) {
                var r = data.rules[i];
				// RTDEV-12271 - hasDomTrigger property was set from base_rule.jsp and business_rule.jsp and the value was obtained
				// from RenderRule.java
				if (r.hasDomTrigger) {
					this._domRules.push(r);
				}
                var id = r.getID();
                var overridableRuleInd = rulesIndexes[id];
                if (overridableRuleInd == undefined) {
                	rulesIndexes[id] = i;
                } else {
                    // The overridden rule is totally eclipsed by the overriding rule
                	data.rules[overridableRuleInd] = r;
                    data.rules.splice(i, 1);
                    i--;
                }
            }
        }
        // End of rule overriding support

		this.absorb(data); /* Absorbing data including data.rules*/
		this._varTable = {};
		this._rulesById = {};
        this._ruleIds = [];
		this._bActionable = true; // used for incrementality control
		if(data && data.rules){
			for(var j = 0; j < data.rules.length; j++) {
				var r1 = data.rules[j];
				this._varTable[r1.getID()] = r1.getVars();
				this._rulesById[r1.getID()] = r1;
				this._ruleIds[j] = r1.getID();
			}
		}

		/**
		 * Obtains the complete set of rules in execution order.
		 */
		this.getRules = function() {
			return this.rules;
		};

		/**
		 * @TODO compete these methods
		 */
		this.start = function(){
			if (this.started) {
				return;
			}
			this.started = true;
		};
		this.init = function(reinitialize){
            if (this.initialized && !reinitialize) { return;}
            for(var i=0; i<this.getRules().length; i++){
                this.getRules()[i].init();
            }
            this.initialized = true;
            log(this.getID() + " initialized.");
		};
		this.load = function(){};
		this.save = function(){};
		this.agrtyer = function(){};

		/**
		 * Resets the rules in the manager for the PAGE ONLY.
		 * @TODO RHINOUNIT
		 */
		this.reset = function(){
			for(var i=0; i<this.rules.length; i++){
				this.rules[i].reset();
			}
		};
	}
	MI8.prepare(G3R3).im13(MI8.Persistable).im13(MI8.XJA3).im13(MI8.FM2);
	G3R3.im13(MI8.Observable);

	/**
	 * @inheritDocs
	 * @returns {Object} data object containing the following:
	 *  qBRs {BusinessRule[]},
	 *  rules {Rule|BusinessRule}[]
	 *  @see G3R3#getQualifiedBusinessRules
	 *  @see G3R3#getRules
	 */
	G3R3.prototype.getData = function(){
		updateDataFromOpener();
		var result = {
			qBRs: this.getQualifiedBusinessRules(),
			rules: this.getRules()
		};
		// The implementation of storing the data got from opener is not completed,
		// therefore we will clear them until finishing of implementation.
		clearDataFromOpener();
		return result;
	};

	/**
	 * RTDEV-8091
	 * Reset el["tcRuleIDs"] which was set on initialize chat.
	 * see  Rule#_processDomTrigger
	 */
	G3R3.prototype.resetForReinit = function() {
		for (var i = 0; i < this.rules.length; i++) {
			var triggers = this.rules[i].tt1(this.rules[i]);
			for (var j = 0; j < triggers.length; j++) {
				var trig = triggers[j];
				var elArray = [];
				var el;
				if (trig.domElementID) {
					el = doc.getElementById(trig.domElementID);
					if (!!el) elArray[0] = el;
				} else if (trig.domElements) {
					for (var idx = 0; idx < trig.domElements.length; idx++) {
						elArray.append(trig.domElements[idx]);
					}
				}
				for (var k = 0; k < elArray.length; k++) {
					el = elArray[k];
					if (!inu1(el)) {
						el["tcRuleIDs"] = null;
					}
				}
			}
		}
	};

	/**
	 * obtains the persistable's id
	 * @return {string} string id
	 * @see FM2#getID
	 */
	G3R3.prototype.getPersistentID = function() {
		return this.getID();
	};

	/**
	 * Obtains a list of rules for the page that may be targeted.
	 * @return {Array} array of rules that may target the page. Funnel levels ignored.
	 * @externalAPI Used by Implementation call and exposed through CustomerAPI.js
	 */
	G3R3.prototype.getQualifiedBusinessRules = function(){
		return this._collect(function(rule){
			if(rule.isBR() && rule.areConditionalsMet()){
				return rule;
			}
		});
	};

	/**
	 * Ensures that the rules that are listening for DOM events re-attach their listeners.
	 * Usually in response to DomMutationObserver triggers.
	 */
	G3R3.prototype.refreshDomRules = function(){
		// RTDEV-12271 - Only reattach triggers for Dom rules.
		this._domRules.forEach(function(rule){
			rule.reattachDomTriggers();
		});
	};

	/**
	 * Iterates on every rule the mgr instance maintains and passes it to the parameter function.
	 * @param fcn {Function} Function whose contract must take 2 params:
	 *      1. rule
	 *      2. index of the rule in the rule array (like a priority)
	 * and returns the rule if "accepted" by the param passed function or null/undefined if not.
	 * @return {Array} array of rules that were vetted by the passed function.
	 * @throws {Error} When fcn param is null, undefined or not a function
	 * @private
	 */
	G3R3.prototype._collect = function(fcn){
		var retcol = [];
		if(inu1(fcn) || typeOf(fcn)!="function"){
			throw new Error("Illegal Argument: expected a function, got "+(typeof fcn));
		}
		for(var i=0; i<this.rules.length; i++){
			var rule = this.rules[i];
			var val = fcn(rule, i);
			if(!inu1(val)){
				retcol[retcol.length]=val;
			}
		}
		return retcol;
	};

	/**
	 * Gets all variables categorized by rule id.
	 * @return {Object} series of arrays of vars mapped to rule ids.
	 * Each id maps to one array of vars.
	 * @TODO RHINOUNIT
	 */
	G3R3.prototype.getRuleVarTable = function() {
		return this._varTable;
	};

	 /**
	  * Gets rule by rule name
	  * @param {String} ruleName
	  * @return {Rule}
	  */
	G3R3.prototype.getRuleByName = function(ruleName) {
		var rule = null;
		// TODO: find way to find using a faster algorithm, consider sorting upon insertion of
		// rule?
		for (var i = 0; i < this.rules.length; i++) {
			if (this.rules[i].getName() === ruleName) {
				rule = this.rules[i];
				break;
			}
		}
		return rule;
	};

	 /**
	  * Gets rule by rule id
	  * @param {Number} ruleId
	  * @return {Rule}
	  */
	G3R3.prototype.rb41 = function(ruleId) {
		return this._rulesById[ruleId];
	};

	G3R3.prototype.setActionable = function(bActionable) {
		this._bActionable = bActionable;
	};

	 /**
	  * Checks if customer is in Control Group
	  * @return {boolean}
	  */
	G3R3.prototype.isControlGroup = function() {
		return !this._bActionable;
	};

	 /**
	  * Event for manual rule invocation
	  * @param {Rule} rule
	  */
	G3R3.prototype.fireManualInvocationEvent = function(rule) {
		var evt = {};
		if (!inu1(rule) && rule.onManualInvocation) {
			rule.onManualInvocation(evt);
		}
	};

	G3R3.prototype.fireRuleSatisfiedEvent = function(rule) {
		var event = {rule: rule};

		function f(l, evt) {
			try {
				if (l.onRuleSatisfied) {
					l.onRuleSatisfied(evt);
				}
			} catch(e) {
				log("Error firing event onRuleSatisfied on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, event);
	};

	G3R3.prototype.fireServiceInvitationEvent = function(rule, serviceType) {
		var event = {rule: rule, serviceType: serviceType };

		function f(l, evt) {
			try {
				if (l.onServiceInvitation) {
					l.onServiceInvitation(evt);
				}
			} catch(e) {
				log("Error firing event onServiceInvitation on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, event);
	};

	G3R3.prototype.fireServiceEngagedEvent = function(eventData) {
		var outRule = null;
		try {
			outRule = this.rb41(eventData.brID)
		}
		catch (e) {
			log("error " + e)
		}
		if (inu1(outRule)) {
			outRule = {id: eventData.brID};
		}

		var event = {rule: outRule};

		function f(l, evt) {
			try {
				if (l.onServiceEngaged) {
					l.onServiceEngaged(evt);
				}
			} catch(e) {
				log("Error firing event onServiceEngaged on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, event);
	};

	G3R3.prototype.fireServiceInteractedEvent = function(eventData) {
		var event = {rule: {id: eventData.brID}};

		function f(l, evt) {
			try {
				if (l.onServiceInteracted) {
					l.onServiceInteracted(evt);
				}
			} catch(e) {
				log("Error firing event onServiceInteracted on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, event);
	};

	G3R3.prototype.fireServiceMissedEvent = function(rule, serviceType) {
		var event = {rule: rule, serviceType: serviceType};

		function f(l, evt) {
			try {
				if (l.onServiceMissed) {
					l.onServiceMissed(evt);
				}
			} catch(e) {
				log("Error firing event onServiceMissed on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, event);
	};

	G3R3.prototype.fireExposureQualifiedEvent = function(eventData) {
		function f(l, evt) {
			try {
				if (l.onExposureQualified) {
					l.onExposureQualified(evt);
				}
			} catch(e) {
				log("Error firing event onExposureQualified on " + l.toString() + ": \n" + e);
			}
		}

		this._fireEvt(f, eventData);
	};

	 /**
	  * Fire onResetSession event which start 501st PR
	  */
	G3R3.prototype.fireOnResetSession = function() {
		var onResetSession = function(l) {
			if (l && l.onResetSession) {
				l.onResetSession();
			}
		};
		this._fireEvt(onResetSession);
	};

	G3R3.prototype.isListener = function(l) {
		var bListener = false;
		// add other "native" event handler methods here as needed
		if (l && (l.onRuleSatisfied || l.onServiceInvitation ||
				  l.onServiceEngaged || l.onServiceInteracted ||
				  l.onServiceMissed || l.onExposureQualified ||
				  l.onResetSession)) {
			bListener = true;
		}
		return bListener;
	};

    /**
     * Logs message on callback from TagServer with exposure result of request of C2C/Proactive
     * @param exposureData {Object} Json data received from TagServer
     * @param chatType {String} Type of service (C2C or proactive)
     */
    G3R3.prototype.logExposureResult = function(exposureData, chatType) {
        var isReactive = !!(chatType == CHM.CHAT_TYPES.C2C);
        var agID = exposureData.agID ? ", agID=" + exposureData.agID : "";
        var msgData = "siteID=" + exposureData.siteID + ", custID=" + exposureData.customerID + ", pageID=" + exposureData.pageID + ", brID=" + exposureData.brID + agID + ", buID=" + exposureData.buID;
        if (exposureData.result == this.EXPOSURE_QUALIFIED_RESULT.OUT_HOP) {
            isReactive ? log("Callback: MISSED OPP: Outside of business hours for C2C " + msgData) :
                log("No Proactive Launch: Out of hours " + msgData);
        } else if (exposureData.result == this.EXPOSURE_QUALIFIED_RESULT.NO_AVAILABILITY) {
            log("No agents available " + msgData);
        } else if (exposureData.result == this.EXPOSURE_QUALIFIED_RESULT.WILL_OFFER) {
            log("Agents available " + msgData);
        }
    }

	G3R3.prototype.EXPOSURE_QUALIFIED_RESULT = {
		OUT_HOP: "out_hop",
		NO_AVAILABILITY: "no_availability",
		EXISTING_OFFER: "existing_offer",
		WILL_OFFER: "will_offer"
	};

	 /**
	  * Retrieve the global rule attributes of the given rule. The global rule attribute applies
	  * to the rule if the rule.id is one of the global rule attribute's rule-ids or it
	  * it not one of the global rule attributes's exclude rule-ids. If the global rule attribute
	  * rule-ids and excluded rule-ids are not defined, the global rule attributes will be returned
	  * for any given rule.
	  *
	  * @public
	  * @param {Rule} rule that contains the rule id of interest.
	  * @returns {Array} The array of global rule attributes that applies to the rule or null.
      */
    G3R3.prototype.getGlobalRuleAttributes = function (rule) {
	    if (this.globalRAtts && this.globalRAtts.getGlobalRAtts && rule) {
		    var applicable = true;
            if (this.globalRAtts.getRuleIDs && this.globalRAtts.getRuleIDs().length > 0) {
			    applicable = this.globalRAtts.getRuleIDs().contains(rule.id);
			}
			else if (this.globalRAtts.getExcludedRuleIDs) {
				applicable = !this.globalRAtts.getExcludedRuleIDs().contains(rule.id);
			}
			if (applicable) {
				return this.globalRAtts.getGlobalRAtts(rule);
			}
		}
		return null;
	};

/**
 * Trigger representing a listener function name id.
 * @param {String} id The id of the event trigger function.
 * @param {Number} [delayInMS] The optional delayInMS of the event trigger.
 * @oaran {Boolean=} onlyInFocus turn on timer only if window in focus
 * @param onlyInFocus
 */
	function Trigger(id, delayInMS, onlyInFocus){
		this.id = id;
		this.delayInMS = delayInMS?delayInMS:null;
		this.onlyInFocus= onlyInFocus;
	}

	/**
	 * Rule class representing all rule types
	 * @class Represents a rule.
	 * @constructor
	 * @borrows XJA3#absorb as #absorb
	 * @see XJA3
	 * @param {Object} data - Absorbing data:
	 * @param {Boolean} data.active - the rule's activity flag
	 * @param {Number} data.id - the rule's id
	 * @param {String} data.name The rule's name
	 * @param {Array} data.vars array of the rules {@link VER34} objects @see VER34
	 * @param {Function} data.tt1(rule) function returns an array of {@link Trigger} objects
	 * @param {Function} data.cc2(rule, event) function that returns true or false based on a series of internal tests.
	 * @param {Function} data.af3(rule, event) function that, when invoked, will execute the rules actions.
	 * etc., see business-rule.jsp
	 */
	function Rule(data){
		this.constants = {};
		this.evt = {};
		this.absorbFields(data);
	}

	/**
	 * This function sets fields of the Rule object according to parameters passed to constructor.
	 * This code is placed to a separate function to be reused from both Rule and BusinessRule constructors.
	 */
	Rule.prototype.absorbFields = function(data) {
		this.triggerMet=false;
		this.absorb(data);
		this.vtable = {};
		if(data && data.vars){
			for(var i=0; i<data.vars.length; i++){
				this.vars[i] = VER34.getInstanceFromData(data.vars[i]);
				this.vtable[this.vars[i].getName()]=this.vars[i];
			}
		}

		/* invokes the rules actions directly. */
		this.doActions = this.af3;
	};

	MI8.prepare(Rule).im13(MI8.JSON).im13(MI8.XJA3);

	Rule.create = function(data){
		return new Rule(data);
	};

	Rule.prototype.getID = function(){
		return this.id;
	};
	Rule._delayedRules = {};
	Rule._TIDX = 0;

	/**
	 * Sets the timeout in the current window to delay Rule execution.
	 * @param {number} delayInMS amount of time to delay the execution of the rule.
	 * @param {boolean?} onlyInFocus timeout works only in focus
	 */
	Rule.prototype.setTimeout = function (delayInMS, onlyInFocus) {
		var tidx = Rule._TIDX++;
		Rule._delayedRules[tidx] = this;
		this.timeoutStarted = new Date();
		this.tidx = tidx;
		this.win = win;
		this.stopTimeout = function () {
			Rule._stopTimeout(delayInMS, tidx);
		};
		this.resumeTimeout = function () {
			Rule._resumeTimeout(tidx);
		};
		if (onlyInFocus) {
			attachListener(win, "blur", this.stopTimeout, false);
			attachListener(win, "focus", this.resumeTimeout, false);
		}

		return setTimeout(function () {
			Rule._timerCallback(tidx);
		}, delayInMS);
	};

	Rule._stopTimeout = function(delay, tidx) {
		var rule = Rule._delayedRules[tidx];
		if (rule) {
			var tid = rule.tid;
			if (tid) {
				log("Timer stopped for delayed rule ID: " + rule.getID());
				clearTimeout(tid);
				rule.remainingTime = delay - (new Date() - rule.timeoutStarted);
			}
		}
	};

	Rule._resumeTimeout = function(tidx) {
		var rule = Rule._delayedRules[tidx];
		if (rule && rule.remainingTime) {
			log("Remaining time for rule ID: " + rule.getID() + ", time:" + rule.remainingTime);
			rule.tid = window.setTimeout(function(){
				Rule._timerCallback(tidx);
			}, rule.remainingTime)
		}
	};

	/**
	 * Clears timeout and removes event listeners for rule
	 */
	Rule.prototype.clearTimeout = function () {
		if (this.tid) {
			log("Timer resets for rule ID: " + this.getID());
			detachListener(this.win, "blur", this.stopTimeout, false);
			detachListener(this.win, "focus", this.resumeTimeout, false);
			this.remainingTime = 0;
			clearTimeout(this.tid);
		}
	};

	/**
	 * static callback for all rules to invoke with their unique timer index.
	 * @see Rule#sleep
	 */
	Rule._timerCallback = function (tidx) {
		var rule = Rule._popDelayedRule(tidx);
		if (rule){
			rule.timerCallback();
		}
	};

	/**
	 * Pops a delayed rule off the waiting queue
	 * @param {number} tidx index of the rule to be popped of the queue.
	 * @returns {Rule} delayed rule with that idx. null if none found.
	 * @see Rule#sleep
	 */
	Rule._popDelayedRule = function(tidx){
		var rule = Rule._delayedRules[tidx];
		delete Rule._delayedRules[tidx];
		return (rule?rule:null);
	};

	/**
	 * Delays execution of the rule for a specified period of time.
	 * @param {number} delayInMS amount of time to delay the execution of the rule.
	 * @param {boolean?} onlyInFocus timeout works only in focus
	 */
	Rule.prototype.sleep = function(delayInMS, onlyInFocus){
		this.tid = this.setTimeout(delayInMS, onlyInFocus);
	};
	/**
	 * Resets the rule completely.
	 */
	Rule.prototype.reset = function() {
		this.clearTimeout();
		Rule._popDelayedRule(this.tidx);
	};

	Rule.prototype.fireRule = function(evt, delayInMS, onlyInFocus){
		this.evt = evt;
		this.triggerMet = true;
		if(delayInMS>0) {
			this.sleep(delayInMS, onlyInFocus);
		} else{
			this.execute(evt);
		}
	};
	/**
	 * Getter method for the rule name.
	 * @returns {string} The rule's name.
	 */
	Rule.prototype.getName = function(){ return this.name; };
	/**
	 * method that connects the rules triggers to the framework.
	 * @see EMT5#addListener
	 */
	Rule.prototype.init = function(data){
		if(!this.tt1) {
			log("ERROR: Rule+("+this.id+")["+this.name+"] was set without triggers. Rule will not execute.");
			return; // a rule without triggers is a cause for return
		} else if (typeOf(this.tt1) == 'function') {
			// Since V4CHAT-99 triggers are rendered as functions to allow their initialization after Rule creation
			// thus enabling usage of constants and variables defined in the rule to initialize trigger delay.
			this.triggers = this.tt1(this);
		}

		for(var idx=0; idx<this.triggers.length; idx++){
			var trig = this.triggers[idx];
			if(trig.domElementID || trig.domElements){
				initRule[this.getID()] = true;
				this._processDomTrigger(trig, true);
			}
			else if (trig.serviceType) {
				this._processSvcTrigger(trig);
			}
			else {
				this._processStdTrigger(trig);
			}
		}
	};

	/**
	 * Reattaches DOM triggers to maintain persistent listeners for our DOM-triggered rules.
	 * @public
	 */
	Rule.prototype.reattachDomTriggers = function(){
		var triggers = this.tt1(this);
		triggers.forEach(function(trig){
			this._processDomTrigger(trig, false);
		}, this);
	};

	/**
	 * Attaches a standard trigger listener to the rule.
	 * @param {Trigger} trig Trigger instance containing listener spec.
	 * {@link Trigger}
	 */
	Rule.prototype._processStdTrigger = function(trig){
		var atrig = trig;  // do not remove... this is a subtle "closure" issue (js can't "close" on function parameters)
		this[trig.id] = function(evt) {
			this.fireRule(evt, atrig.delayInMS, atrig.onlyInFocus);  // closure on atrig var above
		};
	};

	/**
	 * Attaches a DOM trigger listener to the rule.
	 * @param {Object} trig Trigger instance containing the DOM listener spec instance.
	 * @param {boolean} init true, if business rules initialization.
	 */
    Rule.prototype._processDomTrigger = function(trig, init){
        var elArray = [];
		if (isWebSDK) {
			if (initRule[this.getID()]) {
				FrameBridge.registerDOMEvent(trig, this.getID());
			}
		} else {
			if (trig.domElementID) {
				var el = doc.getElementById(trig.domElementID);
				if (!!el) elArray[0] = el;

			} else if (trig.domElements) {
				for (var idx = 0; idx < trig.domElements.length; idx++) {
					elArray.append(trig.domElements[idx]);
				}
			}
		}


        if(elArray.length > 0) {
            var r = this;
            // Listeners should be attached to elements only after the initialization of business rule
            if (initRule[this.getID()]) {
                for (var i = 0; i < elArray.length; i++) {
                    var el = elArray[i];
                    if (!inu1(el)) {
                        if (inu1(el["tcRuleIDs"])) el["tcRuleIDs"] = [];
                        var ruleIDs = el["tcRuleIDs"];
                        if (init || (!ruleIDs.contains(this.getID()))) {
                            //onMouseOver triggering consist with two parts because it should be fired if mouse was over the element for an interval
                            if(trig.id == "mousehover"){
                                attachListener(
                                    el,
                                    "mouseover",
                                    function (evt) {
                                        var hoverTime = trig.hoverTime ? trig.hoverTime : 15000;
										r.startHover = setTimeout(function () {
											r.fireRule(evt, trig.delayInMS);
										}, hoverTime);
                                    }
                                );
                                attachListener(
                                    el,
                                    "mouseout",
                                    function (evt) {
                                        window.clearTimeout(r.startHover);

                                    }
                                );

                            } else {
                                attachListener(
                                    el,
                                    trig.id,
                                    function (evt) {
                                        r.fireRule(evt, trig.delayInMS, trig.onlyInFocus);
                                    }
                                );
                            }
                            el["tcRuleIDs"].push(this.id);
                        }
                    }
                }
            }
        }
    };
	Rule.prototype.log = function(msg,e){
		log("Rule #"+this.id+"("+this.name+"): "+msg+(e?"-> error="+e:""));
	};

	/**
	 * Attaches a Service trigger listener to the rule.
	 * @param {Object} trig Trigger instance containing the service listener spec instance.
	 */
	Rule.prototype._processSvcTrigger = function(trig){
		var svcTypes = this[trig.id + "_ServiceTypes"];
		var trigServiceType = trig.serviceType;
		if (inu1(svcTypes)) {
			svcTypes = this[trig.id + "_ServiceTypes"] = [trigServiceType];
			this[trig.id] = function(evt) {
				var evtServiceType = evt.chatType;
				if (svcTypes.contains(evtServiceType) || svcTypes.contains("ALL")) {
					this.fireRule(evt, trig.delayInMS, trig.onlyInFocus);
				}
			};

		} else {
			if (!svcTypes.contains(trigServiceType) && !svcTypes.contains("ALL")) {
				svcTypes.push(trigServiceType);
			}
		}

	};

	/**
	 * Determine whether this rule will execute within its valid date range.
	 * @return true if current time is within the rule's dates of operation, false otherwise
	 */
	Rule.prototype.isWithinDateRange = function() {
		var inRange = true;
		if(!!this.dates) {
			var now = new Date();
			var start = !!this.dates.start ? this.dates.start : new Date(0);
			var end = !!this.dates.end ? this.dates.end : new Date(now.getTime() + 1);
			inRange = now.after(start) && now.before(end);
		}
		return inRange;
	};

	/**
	 * @returns {boolean} true if event criteria and conditions for the rule are fulfilled, false otherwise.
	 */
	Rule.prototype.areConditionalsMet = function(){
			return (this.cc2(this,this.evt) && this.triggerMet && this.isWithinDateRange());
	};

	Rule.prototype.timerCallback = function(){
		this.pid = null;
		this.execute();
	};

	Rule.prototype.gc7 = function(cID){
		if(inu1(this.constants[cID])){
			return constants[cID];
		}
		return this.constants[cID];
	};

	/**
	 * executes the actions if conditions are met.
	 */
	Rule.prototype.execute = function(){
		try {
			if(this.active && this.areConditionalsMet()){
				log("Executing: " + this.toString(), LOG_LEVELS.DEBUG);
				this.doActions(this, this.evt);
			} else {
				log("Not executing, does not meet conditions: " + this.toString(), LOG_LEVELS.DEBUG);
			}
		} catch(e) {
			logActionErr(e, this);
		}
	};

	Rule.prototype.assertTrue = function(bfcn, testName, failmsg){
		var msg = "ASSERT: "+this.getName()+" - "+ testName + ": ";
		try{
			var b = bfcn();
			msg += b?"PASSED":("FAILED. "+failmsg);
			if(!b){
				msg = "*** "+msg;
			}
		}catch(err){
			msg += ("FAULT: "+err);
		}
		ROM.send(urls.loggingURL, {level:"info", line: msg});
		log(msg);
	};

	/**
	 * executes the actions if conditions are met.
	 */
	Rule.prototype.getVars = function(){
		return this.vars;
	};

	/**
	 * Returns string representation of this object.
	 */
	Rule.prototype.toString = function(){
		return "Rule " + this.getID() + " \"" + this.name + "\"";
	};

	/**
	 * Determines if a rule is a BusinessRule type or not.
	 * @return {Boolean} always false for Rule type.
	 */
	Rule.prototype.isBR = function(){
		return false;
	};

	/**
	 * Business Rule subclass of rule. Launches chats in addition to
	 * the other business Rule class allows.
	 * @class Represents a business rule.
	 * @extends {Rule}
	 * @borrows {XJA3} as #absorb
	 * @constructor
	 * @param {Object} data
	 * @param {number} data.id - Business rule id
	 * @param {string} data.name - name of the rule
	 * @param {number} data.qt - queuing threshold
	 * @param {Array} data.vars - array of {@link VER34} for this rule.
	 * @param {Function} data.tt1 - function that returns an array of {@link Trigger} objects
	 * @param {Function} data.cc2 - function for the rule conditional
	 * @param {Function} data.af3 - Function that contains all a rules actions ready for invocation.
	 * @param {number} data.businessUnitID - optional business unit id value overriding default value
	 * @param {Array} data.agtAtts - optional array of name-value pairs for the rule's agent attributes
	 * @param {Array} data.ruleAtts - optional array of name-value pairs for the rule's attributes
	 * @param {Date} data.startDate - staring date-time for which this rule is valid
	 * @param {Date} data.endDate - ending date-time for which this rule is valid.
	 * @requires Rule
	 */
	function BusinessRule(data){
		this.constants = {};

		this.absorbFields(data);
		if(!!this.ignoreFunnelLevel){
			this.constants["ifl"] = true;
			/* If the "cfl" conditions are present in the rule, this nullifies them. */
			this.constants["fl"] = Number.NEGATIVE_INFINITY;
		}
		// Per MAINT24-151 specifying funnel-level attribute in business rule is equivalent to
		// declaring rule constant "fl". One caveat is that if the fl is already delcared as a
		// constant in the rule, it will override the funnel-level attribute in the xml
		else if (!inu1(this.funnelLevel)) {
			if(inu1(this.constants["fl"]))
				this.constants["fl"] = this.funnelLevel;
		}
	}

	BusinessRule.prototype = new Rule();
	BusinessRule.prototype.constructor = BusinessRule;
	BusinessRule.create =function(data){
		return new BusinessRule(data);
	};

    MI8.prepare(BusinessRule).im13(MI8.Observable).im13(MI8.RC54);

	/**
	 * Determines if a rule is a BR.
	 * @override
	 * @return {Boolean} always true for BRs
	 */
	BusinessRule.prototype.isBR = function(){ return true; };

	/**
	 * Used for determining additional set of conditionals for whether a rule should be executed
	 *
	 * @see {@link BusinessRule#execute}
	 * @private
	 * @returns {Boolean}	Indicates rule is being blocked
	 */
	BusinessRule.prototype._isBlocked = function() {
		var hasRuleType = !!this.ruleType;

		if (!hasRuleType) {
			return false;
		}

		var ruleIsBlocked = hasRuleType && getBlockedServicesList().contains(this.ruleType);
		var ruleTypeIsPopup = this.ruleType === CHM.CHAT_TYPES.POPUP || this.ruleType === CHM.CHAT_TYPES.POPUP_CALL;
		var ruleFunnelLevel = this.constants["fl"];
		var persistentFunnelLevel = PM.getVar("cfl").z0();

		var isBlocked = ruleIsBlocked || (ruleTypeIsPopup && ruleFunnelLevel > persistentFunnelLevel);

		return isBlocked;
	};

	BusinessRule.prototype.execute = function(){
		try {
			if (!this.active || !this.areConditionalsMet()) {
				log("Not executing, does not meet conditions: " + this.toString(), LOG_LEVELS.DEBUG);
				return;
			}

			if (this._isBlocked()) {
				log("Not executing, rule type blocked: " + this.toString(), LOG_LEVELS.DEBUG);
				return;
			}

			log("Executing: " + this.toString(), LOG_LEVELS.DEBUG);

			BRM.fireRuleSatisfiedEvent(this);

			var incr_exclude = this.getRuleAttributeValue("incr_exclude") === "yes";

			if (!BRM.isControlGroup() || incr_exclude) {
				this.doActions(this, this.evt);
			} else {
				var dataMap = {
					buID: this.getBusinessUnitID(),
					siteID: Inq.getSiteID(),
					brID: this.getID(),
					agentAttributes: MI8.JSON.stringify(this.getAgentAttributes())
				};

				var agentGroupID = this.getAgentGroupID();

				if (agentGroupID) {
					dataMap.agID = agentGroupID;
				}

				this.callRemote(Inq.urls.agentsAvailabilityCheckURL, dataMap);
			}
		} catch(e) {
			logActionErr(e, this);
		}
	};

    /**
     * Used to fire exposureQualified event for control group users
     */
    BusinessRule.prototype.onRemoteCallback = function(jsonData){
        var result = null;
        if(jsonData.inHOP === "true") {
            if(jsonData.availability === "true") {
                result = BRM.EXPOSURE_QUALIFIED_RESULT.WILL_OFFER;
            } else {
                result = BRM.EXPOSURE_QUALIFIED_RESULT.NO_AVAILABILITY;
            }
        } else {
            result = BRM.EXPOSURE_QUALIFIED_RESULT.OUT_HOP;
        }
        try{
            var exposureData = {
                siteID: Inq.getSiteID(),
                customerID: Inq.getCustID(),
                incrementalityID: asi4(),
                sessionID: getSessionID(),
                brID: this.id,
                group: PM.getVar("incGroup").z0(),
                businessUnitID: this.getBusinessUnitID(),
                result: result,
                rule: this
            };
            BRM.fireExposureQualifiedEvent(exposureData);
        } catch(e){
            let12("Error onRemoteCallback for control group customer : " + e);
        }
    };

	/**
	 * Returns string representation of this object.
	 */
	BusinessRule.prototype.toString = function(){
		return "BusinessRule " + this.getID() + " \"" + this.name + "\"";
	};

	/**
	 * Returns business unit id of this business rule if it was defined in the rule xml.
	 * If not defined, return default value.
	 */
	Rule.prototype.getBusinessUnitID = function(){
		var buID;
		if(!inu1(this.bu8fr)) {
			buID = this.bu8fr();
		} else if(!inu1(this.businessUnitID)) {
			buID = this.businessUnitID; // use the rule's bu id
		}
		else {
            buID = getDefaultBusinessUnitID(); // last resort
        }
		log("Rule#getBusinessUnitId(ruleid=" + this.getID() + "): business-unit-id=" + buID, LOG_LEVELS.DEBUG);
		return buID;
	};

	/**
	 * Compares 2 supplied attributes for equality of names. Returns true if names equal, values are NOT compared.
	 * 	Attributes have following format: {name: 'attribute name', value: 'attribute value'}.
	 * @param attr1 1st attribute to compare
	 * @param attr2 2nd attribute to compare
	 */
	BusinessRule.prototype.attrNamesEqual = function(attr1, attr2) {
		return (attr1 && attr2 && attr1.name && attr2.name && (attr1.name == attr2.name));
	};

	BusinessRule.prototype.getAgentAttributes = function() {
		return this.getAAtts ? this.getAAtts() : [];
	};

	BusinessRule.prototype.setAgentAttributes = function(attribs) {
		this.aAtts = attribs;
	};

	/**
	 * Returns true if array of agent attributes already contain attribute with the same name as of provided attribute.
	 * @param attribute in format {name: 'attribute name', value: 'attribute value'}
	 */
	BusinessRule.prototype.containsAgentAttribute = function(attribute) {
		return this.getAgentAttributes().contains(attribute, BusinessRule.prototype.attrNamesEqual);
	};

	/**
	 * Adds rule attribute to the array of agent attributes. If attribute already e9, its value is updated.
	 * @param attribute in format {name: 'attribute name', value: 'attribute value'}
	 */
	BusinessRule.prototype.addAgentAttribute = function(attribute) {
		var attsArray = this.getAgentAttributes();
		var isRemove = attribute.value == '';
		if (isRemove) {
			this.removeAgentAttribute(attribute);
			return;
		}
		if (!this.containsAgentAttribute(attribute)) {
			attsArray.append([attribute]);
		} else {
			for(var idx=0; idx < attsArray.length; idx++) {
				if(this.attrNamesEqual(attsArray[idx], attribute)) {
					attsArray[idx].value = attribute.value;
				}
			}
		}
	};

	BusinessRule.prototype.removeAgentAttribute = function(attribute) {
		var attsArray = this.getAgentAttributes();
		if (this.containsAgentAttribute(attribute)) {
			for(var idx=0; idx < attsArray.length; idx++) {
				if(this.attrNamesEqual(attsArray[idx], attribute)) {
					attsArray.remove(idx);
					break;
				}
			}
		}
	};

	/**
	 * Adds provided attributes to the array of agent attributes. If an attribute already e9, its value is updated.
	 * @param attributes of attribute objects having format {name: 'attribute name', value: 'attribute value'}
	 */
	BusinessRule.prototype.addAgentAttributes = function(attributes) {
		for(var idx=0; idx < attributes.length; idx++) {
			this.addAgentAttribute(attributes[idx]);
		}
	};

    BusinessRule.convertToAttributeString = function(data) {
        if (inu1(data)) {
            return null;
        }

        var out = "";
        for (var index = 0; index < data.length; index++)  {
            if (index > 0) {
                out += ";";
            }
            // Attributes should be already encoded when they passed to c2c\chat requests, they use another methods.
            // See methods: BusinessRule.prototype.getAgentAttributes and BusinessRule.prototype.getAgentAttributesAsString , both(!) of them should return encoded values.
            out += data[index].name  + "," + data[index].value;
        }
        return out;
    }

	/**
	 * Get agent's attributes as string for log like: attrName,attrValue;attrName,attrValue
	 */
	BusinessRule.prototype.getAgentAttributesAsString = function() {
		if (!this.getAgentAttributes) {
			log("Only BusinessRule can have agent attributes.");
			return null;
		}
        return BusinessRule.convertToAttributeString(this.getAgentAttributes());
	};

	/**
	 * Get rule attributes as string for log like: attrName,attrValue;attrName,attrValue
	 */
	BusinessRule.prototype.ra1t = function() {
		if (!this.getRuleAttributes) {
			log("Only BusinessRule can have rule attributes.");
			return null;
		}
        return BusinessRule.convertToAttributeString(this.getRuleAttributes());
	};

	/**
	 * Retrieves the rule's attributes and augment it with the global rule attributes that
	 * are applicable to this rule. The rule attribute value overrides global rule attribute value.
	 * @returns {Array} The array of attributes. e.g. [{name: 'attr1', value: 'val1'}, {name: 'attr2', value: 'val2'}]
	 * @see G3R3.getGlobalRuleAttributes.
     */
	BusinessRule.prototype.getRuleAttributes = function() {
		// Make a copy of the array, we don't want to push the gloablRAtts to this.rAtts.
		var rAtts =  Array.clone(this.getRuleAttributesAsArray());
		var globalRAtts = BRM.getGlobalRuleAttributes(this) || [];
		// Add the globalRulesAttribute only if it the rule does not have the attr already.
		for (var i=0; i < globalRAtts.length; i++) {
			if (!this.hasRuleAttribute(globalRAtts[i])) {
				rAtts.push(globalRAtts[i]);
			}
		}
		return rAtts;
	};

	/**
	 * Log error, it is deprecated.
	 * @deprecated
	 * @param attribs
     */
	BusinessRule.prototype.setRuleAttributes = function(attribs) {
		var msg = "Error: Rule "+this.id+"("+this.name+") calling deprecated BusinessRule.prototype.setRuleAttributes.";
		if (!this.setRuleAttributesErrorLoggedToServer) {
			let12(msg);
			this.setRuleAttributesErrorLoggedToServer = true;
		} else {
			log(msg);
		}
	};

	/**
	 * Returns array of rule attributes in format: [{name: attr1, value: val1},{name: attr2, value: val2s}]
	 * to support global rule attributes functionality
	 */
    BusinessRule.prototype.getRuleAttributesAsArray = function() {
        return this.getRAtts?this.getRAtts():[];
    };

	/**
	 * Returns the value of the given rule attribute
	 * @return {string} value for the given rule attribute, null if none found or attribute does not exist.
	 */
	BusinessRule.prototype.getRuleAttributeValue = function(attName) {
		var rAtt = this.getRuleAttribute(attName);
		return (!!rAtt && !!rAtt.value) ? rAtt.value : null;
	};

	/**
	 * Returns true if array of rule attributes contain the attribute with the same name as of provided attribute.
	 * @param attribute in format {name: 'attribute name', value: 'attribute value'}
	 * @return {Boolean} true if the given attribute by name is in the rule's attributes, false otherwise.
	 */
	BusinessRule.prototype.hasRuleAttribute = function(attribute) {
		return this.getRuleAttributesAsArray() && this.getRuleAttributesAsArray().contains(attribute, BusinessRule.prototype.attrNamesEqual);
	};

	/**
	 * Returns true if array of rule attributes contain or the global rule attributes contain
	 * attribute with the same name as of provided attribute.
	 * @param attribute in format {name: 'attribute name', value: 'attribute value'}
	 * @return {Boolean} true if the given attribute by name is in the rule's attributes or global rule attributes,
	 *         false otherwise.
	 */
	BusinessRule.prototype.containsRuleAttribute = function(attribute) {
		var result = this.hasRuleAttribute(attribute);
		if (!result) {
			var globalRAtts = BRM.getGlobalRuleAttributes(this);
			if (globalRAtts && globalRAtts.length > 0)
			   result = globalRAtts.contains(attribute, BusinessRule.prototype.attrNamesEqual);
		}
		return result;
	};

	/**
	 * Returns the name,value pair that matches the current rule attribute name
	 * @param {string} attName
	 * @return {object} attribute object with name and value. Null if no attribute matches the name.
	 */
	BusinessRule.prototype.getRuleAttribute = function(attName) {
		var rAtts = this.getRuleAttributes();
		for(var ix=0;ix<rAtts.length;ix++){
			if(rAtts[ix].name==attName){
				return rAtts[ix];
			}
		}
		return null;
	};

	BusinessRule.prototype.getPriority = function() {
        return this.priority;
	};

	BusinessRule.prototype.getStartDate = function() {
		var start = null;
		if (this.dates && this.dates.start) {
			start = this.dates.start;
		}
		return start;
	};

	BusinessRule.prototype.getEndDate = function() {
		var end = null;
		if (this.dates && this.dates.end) {
			end = this.dates.end;
		}
		return end;
	};

	/**
	 * Returns language of this business rule if it was defined in the rule xml.
	 * If not defined, returns site default language.
	 */
	BusinessRule.prototype.getLanguage = function(){
		var language;
		if(!inu1(this._getLanguage)){ 
			try{
				language = this._getLanguage(this);
			}catch(e){
				language = getDefaultLanguage( );
				log("Error while getting language from the given Rule: \n" + e + "\n");
			}
		} else {
			language = getDefaultLanguage( );
		}
		return language;
	};

	/**
	 * returns current business rule agent group ID, if it is passed as a JS variable then it is rendered as
     * getAgID function, otherwise as property agID
     * returns default agent group id if there is no override in business rule
     * returns undefined if agent group settings lvl is not used for this site.
	 */
	BusinessRule.prototype.getAgentGroupID = function() {
		var agentGroupID;
        if(!!this.getAgID){
            agentGroupID = this.getAgID();
        } else if(!!this.agID) {
            agentGroupID = this.agID;
        } else {
            agentGroupID = !!getDefaultAgentGroupId() ? getDefaultAgentGroupId() : undefined;
        }
        return agentGroupID;
	};

	/**
	 * Returns name of agent specified in business rule in agent profile
	 * @returns {(String|null)} agent name or null if agent not specified in business rule
	 */
	BusinessRule.prototype.getUniqueAgentName = function () {
		var agentName = null;

		try {
			agentName = this.uniqueAgentName ? this.uniqueAgentName :
				(!!this.getAgentName && !!this.getAgentName()) ? this.getAgentName() : null;
		} catch (e) {
			let12("BusinessRule#Unable to get agent name. An error was made in the configuration of Business Rules.\n" + e, true);
		}

		return agentName;
	};

	/**
	 * Sets name of agent
	 * @param uniqueAgentName {String} agent name
	 */
	BusinessRule.prototype.setUniqueAgentName = function (uniqueAgentName) {
		this.uniqueAgentName = uniqueAgentName;
	};

	/**
	 * Sets public ID of this agent
	 * @param publicAgentId {String} public agent id.
	 */
	BusinessRule.prototype.setPublicAgentId = function (publicAgentId) {
		this.publicAgentId = publicAgentId;
	};
    /**
     * Returns ID of agent specified in business rule in agent profile
     * @return {String} agent ID or null if agent not specified in business rule
     */
    BusinessRule.prototype.getUniqueAgentId = function () {
        return (!!this.getAgentIdRef && !!this.getAgentIdRef()) ? this.getAgentIdRef() : null;
    };

	BusinessRule.prototype.getUniquePublicAgentId = function () {
		return (!!this.getPublicAgentId && !!this.getPublicAgentId()) ? this.getPublicAgentId() : null;
	};

    /**
     * return rule's funnel level value
     * default value is 5
     */
    BusinessRule.prototype.getFunnelLevel = function() {
        return this.funnelLevel;
    };

	/**
	 * Returns parameters for ACIFv3 automatons
	 * Object structure: {id:123, location:"center",context:"ci", datapass(optional):{}};
	 * @return {Array} array of object with automaton parameters or empty array if not provided
	 */
	BusinessRule.prototype.getAutomatonParams = function() {
		return this.a8pm ? this.a8pm() : [];
	};

	BusinessRule.prototype.q6t = function() {
		return this.getRuleQueueThreshold ? this.getRuleQueueThreshold() : null;
	}

/**
 * @description converting the schedule class to a module which return singleTone object which produces schedule object
 * @module Schedule
 * @return {Object}
 */
var Schedule = (function() {

	/**
	 * Create an instance of Schedule object.
	 *
	 * @constructor
	 * @param {String} id identifier of this schedule
	 * @param {Date} periodStart optional date-time value to start this schedule.
	 *    If not specified schedule considered to be started.
	 * @param {Date} periodEnd optional date-time value to end this schedule.
	 *    If not specified schedule will continue forever.
	 * @param {Date} startTime optional value denoting time of the day when this schedule becomes active.
	 * @param {Date} endTime optional value denoting time of the day when this schedule becomes inactive.
	 * @param {Array} days weekly schedule as array of integers from 0 to 6 where 0 denotes Sunday, 6 - Saturday.
	 *    If not specified or empty then all week days are allowed.
	 */

	/**  4new This JSDoc is for the new Schedule
	 * @param {String} id        - identifier of this schedule
	 * @param {Date} periodStart - Start date-time (UTC) of a schedule.
	 *                              If null, schedule considered to be started.
	 * @param {Date} periodEnd   - End date-time (UTC) of a schedule.
	 *                             If null, schedule never finishes.
	 * @param {number} startTime - start time of day in sec.
	 * @param {number} endTime   - end time of day in sec.
	 * @param {Array} days       - weekly schedule as array of integers from 0 to 6
	 *                             where 0 denotes Sunday, 6 - Saturday.
	 *                              If null or undefined, all week days are allowed.
	 * @param {number} timezone  - Indicator of schedule version; new version has it.
	 *                                Timezone in string.
	 *
	 * Javascript Date-Time rules
	 * . Javascript only know local time zone and UTC timezone.
	 * . In human readable time, the rule is; local time + offset = UTC time
	 * . getTime always retuns in UTC
	 */
	function Schedule(id, periodStart, periodEnd, startTime, endTime, days, timezone) {
		this.id = id;
		this.periodStart = periodStart;		// 4new because javascript doesn't know timezone.
		this.periodEnd = periodEnd;
		this.startTime = startTime;			// 4new this should be start hour + tzOffset
		this.endTime = endTime;
		this.days = days;

		this.isScheduleMet = function () { return false; };
		if (typeof timezone == 'undefined') {
			this.isScheduleMet = isScheduleMetCur;
		}
		else {
			this.timezone = timezone;           // 4new because javascript doesn't know timezone.
			initData.scheduleTZs[this.timezone] = 0;
			this.isScheduleMet = isScheduleMetNew;
		}


		/**
		 * Checks if this schedule is met at the specified point in time.
		 * @param {Date} dt point in time to check against this schedule.
		 *    This parameter must be client side time and will be normalized to server time by adding client time lag.
		 * @param {String} clientTimeLag optional parameter - the lag in ms between browser and server time.
		 *  Negative value e.g. -1000ms means browser clock is fast e.g. 10:00:01 compared to server clock 10:00:00.
		 * @param siteTzOfstMillis site timezone offset in miillis, e.g. -480 * 60 * 1000 for PST (GMT-0800).
		 * This value is used to determine current day of week for weekly schedules.
		 * @returns true is this schedule is met at the specified point in time.
		 *
		 * Note that this function is called by isSchMet() function only which always sends siteTzOfstMillis value.
		 * The siteTzOfstMillis value is server's timezone offset which is ajax queried and saved at client.
		 */
		function isScheduleMetCur(dt, clientTimeLag, siteTzOfstMillis) {
			var result = true;

			// removing client time lag - comparing all dates as if they were synchronized using server clock
			if (clientTimeLag) dt.roll(clientTimeLag);

			if (this.periodStart) result = dt.after(this.periodStart) || dt.equals(this.periodStart);
			if (result && this.periodEnd) result = dt.before(this.periodEnd) || dt.equals(this.periodEnd);
			if (result && this.days && !this.days.isEmpty()) {
				// Note that Date.prototype.getTimezoneOffset() returns negative value for positive offset TZ,
				// e.g. -120 for GMT+02:00
				if (!siteTzOfstMillis) siteTzOfstMillis = 0;
				var dtToGetSiteDay = new Date(dt.getTime() + dt.getTimezoneOffset() * 60000 - siteTzOfstMillis);
				var currentDayAtSite = dtToGetSiteDay.getDay();
				result = this.days.contains(currentDayAtSite);
			}

			if (result && (this.startTime || this.endTime)) {

				var DAY_MILLISEC = 24 * 60 * 60 * 1000;
				var msSinceBOD, dtSrvTime = dt.getTime();

				/* Define missing arguments */
				if (!siteTzOfstMillis) {
					siteTzOfstMillis = 0;
				}

				if (!this.startTime) {
					this.startTime = new Date(siteTzOfstMillis);
				}

				if (!this.endTime) {
					this.endTime = new Date(this.startTime.getTime() + DAY_MILLISEC - siteTzOfstMillis);
				}

				/* Remove days from 1970/1/1 and Get hours only. */
				msSinceBOD = dtSrvTime % DAY_MILLISEC;

				/* In UTC time, if endTime is on the following day  */
				if (this.endTime.getTime() > DAY_MILLISEC) {
					/* And the time is between 00:00 to endTime in the next day.  */
					if (msSinceBOD <= (this.endTime.getTime() - DAY_MILLISEC)) {
						msSinceBOD += DAY_MILLISEC;
					}
				}

				if (this.startTime) result = msSinceBOD >= this.startTime.getTime();
				if (result && this.endTime) result = msSinceBOD <= this.endTime.getTime();
			}
			return result;
		}

		/**
		 *    New isScheduleMet function used with schedule.timezone.
		 *
		 */
		function isScheduleMetNew(dt, clientTimeLag) {
			var result = true;

			// removing client time lag - comparing all dates as if they were synchronized using server clock
			if (clientTimeLag) dt.roll(clientTimeLag);

			// Check if the time is in period given
			// The period start/end are in UTC and the checkPeriod will use UTC to compare its period.
			result = Schedule.checkPeriod(dt, this);

			// Check Day
			if (result) {
				// Check if day is given.
				if (this.days && !this.days.isEmpty()) {
					result = Schedule.checkDays(dt, this);
				}
			}

			// Check Time
			if (result) {
				result = Schedule.checkTime(dt, this);
			}

			return result;
		}
	}

	// Member functions.
	/*
	 * Reset schedule date to correct time based on localtime.
	 * 
	 */
	Schedule.prototype.setScheduleDate = function (dt) {
		this.scheduleDate = new Date(dt.getTime());
		this.scheduleDate.roll(Schedule.getOffsetDiff(this.tzOffset, Schedule.getTimezoneOffsetMilli(dt)));
	}


	/*
	 * Return true when schedule has period start and/or end and dt is in given period.
	 */
	Schedule.checkPeriod = function (dat, schedule) {
		var result = true;

		if (schedule.periodStart && typeof schedule.periodStart.getTime == "function") result =
																					   dat.after(schedule.periodStart) || dat.equals(schedule.periodStart);
		if (result && schedule.periodEnd && typeof schedule.periodEnd.getTime == "function") result =
																							 dat.before(schedule.periodEnd) || dat.equals(schedule.periodEnd);

		return result;
	}

	/*
	 * Return true when given date's day is in schedule's day
	 */
	Schedule.checkDays = function (dat, schedule) {
		var result = true;

		// Apply timezone offset
		schedule.setScheduleDate(dat);

		if (schedule.days) {
			var scheduleDateLocalDay = schedule.scheduleDate.getDay();
			result = schedule.days.contains(scheduleDateLocalDay);
		}

		return result;
	}

	/*
	 *  Return true when given date value is in schedule's time range.
	 */
	Schedule.checkTime = function (dat, schedule) {
		var result = true;

		// Apply timezone offset
		schedule.setScheduleDate(dat);

		var scheduleTimeInSec = schedule.scheduleDate.getHours() * 60 * 60 + schedule.scheduleDate.getMinutes() * 60 + schedule.scheduleDate.getSeconds();
		schedule.scheduleTimeInMilSec = scheduleTimeInSec * 1000;

		// Check if time is given time.
		// this startTime is start time of day in seconds
		if (result && schedule.startTime) {
			result = schedule.scheduleTimeInMilSec >= schedule.startTime;
		}

		if (result && schedule.endTime) {
			result = schedule.scheduleTimeInMilSec <= schedule.endTime;
		}
		return result;
	}

	/*
	 *  Return timezone offset in milliseconds.
	 *
	 *  Note: since javascript getTimezoneOffset() function returns difference between UTC and local time. 
	 *  *** which means that the offset is positive if the local timezone is behind UTC and negative if it is ahead.
	 *  *** which means its sign opposit than standard and java notation.
	 *  *** hence this function returns offset with opposit sign.
	 *
	 * @parameter dt  - javascript date object
	 */
	Schedule.getTimezoneOffsetMilli = function (dt) {
		return -dt.getTimezoneOffset() * 60 * 1000;
	}

	/*
	 *  Return the difference of schedule timezone and local (javascript) timezone offset
	 *
	 *  Case 1: schedule +1, client -8 -> + 9
	 *  Case 2: schedule +1, client 0  -> + 1
	 *  Case 3: schedule -1, client -8 -> + 7
	 *  Case 4: schedule -1, client 3 -> -4
	 */
	Schedule.getOffsetDiff = function (offsetSchedule, offsetLocal) {
		return offsetSchedule - offsetLocal;
	}

	return {
		/**
		 * createSchedule function produces Schedule Object
		 * @public
		 * @link Schedule#createSchedule
		 * @param id
		 * @param periodStart
		 * @param periodEnd
		 * @param startTime
		 * @param endTime
		 * @param days
		 * @param timezone
		 * @return {Schedule}
		 */
		createSchedule: function (id, periodStart, periodEnd, startTime, endTime, days, timezone)
		{
			return new Schedule(id, periodStart, periodEnd, startTime, endTime, days, timezone);
		},
		/**
		 *  @public
		 *  @borrows Schedule.checkPeriod as checkPeriod
		 */
		checkPeriod:Schedule.checkPeriod,
		/**
		 *  @public
		 *  @borrows Schedule.checkDays as checkDays
		 */
		checkDays:Schedule.checkDays,
		/**
		 *  @public
		 *  @borrows Schedule.checkTime as checkTime
		 */
		checkTime:Schedule.checkTime,
		/**
		 *  @public
		 *  @borrows Schedule.getTimezoneOffsetMilli as getTimezoneOffsetMilli
		 */
		getTimezoneOffsetMilli:Schedule.getTimezoneOffsetMilli,
		/**
		 *  @public
		 *  @borrows Schedule.getOffsetDiff as getOffsetDiff
		 */
		getOffsetDiff:Schedule.getOffsetDiff
	}
}())

		/**
		 * Represents a C2C image in the DOM
		 * @name C2C
		 * @class
		 * @constructor
		 * @borrows XJA3#absorb as #absorb
		 * @borrows RC54#onRemoteCallback as #onRemoteCallback
		 * @borrows RC54#callRemote as #callRemote
		 */
		function C2C(mgr, rule, chatType, specDataFcn, c2p, adaCompliant, ariaEnhanced, ariaEnhancedChatAvailableMessage, adaAndroidC2cSupportDomains, useNative){
			this._mgr = mgr;
			this._rule = rule;
			this.chatType = chatType;
			this.c2cSpec = MM.mergeC2CSpec(specDataFcn(rule)); // get the c2cSpec WITHOUT chat data
			this.specDataFcn = specDataFcn;
			this.adaCompliant = adaCompliant;
			this.ariaEnhanced = ariaEnhanced;
			this.ariaEnhancedChatAvailableMessage = ariaEnhancedChatAvailableMessage;
			this.adaAndroidC2cSupportDomains = adaAndroidC2cSupportDomains;
			EVM.addListener(this);
			this.idx = C2C.IDX++;
			this.clicked = false;
			this.c2p = c2p;
			this.useNative = useNative;
            this.pollCount = 0;
            this.pollTime = 0;
			this.oldState = null;
			this.newState = null;
			this.parentPositionStyle = null;
			this.positionChanged = false;
			this.listeners = [];
			this.timeout_id = C2C.INITIAL_TIMEOUT_ID;
		}
		MI8.prepare(C2C).im13(MI8.XJA3).im13(MI8.RC54);
		C2C.IDX=0;
		C2C.c2CPageElementIDs =[];
		C2C.prototype.getIdx = function(){
			return this.idx;
		};

		/**
		 * obtains an instance of the base xml chat spec for the c2c.
		 * @throws if rule is undefined for the c2c
		 */
		C2C.prototype.getXmlChatSpec=function(){
			if(inu1(this._rule)){
				throw "C2C not ready: rule is undefined";
			}
			var xmlC2cSpec = this.specDataFcn(this._rule);
			var c2cPlugin = this.getPlugin();

			if(!!xmlC2cSpec.chatSpec){
                if (c2cPlugin) {
                    xmlC2cSpec.chatSpec.pn = c2cPlugin;
                }

				return xmlC2cSpec.chatSpec; // return only the chat spec override portion if it e9.
			}
			// no overrides at the chatSpec level and below... create an xml chatSpec from scratch
			var c2cSpec = MM.mergeC2CSpec(xmlC2cSpec);
			return {id: c2cSpec.chatSpec.id}; //only the chatSpec
		};

		/**
		 * Remote callback from c2c display request. Expects JSON object as callback data for display.
		 */
		C2C.prototype.onRemoteCallback = function(dat){
			/*
			 RTDEV-10619; When chat is closed and requestC2C is sent to tagserver
			  response has an attribute called redisplayed: true.
			  If so, it will be used to set the focus back to C2C button.
			 */
			var setFocus = false;
            if(!!dat.c2cRedisplayed){
                BRM.fireRuleSatisfiedEvent(this.getRule());
				if(dat.c2cRedisplayed && dat.c2cRedisplayed == true) setFocus = true;
            }
			var exposureData = {
				siteID: Inq.getSiteID(),
				pageID: inu1(LDM.getPageID()) ? -1 : LDM.getPageID(),   
				customerID: Inq.getCustID(),
				incrementalityID: asi4(),
				sessionID: getSessionID(),
				brID: this._rule.getID(),
				group: PM.getVar("incGroup").z0(),
				buID: this._rule.getBusinessUnitID(),
				agID: this._rule.getAgentGroupID(),
				result: dat.result,
				rule: this._rule
			};
            if(!this.repolled || (this.repolled && dat.result != this.result)){
                BRM.fireExposureQualifiedEvent(exposureData);
                BRM.logExposureResult(exposureData, CHM.CHAT_TYPES.C2C);
            } else {
                this.skipExposed = true;
            }
			this.absorb(dat);

			if(setFocus === true || typeof this.lastDat === "undefined"
				|| this.lastDat.result !== dat.result || this.lastDat.launchable !== dat.launchable
				|| !this.getDiv() || !this.getDiv().firstChild){
				if(this.isExtC2C || isWebSDK || this.getPlugin()) {
					this.renderC2CbyClient(setFocus);
				} else {
					this.show(setFocus);
				}
			}
			this.checkPollCount();

			if(this.optDataPass && !this.optDataPassListening){
				EVM.addListener({source:this, onAgentAssigned: this.optDataPass});
				this.optDataPassListening = true;
			}
			if(this.serviceMissedEvent) {
				BRM.fireServiceMissedEvent(this._rule, CHM.CHAT_TYPES.C2C);
			}
			this.lastDat = dat;

			// when chat closing, request method called for all c2c from onChatClosed method, so nextRequest method shouldn't be called
			// in other cases nextRequest method should be called, because request method called only for first c2c
			if (!dat.c2cRedisplayed) {
				this._mgr.nextRequest(this);
			}
		};
		/**
		 * Forces a busy agent icon display.
		 * TODO: unit testing
		 */
		C2C.prototype.showAgentsBusyIcon = function(){
			this.showImg(this.busyURL);
		};

		/**
		 * Displays icon.
		 * @param {string} name - name of property (html or image)
		 * @param {boolean} clickable - true: client can click, false:  client can't click
		 */
		C2C.prototype.showIcon = function (name, clickable) {
			if (this.c2cSpec.c2cTheme.renderAsHTML) {
				this.showTextButton(name, clickable);
			} else {
				this.showImg(name, clickable);
			}
			// Fix the C2C location if is it not visible.
			this.fixC2CLocation();

			this.updateContainerStyle();
		};

		/**
		 * Shows a given HTML and displays it as optionally "clickable".
		 *
		 * @param {string} name type of c2c which we need to show
		 * @param {boolean} clickable - true: client can click on html, false:  client can't click on html
		 */
		C2C.prototype.showTextButton = function (name, clickable) {
			var div = this.getDiv();
			if (!div) {
				log("C2C container is missed on the page. Check the markup.");
				return;
			}
			var eventName = (isIE() && getBrowserMajorVer() <= 7) ? 'onmouseup' : 'onclick' ;
			var c2cTheme = this.c2cSpec.c2cTheme[name];

			div.innerHTML = '<div ' + (isIOS()?' tabindex="0"':'')+'>' + c2cTheme + '</div>';

			if (this.ariaEnhanced) {
				var wrapper = document.createElement("div");
				wrapper.setAttribute("aria-live", "polite");
				wrapper.setAttribute("tabindex", "-1");
				wrapper.style.position = "absolute";
				wrapper.style.top = "-9999px";
				wrapper.style.width= "1px";
				wrapper.style.height = "1px";

				var defaultMessage = "Chat available - open chat window by selecting button at end of window.";
				var message = this.ariaEnhancedChatAvailableMessage || defaultMessage;
				var messageElement = document.createElement("p");
				messageElement.innerHTML = message;

				div.appendChild(wrapper);

				/**
				 * Adding a timeout because the screen-reader doesn't register that the aria-live
				 * parent has a new child if they're created at the same time, and will ignore the
				 * child message element. A delay seems to fix the buggy behavior.
				 */
				setTimeout(function () {
					wrapper.appendChild(messageElement);
				}, 200);
			}

			if (clickable){
				if (C2CM.IMAGETYPES.ready === name && this._rule.asyncChat() && this.c2cSpec.dispBadge) {
					this.requestCustomerStatus();
				}
				this.addEventHandlers(div, this.idx, eventName);
			}
		};

		/**
		 * Shows a given image and displays it as optionally "clickable".
		 *
		 * @param img        - String, image property (filed) name. one of 'd', 'b', 'ah', or 'r'.
		 *                     Also check X43.prototype.IMAGETYPES
		 * @param clickable
		 */
		C2C.prototype.showImg = function(img, clickable){
			var div = this.getDiv(), func = null;
			/* If we are using inner iframes, then the div layer will be "decorated" with a function called "setSource" */
			try {func = div["setSource"];}catch(e){func=null};	/* Obtain possible function from inner IFRAME */
			var c2cModel = MM.getC2CSpec(this.c2cSpec.id);

			/* All image alt text's property names are; image property name + 'alt'.
			*          Defined at c2c-theme-model.jsp */
			var altText = this.c2cSpec.c2cTheme[img + 'alt'];
			if(typeof altText === 'undefined' || altText == null || altText === "") {
				altText = this.c2cSpec.altText ? this.c2cSpec.altText : ( c2cModel.altText ? c2cModel.altText : "Click To Chat");
			}
			// INVEST-545: under specific condition, the 'onclick' event is not fired in IE6 and IE7.
			var eventName = isIOS() ? "ontouchstart" : ((isIE() && getBrowserMajorVer() <= 7) ? 'onmouseup' : 'onclick' );
			/* If we are using an inner iframe, then func has the function, otherwise it is null
			 So ... if func is defined (not null or undefined) we want to reference the click event via "top." window */
			var onclicktxt = clickable ? ' alt=\"' + altText + '\" tabindex="0"' : 'alt=\"' + altText + '\"';

			//In Firefox, By default if we don't mention the alt text information for input type image,  it displays 'Submit Query' text.
			//In MAINT25-111 to overcome this issue, i have added the alt attribute to type image tag.
			if (!!func) {/* If the inner IFRAME has established the function, then use it to set image src */
				var domain = div["iframeDomain"];

				onclicktxt = 'top.top.inqFrame.Inq.C2CM.agrty(' + this.idx + ', null, "C2C#showImg"); return false;';
				var mapAttributes = {};
				mapAttributes["style"] = "border-style: none; border-width: 0px;" ;
				mapAttributes["alt"] = altText ;
				mapAttributes["tabindex"] = "0" ;
				if (clickable){
					mapAttributes["style"] = "border-style: none; border-width: 0px; cursor: pointer;" ;
					mapAttributes["onclick"] = onclicktxt ;   //onclick is handled as a function in setSource function
				}

				mapAttributes["src"] = urls.mediaSiteURL + '/images/' + this.c2cSpec.c2cTheme[img];
				mapAttributes["role"] = "button";
				func(mapAttributes, domain);
			}
			else if((this.c2p || this.adaCompliant) && clickable){
				div.innerHTML='<input type="image" role="button" src=\"'+ urls.mediaSiteURL + '/images/' + this.c2cSpec.c2cTheme[img] + '\"' + onclicktxt + (this.adaCompliant?' style="cursor:default" ':'')+'/>';
				if(C2C.DummyC2CBtn.checkCondition(this.adaCompliant, this.adaAndroidC2cSupportDomains)) {
					if(C2C.talkBackDummyC2CBtnAdded == null) {
						C2C.DummyC2CBtn.add(div);
					}
					C2C.DummyC2CBtn.show(div);
				}
				if (clickable) {
					this.addEventHandlers(div, this.idx, eventName);
				}
				/* RTDEV-11235
				 * VoiceOver(VO) on iOS9 doesn't detect dynamic element automatically and need little help
				 * VO behavior can be studied to improve the code
				 */
				if (this.adaCompliant && isIOS9()) {
					window.setTimeout(function () {
						var active = window.parent.document.activeElement;
						div.firstChild.focus(); // Let VO know that C2C is on a page.
						active.focus();
					}, 500);
				}
			}
			else{
				div.innerHTML='<img src=\"'+ urls.mediaSiteURL + '/images/' + this.c2cSpec.c2cTheme[img] + '\"' + onclicktxt + ' style="cursor:default" '+(CHM && CHM.chat && CHM.chat._isVisible?'aria-hidden="true" tabindex="-1"':'')+'/>';
				if (clickable) {
					this.addEventHandlers(div, this.idx, eventName);
				}
				if(C2C.talkBackDummyC2CBtnAdded == true) {
					C2C.DummyC2CBtn.hide(div);
				}
			}
		};

		/**
		 * Add event handlers to "clickable" C2C elements
		 *
		 * @param {Element} div The parent HTML element of the target element to add event on
		 * @param {Number} idx the index of the C2C spec to trigger
		 * @param {string} eventName is the event name to be added
		 */
		C2C.prototype.addEventHandlers = function (div, idx, eventName) {
			var eventHandler = function() {
				C2CM.launchChat(idx);
				return false;
			};
			var mouseoverHandler = function(e) {
				e = e || window.event;
				var targ = e.target || e.srcElement;
				if (targ.nodeType == 3) targ = targ.parentNode; // defeat Safari bug

				var isAnchorTag = targ.tagName.toLowerCase() === "a";

				if (!isAnchorTag) {
					targ.style.cursor = "pointer";
				}
			};
			window.setTimeout(function () {
				var element = div.firstChild;//get the target element
				if (element) {
					element[eventName] = eventHandler;
					element['onmouseover'] = mouseoverHandler;
				}
			}, 300);

		}


		/** showClickToCallHtml - displays the click to call page in the c2c spot
		 *  This called by a rule and only by a rule
		 *
		 *  It's purpose is to replace the C2C image with a web url, mostly for a C2C that can:
		 *  1) show area to put in phone number
		 *  2) have button to push for placing the call request
		 *  JIRA: MAINT24-170
		 *
		 * @param urlHtml is the url path to the html
		 * @return - nothing
		 * TODO: unit testing
		 */
		C2C.prototype.showClickToCallHtml = function(urlHtml){
			var div = this.getDiv();
			var target =  urls.mediaSiteURL + '/images/' + this.c2cSpec.c2cTheme["r"] ;
			if (div!=null && div.firstChild && target == div.firstChild["src"]){
				var frameSource = window.location.protocol + "//" +
								window.location.host +  ((window.location.port=="")?"":":"+window.location.port) +
								inqFrame.Inq.v3framesrc ;

				/** Publish showCallButton, this is analogous to GWT publishing (that's where I got the idea
				 *  We need to make the showCallButton accessible after obfuscation, so we publish it in the FlashPeer area
				 */
				if (inqFrame.Inq.FlashPeer["showCallButton"]==null) {
				inqFrame.Inq.FlashPeer.showCallButton = function(indx, source, left, top, number, show, giveFocus, title){
						(inqFrame.Inq.C2CM).showCallButton(indx, source, left, top, number, show, giveFocus, title);
				};
				}

				/** Pass data to the IFRAME as if this were XFORM */
				var iframeName = encodeURIComponent('{id: "'+ this.idx + '", clientHtml: "'+ frameSource + '"}');
				div.innerHTML=
						'<iframe width="100%" height="100%" ' +
						'name="'+iframeName+'" ' +
						'border="0" ' +
						'allowTransparency="true" ' +						
						'frameborder="0" scrolling="no" ' +
						'src="'+urlHtml+'" ' +
						'></iframe><input type="image" style="display: none;"></input>';
			}
		};

		/** Display the call button, from the IFRAME
		 *  The artwork is placed in exactly the same place as in the iframe
		 *  just placed over it in the client page.
		 *
		 * @param {String} source - the url to the button image
		 * @param {Number} left - the left offset of the button
		 * @param {Number} top - the top offset for the button
		 * @param {String} number - The supplied phone number
		 * @param {Boolean=} showButton - boolean, true: show button, false: hide button
		 * @param {Boolean=} giveFocus - force focus to the button
		 * @param {String=} title - (optional) title (tooltip) for the mouse over
		 * @return {void}
		 * TODO: unit testing
		 */
		C2C.prototype.showCallButton = function(source, left, top, number, showButton, giveFocus, title) {
			var callBtnId = "tcCallButton";

			/* Set default values */
			if (giveFocus==null) giveFocus = true ;
			if (title==null) title = "Call "+number ;
			if (giveFocus==null) giveFocus = false ;
			if (showButton==null) showButton = true ;

			var div = this.getDiv();
			div.style.position = "relative";
			var form = document.createElement("form");

			/**
			 * Test for existance of the input immage, it is there, put in by showClickToCallHtml above
			 */
			var inputImage = null;
			if (inputImage==null&showButton==false) return ;
			var inputImages = div.getElementsByTagName("INPUT");
			if (inputImages!=null && inputImages.length > 0) {
				inputImage = inputImages[0];
			}

			/* set up the call btn and place it in the same place it was in the iframe */
			inputImage.id = callBtnId;
			inputImage.src = source ;
			inputImage.idx = this.idx ;
			inputImage.fone = number ;
			inputImage.title = title ;
			inputImage.style.cssText = "display: "+((showButton)?"":"none")+";position: absolute; left: "+left+"px; top: "+top+"px;";
			inputImage.onClick = inputImage.onclick = function(){
				var indx = this.idx ;
				var fon  = this.fone;
				C2CM.launchChat(indx, fon);
				return false;
				};
			if (giveFocus && showButton)  {
				if (inputImage["focus"]!=null) {
					try { inputImage.focus(); } catch (e){}
				}
			}

		};

		C2C.prototype.setClicked = function(isClicked) {
			this.clicked = isClicked;
			// Remove "resize" listener when C2C is clicked.
			if (!inu1(C2C.VirtualKeyboardOpenCloseHandler)) {
				C2C.VirtualKeyboardOpenCloseHandler.removeListener();
			}
		};

		C2C.prototype.isClicked = function() {
			return this.clicked;
		};

		/**
		 * gets a ref to the DOM instance that acts as a "view" for the this c2c instance model.
		 */
		C2C.prototype.forceGetDiv = function () {
			// if the rule contains the c2c page element ID details, we will give it the first preference
			// otherwise grab it from the c2c specs.
			if(!inu1(this.c2cSpec.div)){
				return this.c2cSpec.div;
			}
			this.pageElementID =  !!this.c2cSpec.peId ?  this.c2cSpec.peId : C2C.c2CPageElementIDs[this.id];
			var divId = this.pageElementID;
			return getParentPageElById(divId, win.document);
		};

		/**
		 * Determines if a div is occupied or not.
		 * @return {Boolean} true if the div e9 and is occupied, false if the div is either null or not occupied.
		 */
		C2C.prototype.isDivOccupied = function(){
			var adiv = this.forceGetDiv();
			if(!adiv){
				return false; // div is not occupied if it does not exist
			}
			return (!!adiv.occupied);
		};

		/**
		 * @return - div if it not occupied or rule the same.
		 */
		C2C.prototype.getDiv = function(){
			if (isWebSDK) {
				return;
			}
			var div = this.forceGetDiv();
			div = (!!div && (!div.occupied || div.ruleID==this._rule.getID()))?div:null;
			try{
				if(div != null && typeof this.c2cSpec.chatSpec.lang != "undefined") {
					div.setAttribute("lang", this.c2cSpec.chatSpec.lang);
				}

				/**
				 * We use the *adaCompliant* flag to to enable accessibility features.
				 * The way we implemented this originally was if adaCompliant was set to true, we
				 * would add the aria-live="polite" attribute to the C2C parent div, and the C2C button
				 * would change its aria-label to make the screen-reader announce when C2C is
				 * available, busy etc...
				 *
				 * We wanted to change this behavior of wrapping the C2C button in an aria-live parent,
				 * because interactive elements (such as C2C button) should not be children of
				 * aria-live parents. We added the *ariaEnhanced* flag so we can implement a different
				 * method of announcing the location of the C2C button on the page when the button
				 * appears.
				 */
				if (this.adaCompliant && !this.ariaEnhanced) {
					div.setAttribute("aria-live","polite");
				}
			} catch (err) { /* All DOM operation should be in try catch block */ }
			return div;
		};

		/**
		 * Clears the DOM DIV's contents completely via innerHTML
		 */
		C2C.prototype.clear = function(){
			var div = this.getDiv();
			if (div) {
				div.occupied = false;
				div.innerHTML="";
			}
		};
		/**
		 * Clears and resets the invoked C2C object completely; allowing it to be occupied by another target.
		 * TODO: unit testing
		 */
		C2C.prototype.reset = function(){
			if (this.isExtC2C && typeof this.specDataFcn().launchJS == "function") {
				/**
				 *  If this is an CIAPI based BR, then allow client to clear the c2c buttons before reiniting
				 */
				this.specDataFcn().launchJS({"c2cIdx": this.idx, "displayState": "reset"});
			}
            this.stopC2CAgentCheckTimer();
			this.clear();
			this.clearListeners();
		};
		/**
		 * Displays a given image and optionally sets it's absolute style.
		 * Fires an event that a C2C was displayed.
		 * @param {boolean} setFocus     - when this is true, C2C button will get focus.
		 */
		C2C.prototype.show = function(setFocus){
            //if reinitChat was called then c2c could be already removed from manager
            if (inu1(C2CM.getC2C(this.idx))) {
                log("No C2C will be shown, possibly reinitChat() was called before");
                return;
            }
			var div = this.getDiv();
			if(!!this.c2cSpec.abs && div){
				div.style.position="absolute";
				div.style.top=this.c2cSpec.abs.y;
				div.style.left=this.c2cSpec.abs.x;
			}
			var image = this.image;

			if (CHM.isChatInProgress() || CM.cleaningDetected) {
				this.launchable = false;
				image = this._mgr.IMAGETYPES.disabled;
			}

			if(!!div){
				div.occupied = true;
				div.ruleID = this._rule.getID();
				div.idx=this.idx;
				this.showIcon(image, this.launchable);
				if(this.newState) {
					this.oldState = this.newState;
				}
				this.newState = C2CM.STATES[image];
				if(this.newState !== this.oldState) {
					C2CM.fireC2CStateChanged({oldState:this.oldState, newState:this.newState, c2c:this, rule:this._rule, data:this.data});
				}
				// fire the c2c displayed and service invitation events only when the c2c is displayed on the client page
				if (this.launchable && !this.skipExposed) {
					C2CM.fireC2CDisplayed({c2c:this, rule:this._rule, data:this.data});
					BRM.fireServiceInvitationEvent(this._rule, CHM.CHAT_TYPES.C2C);
					if (!inu1(C2C.VirtualKeyboardOpenCloseHandler)) {
						C2C.VirtualKeyboardOpenCloseHandler.addListener(this.pageElementID);
					}
				}
                this.skipExposed = false;
				/* RTDEV-11370
						setFocus is true when C2C is shown after a chat is closed
						 lastusedC2CId is defined in memory then the same C2C should gets focus
						 or first C2C gets focus.
						 In case if lastUsedC2CId is null then give priority to btnC2C than html c2c, providedly site has btnC2C
				 */
				if (setFocus === true && ((!X43.lastusedC2CId && X43.c2cBtnId==null && div.idx === 0)
										|| (!X43.lastusedC2CId && X43.c2cBtnId!=null && X43.c2cBtnId == div.idx)
										|| (X43.lastusedC2CId && X43.lastusedC2CId === div.id))
				) {
					var c2cDiv = getParentPageElById(div.id, win.document);
					/*
					 * RTDEV-16596
					 * This ticket specifies that C2C must be in focus on chat closed regardless that the page has to
					 * scroll if C2C is not inside the viewport. In order to avoid conflict with other tickets, we
					 * requires that the rule must have the "ignore-page-scrolling-on-C2C-focus" attribute set to true.
					 */
					var ignoreScrolling = this._rule.ignorePageScrollingOnC2CFocus ? true : false;
					/* On Desktop if C2C is not fixed then it should be visible to set focus on it to prevent page scroll */
					if (isMobileDevice() || (!isMobileDevice() && (c2cDiv.style.position === 'fixed' || ignoreScrolling || isElementInViewport(c2cDiv)))){
						window.setTimeout(function () {
							if (c2cDiv && c2cDiv.firstChild) {
								var c2cChild = C2C.getControlElement(c2cDiv.firstChild);

								if (c2cChild) {
									var c2cChildIsAnchorTag = c2cChild.tagName.toLowerCase() === "a";

									if (!c2cChildIsAnchorTag && !c2cChild.hasAttribute("tabindex")) {
										c2cChild.setAttribute('tabindex', 0);
									}
									c2cChild.focus();
								}
							}
							X43.lastusedC2CId = null;
						}, 300);
					}
				} else if(this.launchable && !this.c2cSpec.c2cTheme.renderAsHTML) {
					X43.c2cBtnId = this.idx;
				}
			}
		};

		C2C.prototype.renderC2CbyClient = function(setFocus) {
			//if reinitChat was called then c2c could be already removed from manager
			if (inu1(C2CM.getC2C(this.idx))) {
				log("No C2C will be shown, possibly reinitChat() was called before");
				return;
			}
			var image = this.image;
			if (CHM.isChatInProgress() || CM.cleaningDetected) {
				this.launchable = false;
				this.image = image = this._mgr.IMAGETYPES.disabled;
			}
			if(this.newState) {
				this.oldState = this.newState;
			}
			this.newState = C2CM.STATES[image];
			if(this.newState !== this.oldState) {
				C2CM.fireC2CStateChanged({oldState:this.oldState, newState:this.newState, c2c:this, rule:this._rule, data:this.data});
			}
			// fire the c2c displayed and service invitation events only when the c2c is displayed on the client page
			if (this.launchable && !this.skipExposed) {
				C2CM.fireC2CDisplayed({c2c:this, rule:this._rule, data:this.data});
				BRM.fireServiceInvitationEvent(this._rule, CHM.CHAT_TYPES.C2C);
			}
			this.skipExposed = false;
			if (isWebSDK || this.getPlugin()) {
				var _this = this;
				var timeoutPer = this.newState !== "chatactive" ? 25 : 100;
				setTimeout(function () {
					C2CM.fireC2CReadyForSDK({c2c: _this, setFocus: setFocus})
				}, timeoutPer);


			} else {
				var lJs = this.specDataFcn().launchJS;
				var param = {
					"c2cIdx": this.idx,
					"displayState": this.newState,
					"ruleID": this._rule.getID(),
					"isAsyncEngagement": this._rule.asyncChat(),
					"launchable":this.launchable
				};
				if (setFocus === true) {
					param["reDisplay"] = true;
				}
				if (this.newState !== "chatactive") {
					lJs && lJs(param);
				}
				else {
					var _this = this;
					setTimeout(function () {
						lJs && lJs(param);
					}, 100);
				}
			}
		};

		/**
		 *  check and increase pollCount if necessary.
		 */
		C2C.prototype.checkPollCount = function(){
			// Only if both check-agent-availability is true and check-agent-availability-interval is set, we will set the agentCheckTimer.
			if (!this.c2cSpec.igaa && !inu1(this.c2cSpec.aaci)) {
				// If neither total-poll-count nor total-time-to-poll is set, we set the default of running the agentCheck 20 times. Feature requested by RTDEV-15353.
				if (inu1(this.c2cSpec.aaciPollCount) && inu1(this.c2cSpec.aaciMaxTime)) {
					this.c2cSpec.aaciPollCount = 20;
					// Do not set this.c2cSpec.aaciMaxTime, runC2CAgentCheckTimer will use default value Number.MAX_VALUE.
				}
				if (this.c2cSpec.aaci > this.c2cSpec.aaciMaxTime) {
					// Warn runC2CAgentCheckTimer will not set agentCheck timer in this condition.
					log("The total-time-to-poll '" + this.c2cSpec.aaciMaxTime + "' " +
						"is configured to be less than the agent-availability-interval '" + this.c2cSpec.aaci +
						"'. The C2C agent check timer will not be set.", LOG_LEVELS.WARN);
				}
				// start timer to do periodic checks of agent availability if poll count does not exceed the value from BR xml.
				this.pollCount++; // The requestC2CImage is called 1 time already. RTDEV-15817
				if (this.pollCount < this.c2cSpec.aaciPollCount || (this.c2cSpec.aaciMaxTime && this.c2cSpec.aaciMaxTime > this.pollTime)) {
					this.runC2CAgentCheckTimer();
				}
			}
		};

        /**
         * Forces disabled icon display.
         */
        C2C.prototype.showDisabledIcon = function() {
            this.launchable = false;
	        if(this.getDiv()) {
		        this.showIcon(this._mgr.IMAGETYPES.disabled, this.launchable);
	        }
        };

        /**
		 * Listener for chat launch event. The C2C is supposed to become unclickable when
		 * in a chat state so the C2C nullifies its link when chat is launched.
		 * TODO: unit testing
		 */
		C2C.prototype.onChatLaunched = function(evt){
			this.showDisabled(evt);
			/**
			 * RTDEV-10193
			 * The follow is to fix the problem found in 15723 which is caused having to zoom factor in
			 * window.top.document.documentElement.style.zoom. To fix this problem, I have to clear the zoom level
			 * when the chat is started and the zoom level will be set again when the chat window is closed.
			 * Please note that this fix works the same as the prod version by scrolling the page to the left so that
			 * C2C is visible instead of zooming the page.
			 * @type {boolean}
			 */
			var isTablet = !inu1(inqFrame.Inq.FlashPeer.getDeviceType) && (inqFrame.Inq.FlashPeer.getDeviceType() === "Tablet");
			var isAndroid = getOSType() === "Android";
			var docElem;
			if (isTablet && isAndroid) {
				docElem = window.top.document.documentElement;
				if (docElem.style.zoom !== "") {
					docElem.style.zoom = null;
				}
			}
		};

		/**
		 * showDisabled
		 * Changes state of C2C icon and fired corresponding event
		 * @param {object} evt
		 */
		C2C.prototype.showDisabled = function(evt) {
			this.stopC2CAgentCheckTimer();
			this.oldState = this.newState;
			this.newState = C2CM.STATES.d;
			this.launchable = false;
			C2CM.fireC2CStateChanged({oldState:this.oldState, newState:this.newState, c2c:this, rule:this._rule, data:this.data});
			if (this.getDiv()) {
				this.showIcon(this._mgr.IMAGETYPES.disabled, this.launchable);
			}
		};

		/**
		 * Listener for chat closed event. The C2C is supposed to become "available" again when
		 * not in a chat state so the C2C reinstates its link when chat is closed.
		 * @param {Object} evt - event on chat closed
		 */
		C2C.prototype.onChatClosed = function (evt) {
			this.absorb(this.specDataFcn());
			this.clear();
			if (evt.evtType === CHM.EVTS.CLOSED) {
				this.C2CRedisplayed = true;
				this.request();
			}
			this.C2CRedisplayed = null;
			this.setClicked(false);
		};

		C2C.prototype.request = function() {
			if(C2CM.isBlocked(this.getChatType())) {
				this.reset();
				return;
			}
			var rule = this.getRule();
			var data = {
				siteID: siteID,
				brID: rule.getID(),
				brn: rule.getName(),
				pageID: LDM.getPageID(),
				chatType: this.chatType,
				priority: rule.getPriority(),
                qt:rule.q6t(),
				buID: rule.getBusinessUnitID(),
                custID: Inq.getCustID(),
                agID: rule.getAgentGroupID()
			};

			if (inu1(data.pageID)) {
				data.pageID = -1;
			}
			if (!inu1(this.c2cSpec.igaa)) {
				data.igaa = this.c2cSpec.igaa; // agent availability override
			}
			if (!inu1(this._rule.getRuleAttributes())) {
				data.rAtts = this._rule.getRuleAttributes();
			}
			if (!inu1(this._rule.getAgentAttributes())) {
				data.aAtts =this._rule.getAgentAttributes();
			}
			if (!!this.c2cSpec.chatSpec && !inu1(this.c2cSpec.chatSpec.ignHOP)) {
				data.ignHOP = this.c2cSpec.chatSpec.ignHOP;
			}
			// MAINT24-208 BR30: do not present further C2Call invitations until the agent closes the call
			if (CHM.isCallServiceType(this.chatType) && CHM.getLastCallID()) {
				data.lastCallId = CHM.getLastCallID();
			}

            if(!!this.C2CRedisplayed){
                data.c2cRedisplayed = this.C2CRedisplayed;
            }

			var sData = MI8.JSON.stringify(data);
			this.callRemote(urls.requestC2CImageURL, {d: sData});
		};

		/**
		 * Sends a request to the tagserver to get count of unread messages
		 */
		C2C.prototype.requestCustomerStatus = function () {
			var rule = this.getRule();
			/**
			 * Passing the responsibility of invoking conversation in play check to SDK, so that Application can display restore button
			 */
			if (typeof NuanIJSFBridge != "undefined") {
				NuanIJSFBridge.checkConversationPlay(getSiteID(), rule.getBusinessUnitID(), rule.getAgentGroupID(), this.getIdx());
			} else if (getIOSNativeSDKInstance()) {
				var data = {};
				data["reqType"] = "checkConversation";
				data["siteID"] = getSiteID();
				data["agID"] = rule.getAgentGroupID();
				data["buID"] = rule.getBusinessUnitID();
				data["idx"] = this.getIdx();
				getIOSNativeSDKInstance().postMessage(JSON.stringify(data));
			} else {
				var data = prepareBaseBodyForAsyncChatDataRequest();
				data.businessUnitID = rule.getBusinessUnitID();
				var agentGroupID = rule.getAgentGroupID();
				if (agentGroupID) {
					data.agentGroupID = agentGroupID;
				}
				ROM.post(urls.requestCustomerStatus, data, null, null, this.customerStatusCallback.bind(this));
			}
		};

		/**
		 * Remote callback from requestCustomerStatus request
		 * @param {Object} response
		 */
		C2C.prototype.customerStatusCallback = function(response) {
			if (response.responseStatus === 200 && response.data) {
				var data = typeof response.data == 'string' ?  JSON.parse(response.data) : response.data;
				this.showUnreadMessageBubble(data);
			}
		};

		/**
		 * Shows bubble with count of unread messages if they exist
		 * @param {Object} data - data from requestCustomerStatus response
		 */
		C2C.prototype.showUnreadMessageBubble = function(data) {
			if (data['pendingMessagesCount'] && data['pendingMessagesCount'] > 0) {
				var div = this.getDiv();
				var c2cBubble = div && div.getElementsByClassName('c2c-bubble')[0];
				if (c2cBubble) {
					c2cBubble.style.display = "block";
					c2cBubble.innerText = data['pendingMessagesCount'];
				}
			}
		};

		C2C.prototype.getID = function() {
			return this.id;
		};

		C2C.prototype.getC2cTheme = function() {
			return this.c2cSpec.c2cTheme;
		};

		C2C.prototype.getChatSpec = function() {
			return this.c2cSpec.chatSpec;
		};

		C2C.prototype.hasAbsolutePosition = function() {
			return !!this.c2cSpec.abs;
		};

		C2C.prototype.getPosition = function() {
			return this.c2cSpec.position;
		};

		C2C.prototype.getRule = function() {
			return this._rule;
		};

		C2C.prototype.getChatType = function() {
			return this.chatType;
		};

		C2C.prototype.getPlugin = function() {
			return this.c2cSpec.plugin;
		};

		/**
		 * Starts a timer that would check agent availability and update C2C image accordingly.
         * If current polling time is greater than max poll time from business rules then timer will not start
		 * In fact when time intervall passes timer invokes usual C2C request sequence:
		 * request()->onRemoteCallback()->show()->runC2CAgentCheckTimer()
		 */
		C2C.prototype.runC2CAgentCheckTimer = function() {
            var maxPollTime = Number.MAX_VALUE;
            if(this.c2cSpec.aaciMaxTime) {
                maxPollTime = this.c2cSpec.aaciMaxTime;
            }
            this.pollTime += this.c2cSpec.aaci;

			if (!this.c2cSpec.igaa && this.c2cSpec.aaci &&
				(this.c2cSpec.aaci > 0 ) && (this.pollTime < maxPollTime)) {
				// Next request() call should be after this.c2cSpec.aaci. Hence cancel current one if any scheduled.
				this.cancelC2CAgentCheckTimer();
                this.repolled = true;
				this.timeout_id = setTimeout(function () {
					C2CM.getC2C(this.getIdx()).request();
				}.bind(this), this.c2cSpec.aaci);
			}
		};

		/**
		 * Stops check agent availability timer.
		 * TODO: unit testing
		 */
		C2C.prototype.stopC2CAgentCheckTimer = function() {
		    this.cancelC2CAgentCheckTimer();
            this.repolled = false;
		};

		/**
		 * Cancel this.request() scheduled.
		 */
		C2C.prototype.cancelC2CAgentCheckTimer = function() {
		    if (this.timeout_id) window.clearTimeout(this.timeout_id);
		};


		/**
		 * Find the path to the c2c plugin which may be found in the chat theme folder.
		 * C2C plugin is a new way of showing c2c which is basically kept in the chat theme folder
		 * @return {string} url
		 */
		C2C.prototype.getPluginPath = function () {
			var spec = this.getChatSpec(), pn = this.getPlugin();
			if (spec && pn) {
				var fn = spec.chatTheme && spec.chatTheme.fn;
				if (fn) {
					return fn.replace(/\.(mxml|zip)$/, "") + "/" + pn + ".js"
				}
			}

		};

		/**
		 * Convert the string of inline styles to the object.
		 * @param {string} styleText
		 * @returns {Object}
		 */
		C2C.prototype.parseStyle = function(styleText) {
			var style = {};
			var styleList = styleText.split(";");
			for (var i = 0, item; i < styleList.length; i++) {
				item = styleList[i].split(":");
				if (!item[0]) continue;
				style[item[0].trim()] = item[1] ? item[1].trim() : "";
			}
			return style;
		};

		/**
		 * Apply the specified style directly to the element.
		 * @param {HTMLElement} element
		 * @param {(string|Object)} style
		 */
		C2C.prototype.applyStyle = function(element, style) {
			/* Collects the new styles and removes value of previous style
			   which has a different displaying when they defined as single or pair, e.g. when 'position: absolute':
			       - when specified only 'left: 10px' then element will be located on the left;
			       - when specified two positions 'left: 10px; right: 10px;'
			         then the element will be extended from left to the right.
			 */
			var stylePositionController = {
				stylesMap: {},
				appliedProperty: [],
				addProperty: function(name) {
					this.appliedProperty.push(name);
				},
				fixKnownStyleIssues: function(element) {
					if (isIE() && getBrowserMajorVer(true) <= 6) { // IE quirks mode
						if (this.stylesMap["position"] == "fixed" && this.appliedProperty.indexOf("position") != -1) {
							/* IE6- is not supported the style property "position" with value "fixed".
							 * see: https://msdn.microsoft.com/en-us/library/ms531140%28v=vs.85%29.aspx
							 */
							element.style["position"] = "absolute";
						}
					}
				},
				clearExcessivePropertyValue: function(element) {
					for (var i = 0; i < this.appliedProperty.length; i++) {
						switch (this.appliedProperty[i]) {
							case "top":
								if (this.appliedProperty.indexOf("bottom") == -1) {
									element.style["bottom"] = "";
								}
								break;
							case "bottom":
								if (this.appliedProperty.indexOf("top") == -1) {
									element.style["top"] = "";
								}
								break;
							case "left":
								if (this.appliedProperty.indexOf("right") == -1) {
									element.style["right"] = "";
								}
								break;
							case "right":
								if (this.appliedProperty.indexOf("left") == -1) {
									element.style["left"] = "";
								}
								break;
						}
					}
				}
			};

			if (typeof style == "string") {
				style = this.parseStyle(style);
			}

			stylePositionController.stylesMap = style;
			for (var prop in style) {
				element.style[prop] = style[prop];
				stylePositionController.addProperty(prop);
			}

			stylePositionController.clearExcessivePropertyValue(element);
			stylePositionController.fixKnownStyleIssues(element);
		};

		/**
		 * Checks the ratio of width to height of the page and screen.
		 * If ratio of the page more than ratio of the screen,
		 * this can lead to the appearance of white space at the bottom of the page in browsers on Android.
		 * @returns {boolean}
		 */
		C2C.prototype.isChangePositionNeeded = function() {
			var docEl = top.document.documentElement;
			var docRatio = docEl.scrollWidth / docEl.scrollHeight;
			var screenRatio = screen.width / screen.height;
			return docRatio > screenRatio;
		};

		/**
		 * Forced roll back of styles onto initial state.
		 * Then update the styles if it needed.
		 */
		C2C.prototype.updateIconPositionToInitial = function() {
			this.applyStyle(this.getDiv(), this.parentPositionStyle);
			this.positionChanged = false;
			this.updateIconPositionAfterDelay();
		};

		/**
		 * Need to delay the updating of position because
		 * the screen and document metrics will be updated after invoking of event listeners.
		 */
		C2C.prototype.updateIconPositionAfterDelay = function() {
			setTimeout(function() {
				this.updateIconPosition();
			}.bind(this), 500);
		};

		/**
		 * Updates the position of C2C container.
		 * Only if this needed.
		 */
		C2C.prototype.updateIconPosition = function() {
			/** @type {HTMLElement} */
			var element = this.getDiv();
			/** @type {Object} */
			var style = copy(this.parentPositionStyle);
			var rollBackChanges = false;
			var styleChanged = false;
			var newTop;

			if (isAndroidWebView()) {
				if (window.top.pageYOffset <= 0) {
					if (isElementOutsideOfViewport(0)) {
						newTop = newTopPosition(0);
						styleChanged = true;
					}
				} else if (this.positionChanged) {
					rollBackChanges = true;
				}
			} else {
				if (this.isChangePositionNeeded()) {
					if (this.positionChanged) {
						if (isElementOutsideOfViewport(0)) {
							newTop = newTopPosition(0);
							styleChanged = true;
						}
					} else if (style["bottom"] != null && style["top"] == null) {
						var bottomPosition = parseInt(style["bottom"]);
						if (!isNaN(bottomPosition)) {
							if (isElementOutsideOfViewport(bottomPosition)) {
								newTop = newTopPosition(bottomPosition);
								styleChanged = true;
							}
						}
					}
				} else if (this.positionChanged) {
					rollBackChanges = true;
				}
			}

			if (styleChanged) {
				style["top"] = newTop + "px";
				delete style["bottom"];

				this.applyStyle(element, style);
				this.positionChanged = true;
			} else if (rollBackChanges) {
				this.applyStyle(element, this.parentPositionStyle);
				this.positionChanged = false;
			}

			function isElementOutsideOfViewport(bottom) {
				// is checked only bottom position
				// Summarized the value of bottom,
				// because element can be visible due to the fact that it has an indent from bottom,
				// but thus it can be located incorrectly,
				// because it should be moved from bottom onto the specified value.
				return element.getBoundingClientRect().bottom + bottom > window.top.document.documentElement.scrollHeight;
			}

			function newTopPosition(bottom) {
				return window.top.document.documentElement.scrollHeight - element.offsetHeight - bottom;
			}

			/* The simple copy of object. This is enough for object containing the list of styles property. */
			function copy(object) {
				var out = {};
				for (var k in object) {
					out[k] = object[k];
				}
				return out;
			}
		};

		/**
		 * Updates the inline styles of C2C container.
		 * This style can be specified through the "data-parent-style" parameter of the C2C icon.
		 *   It should be first child of parent element,
		 *   but in old settings there are the cases when C2C icon is the child of first child.
		 */
		C2C.prototype.updateContainerStyle = function() {
			/** @type {?HTMLElement} */
			var element = this.getDiv();
			/** @type {?HTMLElement} */
			var child = element ? element.children[0] : null;
			if (child) {
				/** @type {?string} */
				var styleText = child.getAttribute("data-parent-style");
				if (child.children[0] && styleText == null || styleText == "") {
					styleText = child.children[0].getAttribute("data-parent-style");
				}

				if (styleText != null && styleText != "") {
					this.parentPositionStyle = this.parseStyle(styleText);
					// initially apply the style
					this.applyStyle(element, this.parentPositionStyle);

					// then correct it, if the position will be out of visual viewport
					if ("Android" == getOSType() // Currently, uses only for Chrome and WebView browsers on Android devices.
						&& styleText.contains("position")
						&& styleText.contains("fixed")
					) {
						if (isAndroidWebView()) {
							if (this.parentPositionStyle["bottom"] != null && this.parentPositionStyle["top"] == null) {
								this.updateIconPosition();
								this.addListener(window.top, "scroll", this.updateIconPositionAfterDelay.bind(this));
							}
							this.addListener(window.top, "orientationchange", this.updateIconPositionToInitial.bind(this));
						} else if (isChrome()) {
							if (this.isChangePositionNeeded()) {
								var img = element.getElementsByTagName("img")[0];
								var inputEl = element.getElementsByTagName("input")[0];
								if (!img && inputEl && inputEl.type == "image") {
									img = inputEl;
								}
								if (img && !img.complete) {
									var onloadListener = img.onload;
									img.onload = function() {
										if (typeof onloadListener == "function") {
											onloadListener();
										}
										this.updateIconPosition();
									}.bind(this);
								} else {
									this.updateIconPosition();
								}
							}
							this.addListener(window.top, "orientationchange", this.updateIconPositionAfterDelay.bind(this));
						}
					}
				}
			}
		};

		/**
		 * RTDEV-10193
		 * BestBrands C2C button is not inside the viewport when loading width "demo.touchcommerce.com" on Android
		 * tablets. It was noticed that when this happens, fixed location is used for C2C button and therefore the
		 * left, width, and right value of C2C will be used to compute the total width of the client. This value is
		 * then compare the window.top.innerWidth to decide whether we need to zoom out so that the C2C button will be
		 * visible.
		 */
		C2C.prototype.fixC2CLocation = function() {
			var isTablet = !inu1(inqFrame.Inq.FlashPeer.getDeviceType) && (inqFrame.Inq.FlashPeer.getDeviceType() === "Tablet");
			var isAndroid = getOSType() === "Android";
			var elem, style,clientWidth, vpWidth;
			var docElem;
			var zoom;
			if (isTablet && isAndroid) {
				elem = this.getDiv();
				style = getComputedStyle(elem);
				/*
				 * Compute the overall width of the client using the position and width of the C2C button.
				 * clientWidth will be NaN is any of the values is not numeric.
				 */
				clientWidth = parseInt(style.left) + parseInt(style.width) + parseInt(style.right);
				vpWidth = window.top.innerWidth;
				if (!isNaN(clientWidth) && clientWidth > vpWidth) {
					docElem = window.top.document.documentElement;
					if (docElem.style.zoom === "") {
						zoom = (vpWidth/clientWidth)*100;
						docElem.style.zoom = zoom+"%"
					}
				}
			}
		};

		/**
		 * Attach event listener onto the target element
		 * and add it to the map for further removing.
		 * @param {HTMLElement|Window} target
		 * @param {string} type
		 * @param {function} listener
		 */
		C2C.prototype.addListener = function(target, type, listener) {
			attachListener(target, type, listener);
			this.listeners.push({
				target: target,
				type: type,
				listener: listener
			})
		};

		/**
		 * We need to remove all attached listeners when we reinitialize the frame of chat.
		 * @see Customer API, reinitChat()
		 */
		C2C.prototype.clearListeners = function() {
			for (var i = this.listeners.length; i--;) {
				detachListener(this.listeners[i].target, this.listeners[i].type, this.listeners[i].listener);
			}
		};

		/**
		 * sets page element container IDs of all c2c specs available for the site.
		 */
		C2C.setC2CPageElementIDs = function(pageElementIDs){
			C2C.c2CPageElementIDs =  pageElementIDs;
		};

		/**
		 * returns child element if it isn't div or style, because element must to have the "click" @event and focus.
		 * @param {HTMLElement} element
		 * @returns {HTMLElement} element
		 */
		C2C.getControlElement = function(element) {
			if(element.tagName.toLowerCase() === "div") {
				return C2C.getControlElement(element.firstElementChild);
			} else {
				if (element.tagName.toLowerCase() === "style") {
					return C2C.getControlElement(element.nextElementSibling);
				}
			}
			return element;
		};

		/* Android 5.2, TalkBack doesn't support fixed position when page is scrolled down.
		 To work around, a dummy restore button is added at the bottom of the page and operated as
		 Restore button.
		 */
		C2C.talkBackDummyC2CBtn = null;
		C2C.talkBackDummyC2CBtnAdded = null;

        /**
         * Hide C2C button when Virtual Keyboard is present and show it when the keyboard is hidden.
         * RTDEV-13453
         * @type {{init: Function}}
         */
		C2C.VirtualKeyboardOpenCloseHandler = {
			addListener: function (c2CElementId) {
				if (!inu1(inqFrame.Inq.FlashPeer.getDeviceType) && (inqFrame.Inq.FlashPeer.getDeviceType() === "Phone") && !inu1(isIOS) && !isIOS()) {
					var keyboardDetectionThreshhold = 200;
					var c2cId = c2CElementId;
					this.c2cHandler = function() {
						var c2cBtn = getParentElByIDTFacade(c2cId);
						if (!inu1(c2cBtn)) {
							// Don't know how to get the exact height between the top of the screen to the
							// top of the web window.  Assuming that when the virtual keyboard is present, the
							// difference in height between to screen.height and the window's innerHeight must be
							// greater than 200 pixels.
							var zoomRatio = window.top.screen.width/window.top.innerWidth;
							var innerHeight = window.top.innerHeight*zoomRatio;
							var screenHeight = window.top.screen.height;
							if ((screenHeight - innerHeight) > keyboardDetectionThreshhold) {  // virtual keyboard present.
								c2cBtn.style.display = "none";
							} else {
								c2cBtn.style.display = "block";
							}
						}
					};
					window.top.addEventListener("resize", this.c2cHandler);
				}
			},
			removeListener: function() {
				if (!inu1(inqFrame.Inq.FlashPeer.getDeviceType) && (inqFrame.Inq.FlashPeer.getDeviceType() === "Phone") && !inu1(isIOS) && !isIOS()) {
					window.top.removeEventListener("resize", this.c2cHandler);
				}
			}
		};

		C2C.DummyC2CBtn = {
			checkCondition: function (adaCompliant, adaAndroidC2cSupportDomains) {
				var result = false;

				try {
					// Accessibility Enabled check || adaAndroidC2cSupportDomains is empty
					if (adaCompliant != true || typeof adaAndroidC2cSupportDomains == "undefined" || adaAndroidC2cSupportDomains.length == 0) {
						return;
					}

					// Android check
					if (window.navigator.userAgent.toLowerCase().indexOf("android") > -1) {
						// Domain check
						var adaAndroidC2cSupportDomainsArr = adaAndroidC2cSupportDomains.split(',');
						for (var i = 0; i < adaAndroidC2cSupportDomainsArr.length && result == false; i++) {
							if (parseUrl(inqFrame.location.href).hostname.toLowerCase() == adaAndroidC2cSupportDomainsArr[i].trim().toLowerCase()) {
								result = true;
								break;
							}
						}
					}
				}
				catch (err) { /* return false */ }

				return result;
			},
			add: function(divC2C) {
				try {
					C2C.talkBackDummyC2CBtn = divC2C.cloneNode(true);

					var divC2CImg = divC2C.getElementsByTagName('input')[0];
					divC2CImg.setAttribute('tabindex', '-1');
					divC2CImg.setAttribute("aria-hidden", "true");

					C2C.talkBackDummyC2CBtn.id = C2C.talkBackDummyC2CBtn.id + '_talkback';
					C2C.talkBackDummyC2CBtn.style.width = "100%";

					var btnDummyHome;
					var footers = getParentElsByTNTFacade('footer');
					if (footers.length > 0) {
						btnDummyHome = footers[0];
					}
					else {
						btnDummyHome = top.document.body;
					}

					btnDummyHome.appendChild(C2C.talkBackDummyC2CBtn);
					C2C.talkBackDummyC2CBtnAdded = true;
				} catch (err) {
					/* DOM exception and Cannot use support dummy Restore button. */
				}
			},
			show: function(divC2C) {
				if(C2C.talkBackDummyC2CBtn != null) {
					try {
						C2C.talkBackDummyC2CBtn.style.display = "block";
						var btnC2CImg = divC2C.getElementsByTagName('input')[0];
						btnC2CImg.setAttribute('tabindex', '-1');
						btnC2CImg.setAttribute("aria-hidden", "true");
					}
					catch (err) { /* DOM exception */ }
				}
			},
			hide: function(divC2C) {
				if(C2C.talkBackDummyC2CBtn != null) {
					try {
						C2C.talkBackDummyC2CBtn.style.display = "none";
						var btnC2CImg = divC2C.getElementsByTagName('input')[0];
						btnC2CImg.setAttribute('tabindex', '0');
						btnC2CImg.removeAttribute("aria-hidden");
					}
					catch (err) { /* DOM exception */ }
				}
			},
			remove: function(divC2C) {
				if (C2C.talkBackDummyC2CBtn != null) {
					try {
						var btnC2CImg = divC2C.getElementsByTagName('input')[0];
						btnC2CImg.setAttribute('tabindex', '0');
						btnC2CImg.removeAttribute("aria-hidden");
						C2C.talkBackDummyC2CBtn.parentNode.removeChild(C2C.talkBackDummyC2CBtn);
						C2C.talkBackDummyC2CBtn = null;
						C2C.talkBackDummyC2CBtnAdded = null;
					}
					catch (err) { /* DOM exception */ }
				}
			}
		};

		C2C.INITIAL_TIMEOUT_ID = -1;

	/**
	 * Chat manager for framework.
	 * @class Singleton chat manager for framework
	 * @constructor
	 * @implements {DataExporter}
	 * @param {String} id The unique framework id for the GR34.
	 * @param data hard data required for construction configuration.
	 * 		currently, this includes the following:
	 * 		* thankYouShown -- image
			* thankYouEnabled -- image
			* displayTYImage -- image
			* c2CToPersistent -- c2c persistent flag
	 *
	 * @borrows XJA3#absorb as #absorb
	 * @borrows Observable#addListeners as #addListeners
	 * @borrows Observable#clearListeners as #clearListeners
	 * @borrows Observable#_fireEvt as #_fireEvt
	 * @borrows Observable#addListener as #addListener
	 * @borrows Observable#isListener as #isListener
	 * @borrows RC54#onRemoteCallback as #onRemoteCallback
	 * @borrows RC54#callRemote as #callRemote
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @borrows Persistable#load as #load
	 * @borrows Persistable#save as #save
	 * @borrows Persistable#getPersistentID as #getPersistentID
	 * @borrows Persistable#agrtyer as #agrtyer
	 * @see RC54
	 * @see Observable
	 * @see XJA3
	 * @see FM2
	 * @see Persistable
	 */
	function GR34(id, data) {
		this._frameworkModule(id);
		this._observable();
		this.pmor = false;
		this.absorb(data);
		this.popoutWindow = null;
		this.persistentWindow = null;		/* The actual window for the persistent chat instance */
		this.chat = null;
		this._init = false ;
		this.chatRequestQ = [];
		this.requestInProgress = false;
		this.hasEngaged = false;
		this.dataLoaded = false;
		this.evtIdx = 0;
		this.lpt = 0;
		this.earlyPopout = null; // Window of the soon-to-be pop-out chat
		this.lastChat = {}; // last chat data (chat of any type including call types)
		/** @deprecated */
		this.lastCallId = 0; // MAINT24-208: id of last call
		this._flashvarFcns = [];
		this._closeRetries = 0;								// Used in
		this.retryTimeout = null;
		this.startDateTimestamp = null;// start time from tagserver
		this.resetChatOnBrowserClose = gc7("RESET_CHAT_ON_BROWSER_CLOSE", false);
		this.onBeforeChatClosedFired = false;
		this.chatClosedFired = false;
		/** @type {boolean} adblock(or similar) browser extension detected to be enabled in client's browser  */
		this.adblockOn = false;
		/** @type {number} counter of chats which duration is less than one minute */
		this.chatLaunchCounter = 0;
		this.chatLaunchTimeoutIncrement = new TimeoutIncrement(this.REFRESH_NEW_EMBEDDED_CHAT_DELAY_INCREMENT, this.MAX_REFRESH_NEW_EMBEDDED_CHAT_DELAY);
	}

	GR34.CHM = null;
	GR34.persistentTarget = "_inqPersistentChat";

	GR34.prototype.getInstance = GR34.getInstance = function(data) {
		if (inu1(GR34.CHM)) {
			GR34.CHM = new GR34("CHM", data);
		}
		return GR34.CHM;
	};

	/**
	 * @inheritDoc
	 */
	GR34.prototype.getData = function(){
		if (isCEAPIPostChatSurveyMode()) {
			// ACIF expects the engagementID when calling window.Inq.getData().CHM.id
			return {id: parent.CEAPI_POST_CHAT_SURVEY_DATA.engagementID};
		}
		if(this.isChatInProgress()){
			return MI8.clonize(this.getChat().getChatData()).clone();
		}
		return null;
	};

	/**
	 * Stops the closing of chat.
	 * It's initiated from the persistent chat window.
	 *
	 * @see GR34#r345jjm
	 */
	GR34.prototype.StopClosingChatFromPersistent = function() {
		if (this.retryTimeout != null) {
			clearTimeout(this.retryTimeout);
			this.retryTimeout = null;
		}
	};

	/**
	 *	Return fingerprint value RTDEV-14696
	 */
	GR34.prototype.getFPSessionID = function() {
		if (this.chat && this.chat.cd) {
			return this.chat.cd.fpID;
		}
	};

	/**
	 * If we're using the Cache Persistent Solution,
	 * then returns protectionId generated on TagServer,
	 * otherwise generates it on client side.
	 *
	 * Client-side generated protectionID is
	 * 32 bits generated using the Web Crypto API,
	 * in case when it isn't supported by the browser,
	 * then protectionID will consists of two parts: browser
	 * fingerprint and 32 bits from standard Math.random().
	 *
	 * @return {string} protectionId
	 */
	GR34.prototype.getProtectionId = function() {
		if (CM47.chatSessionHelper.protectionId) {
			return CM47.chatSessionHelper.protectionId;
		} else {
			/** @type {Crypto} */
			var cryptoObj = window.crypto || window.msCrypto;
			if (cryptoObj && Uint32Array) {
				return String(cryptoObj.getRandomValues(new Uint32Array(1))[0]);
			} else {
				/** @type {number} */
				var browserFingerprint = ((typeof window["FingerprintNuance"] != "undefined")
					? new FingerprintNuance({screen_resolution: true}).get()
					: new Fingerprint({screen_resolution: true}).get()) & 0x555FFFFF;
				/** @type {number} */
				var randomPart = Math.floor(Math.random() * 0xFFF);
				// clearing the least-significant 20 bits
				randomPart = (randomPart << 20) & 0xAAA00000;
				return String(randomPart | browserFingerprint);
			}
		}
	};

	MI8.prepare(GR34).im13(MI8.FM2).im13(MI8.Observable).im13(MI8.XJA3).im13(MI8.Persistable).im13(MI8.RC54);
	GR34.prototype.log = function(msg){
		log("CHM: "+msg);
	};

	/**
	 * Resets chat requests queue. Needed when chat already in progress
	 * @param {Rule=} rule - a rule object containing a rule id and name
	 */
	GR34.prototype.resetChatRequestsQueue = function(rule){
		if (this.chatRequestQ.length === 0){
			this.chatRequestQ.push({rule: rule});
		}
		this.drainRequestQ();
		this.requestInProgress = false;
	};

	/**
	 * Logs exposure qualified for all remaining chat requests in queue.
	 */
	GR34.prototype.drainRequestQ = function(){
		for(var i = 0; i< this.chatRequestQ.length; i++){
			var reqDat = this.chatRequestQ[i];
			var exposureData = {
				siteID: Inq.getSiteID(),
				customerID: Inq.getCustID(),
				incrementalityID: asi4(),
				sessionID: getSessionID(),
				brID: reqDat.rule.id,
				group: PM.getVar("incGroup").z0(),
				businessUnitID: reqDat.rule.getBusinessUnitID(),
				result: "existing_offer",
				rule: reqDat.rule
			};
			BRM.fireExposureQualifiedEvent(exposureData);
		}
		this.chatRequestQ = []; // clear the chat queue
	};

	/**
	 * Request a new chat from the chat mgr
	 * @param rule a rule object containing a rule id and name
	 * @param chatType see GR34.CHAT_TYPES for valid types
	 * @param xmlSpec {Object} this spec may be partially formed, at minimum containing only a specification id.
	 * 		the amount of information contained in a xmlSpec at this point is determined
	 * 		by the business rule that requested this chat. Missing spec data will be filled in
	 * 		by the media mgr if it is not specified in the business rule.
	 * 	item "p" was added to the data object to stop unintended caching of persistent chat
	 * 	... into a latter pop-up chat.
	 * @param {?string} phoneNumber is the phone number for which to automatically perform a click the call.
	 * @param {?boolean} c2cPersistent
	 * @param {?number} idx
	 * @param {?boolean} useNative
	 * @param {?boolean} extChatJS
	 * @param {string} chatLaunchSource - name of the function that called requestChatLaunch
	 */
	GR34.prototype.request = function(rule, chatType, xmlSpec, phoneNumber, c2cPersistent, idx, useNative, extChatJS, chatLaunchSource){
		var dat;
		var stackTrace;
		if(!rule && this.chatRequestQ.length>0){
			dat = this.chatRequestQ.shift();
			rule = dat.rule;
			chatType = dat.chatType;
			xmlSpec = dat.xmlSpec;
			phoneNumber = dat.phoneNumber;
			c2cPersistent = dat.c2cPersistent;
			idx = dat.idx;
			this.log("De-queued data for "+rule);
		}
		if(this.requestInProgress){ // a chat has already been requested... queue up
			this.chatRequestQ.push({
				rule: rule,
				chatType: chatType,
				xmlSpec: xmlSpec,
				phoneNumber: phoneNumber,
				c2cPersistent: c2cPersistent,
				idx: idx
			});
			this.log("CHAT REQUEST ALREADY IN PROGRESS... waiting "+rule.toString());
			return; // request is already in progress... queue up and wait for reply
		}
		this.requestInProgress = true;
		this.log("Requesting chat for rule: "+rule.toString());
		/* Please note: it is important for GR34.prototype.onPageLanding to clear the chat upon detection of off-site timeout
		 * Otherwise the code will fail below:
		 */
		if (custIdRegenerationInProgress) {
			needToLaunchChat = true;
			this.pendingChatLaunchArgs = arguments;
			return;
		}

		var c2cToPersistent = c2cPersistent ? c2cPersistent : isC2cPersistent();
		// create a new data structure for the chat, we will persist the chat
		// data to cookies once we have a chatID from the tagserver (after the request).
		this.chatData = {
			ruleID: rule.getID(),
			chatType: chatType,
			xmlSpec: xmlSpec,
			pn: phoneNumber,
			pC: false,
			ci: {},
			aMsgCnt:0,
			cMsgCnt:0,
			c2cToPersistent: c2cToPersistent,
			buID: -1,
			fpID: this.getProtectionId(),
			launchNative:useNative,
			extChatJS:extChatJS
		};

		if(this.isBlocked(chatType)) { return; }
		this.rule = rule;
		if(!!phoneNumber)
			this.rule["phoneNumber"]=phoneNumber;
		this.xmlSpec = xmlSpec;
		var incGroup = PM.getVar("incGroup").z0();
		this.chatType = chatType;
		this.c2cIdx = idx;
		var data = {
			p: this.isPersistentWindow(),	/* p (for persistent) was added to avoid caching problem */
			siteID: siteID,
			pageID: LDM.getPageID(),
			custID: Inq.getCustID(),
			chatSpec:MM.mergeChatSpec(xmlSpec),
			chatType: chatType,
			pmor: this.pmor,
			rule: {
				id: rule.getID(),
				name: rule.getName(),
				priority: rule.getPriority(),
				qt:rule.q6t(),
				aAtts: rule.getAgentAttributes(),
				ruleAttributes: rule.getRuleAttributes(),
				phoneNumber: phoneNumber,
				buID: rule.getBusinessUnitID(),
				agID: rule.getAgentGroupID(),
				async: rule.asyncChat()
			},
			incAssignmentID: asi4(),
			sessionID: getSessionID(),
			incGroup: incGroup,
			adblockEnabled : this.isAdblockOn()
		};
		if (getPersistCustID()) {
			//need format for logging because server cache has the same format (not JSON)
			data.persistentCustomerID = FP.getPersistentCustomerID();
		}
		if (getUserObject()) {
			data.user_object = getUserObject();
		}
		if (getAuthUser()) {
			data.authenticatedUser = JSON.stringify(getAuthUser());
		}
		// MAINT24-208 BR30: do not present further C2Call invitations until the agent closes the call
		if (this.isCallServiceType(chatType) && this.getLastCallID()) {
			data.lastCallId = this.getLastCallID();
		}
		if(rule.getUniquePublicAgentId()) {
			data.puaid = rule.getUniquePublicAgentId();
		}

		if (!chatLaunchSource) {
			// all stack trace don't needed because it can be too big,
			// let's take the first thousand characters
			stackTrace = new Error().stack.substring(0, 1000);
		}
		data.chatState = {
			chatLaunchSource: chatLaunchSource ? chatLaunchSource : stackTrace,
			isChatInProgress: this.isChatInProgress(),
			isCEAPIPostChatSurveyMode: isCEAPIPostChatSurveyMode(),
			isV3Active: this.isV3Active(),
			isV3Continue: this.isV3Continue()
		};
		this.fireChatRequested(this, data);
		var sData = MI8.JSON.stringify(data);
		try{
			this.callRemote(urls.requestChatLaunchURL, {d: sData});
		} catch(e) {
			this.log(e.message);
		}
	};

	/**
	 * Launches chat with pre-saved parameters
	 */
	GR34.prototype.launchDelayedChat = function () {
		if (this.pendingChatLaunchArgs) {
			this.requestInProgress = false;
			this.request.apply(this, this.pendingChatLaunchArgs);
			this.pendingChatLaunchArgs = null;
		}
	};

	/**
	 * This method should be called only in ceapi native post chat survey mode. The chatID, customerID, agentID, agentGroupID,
	 * are passed down from CEAPI and passed into this method in the npcsData. This method will launch a chat with the given
	 * IDs assigned to it. Upon the chat is launched, the ACIF will launch the survey according to the automatonID in
	 * the given rules's automaton map.
	 *
	 * @param ruleID The "CEAPIPostChatSurvey" ruleID that contains the surveyID in the automaton map.
	 * @param xmlSpec  The chat spec data passed down from the ceapi call.
	 * @param npcsData The chatID, customerID, agentID, agentGroupID, etc passed down from ceapi.
     */
	GR34.prototype.launchChatForNativePostChatSurvey = function (ruleID, xmlSpec, npcsData) {
		try {
			if (!isCEAPIPostChatSurveyMode()) {
				throw "Native Post Chat Survey is not supported in the current inqLaunch mode.";
			}
			this.chatType = "POPUP";
			// For ETL contentSentToCustomer log
			setCustID(npcsData.customerID, false);
			var chatData = {
				id: npcsData.engagementID,
				ruleID: ruleID,
				chatType: "POPUP",
				xmlSpec: xmlSpec,
				pC: false,
				ci: {},
				aid: npcsData.agentID,
				c2cToPersistent: false
			};
			this.chat = Chat.unmarshal(chatData).load();
			this.chat.show();
			this.chat.cd.agtAttrs = attributesStringToMap(npcsData.agentAttributes);
			this.chat.agentID = npcsData.agentID;
		} catch (e) {
			lmt12("Failure to Launch Chat for Post Chat Survey: " + cf21(e), LOG_LEVELS.WARN);
			log("Error parsing Chat Data: \n" + e + "\n" + chatData);
		}
	};

	GR34.prototype.init = function(){
		if (this._init) { return;}
		this.vitalVar = new VER34(this.getID(), {}, resources["vital"]);
		this.stateVar = new VER34(this.getID(), {}, resources["state"]);
		this.sessionVar = new VER34(this.getID(), {}, resources["session"]);
		this.asyncUnauthUserVar = PM.getVar("asyncUnauthUser");
		if (!this.asyncUnauthUserVar) {
			this.asyncUnauthUserVar = new VER34("asyncUnauthUser", 0, resources["session"], "auu");
			PM.addVar(this.asyncUnauthUserVar);
		}
		this.setUpResetChatOnBrowserClose();
		this._init = true;
		return this;
	};

	/**
	 * Creates variable which will be stored in session cookie.
	 * If this variable is absent when resetChatOnBrowserClose or
	 * isAsyncUnauthUser is true it will mean that browser was closed
	 * and session cookies was deleted.
	 */
	GR34.prototype.setUpResetChatOnBrowserClose = function () {
		if (this.resetChatOnBrowserClose || this.isAsyncUnauthUser()) {
			this.cip = PM.getVar("cip");
			if (!this.cip) {
				this.cip = new VER34("cip", null, resources["bses"], "_bses", function (o) {
					return parseFloat(o);
				});
				PM.addVar(this.cip);
			}
		}
	};

	/**
	 * Returns url for communications with ChatRouter
	 * @return {string} - url for the chat router
	 */
	GR34.prototype.getChatRouterURL = function () {
		if (one2ManyChat) {
			return urls.one2ManyVanityDomain;
		} else {
			return initData["connectionHubDomain"] || urls.chatRouterVanityDomain;
		}
	};

	GR34.prototype.getPersistentID = function(){};
	/**
	 * The agrtyer method is invoked by the X4334rtf when all cookie state is available.
	 * The GR34 may load its state at this point.
	 */
	GR34.prototype.agrtyer = function(){
        if(this.dataLoaded || isCEAPIPostChatSurveyMode()) {
			// In ceapi mode, data is only loaded from launchChatForNativePostChatSurvey
            return;
        }
        this.dataLoaded = true;
        this.init();
        this.load();
        this.preloadInqFramework();
		if (!isWebSDK) {
			AL.preload();
		}
        if(this.isPersistentWindow()){
			openerCall("stopClosingChatFromPersistent");
			openerCall("registerPersistentWindowInOpener", [parent], false);
			this.setPersistentWindowActive(true);
        }
		if (gc7(DEFERRED_START_OF_MANAGERS_KEY) && isPersistentChatLaunchingLimited()) {
			this.restoreChat({isChatLaunched: false});
		}
    };

	/**
	 * Update chat data in GR34 from current cookies.
	 * @param {?Object} chatData - this data contains data for the chat.
	 */
	GR34.prototype.updateChatData = function (chatData) {
		if (chatData && Chat.isChatDataValid(chatData)) {
			if (this.chat) {
				this.chat.updateChatData(chatData);
			} else {
				this.chat = Chat.unmarshal(chatData);
			}
		}
	};

	/** GR34.prototype.urtvd3 - fired when the chat-manager detects whether-or-not there is
	   *    a persistent chat.
	   *
	   *  This code allows the persistent chat to "follow" the same protocol and domain as the hosted client page
	   *  When the client page changes, and the protocol/host is different for the persistent chat, then we
	   *  	reissue the "open" request to change the persistent page.
	   *	This does not work in Chrome, and we are OK with that :)
	   *
	   *  @param isPersistent - boolean true/false
	   *  @param protoDomain - String containing the protocol and domain of the persistent chat
	   *  @param transferURL - new URL for the persistent frame
	   *  @param needNewOpener - opener needs to be reestablished
	   */
	GR34.prototype.urtvd3 = function (isPersistent,protoDomain, transferURL, needNewOpener) {
		if (isPersistent) {
			var myProtoDomain = window.location.protocol + "//" + window.location.hostname ;
			if (myProtoDomain != protoDomain) {
				if (Inq.multiHost){
					/* If we have multiple hosts, then fix the pathname to be correct for this new domain */
					var myHash = transferURL.split("#"); 	// make an array of all elements separated by hash
					myHash.shift(); 						// remove protocol://domain/path
					/* Please note: window.location.pathname is the URL of the hosted file for this domain
					 * so just add the hash information on the end and we are good-to-go
					 */
					transferURL = myProtoDomain + window.location.pathname + "#" + myHash.join("#");
				}
				this.againPopoutChat(transferURL,true) ;
			}
			if (needNewOpener && (myProtoDomain == protoDomain)){
				this.againPopoutChat(transferURL,false) ;
			}
		} else {
			this.setPersistentWindowActive(false);
		}
	};

	/**
	 * The onRemoteCallback method is called after the GR34 has made a successful
	 * "requestChatLaunch" call to the remote launch controller. This callback
	 * method will contain all necessary data to actually display/launch a chat.
	 * @param chatData is a JSON object that can contains the following:
	 * 	chatID
	 * 	siteID
	 * 	pmor
	 * 	chatType
	 * 	chatSpec
	 *  custID
	 *  rule
	 *  persistentChat
	 *  relaunch
	 *  err
	 *  dbg
	 */
	GR34.prototype.onRemoteCallback = function(chatData){
		this.requestInProgress = false;
		try {
			this.log("Request callback for rule: "+this.rule.toString());
			/* Sanity Check */
			if (this.isPersistentWindow()) {
				if (!this.getChat().isPersistent()){
					var fault = new Error("chatData incorrect");
					fault.name = "Launch Error";
					fault.funcName = "onRemoteCallback";
					lmt12("Failure to Launch: "+cf21(fault), LOG_LEVELS.INFO );
				}
			}

			var incGroup = PM.getVar("incGroup").z0();
			this.pmor = chatData.pmor;
			this.startDateTimestamp = chatData.startDateTimestamp;
            if (chatData.uniqueAgentName) {
                this.rule.setUniqueAgentName(chatData.uniqueAgentName);
            }
			if (chatData.publicAgentId) {
				this.rule.setPublicAgentId(chatData.publicAgentId);
			}
			if (chatData.customerID && chatData.customerID != Inq.getCustID()) {
				logInfoToTagServer("Changing current customerID to existing in activeChatroom " + chatData.customerID);
				setCustID(chatData.customerID, true);
			}
			if (this.chatType == this.CHAT_TYPES.POPUP
				|| this.chatType == this.CHAT_TYPES.POPUP_CALL
				|| this.chatType == this.CHAT_TYPES.EXTERNAL_POPUP_CHAT
			) {
				var exposureData = {
					siteID: Inq.getSiteID(),
					customerID: Inq.getCustID(),
					incrementalityID: asi4(),
					sessionID: getSessionID(),
					brID: this.rule.id,
                    buID: this.rule.getBusinessUnitID(),
                    agID: this.rule.getAgentGroupID(),
                    pageID: inu1(LDM.getPageID()) ? -1 : LDM.getPageID(),
                    group: incGroup,
					businessUnitID: this.rule.getBusinessUnitID(),
					result: chatData.result,
					rule: this.rule
				};
				BRM.fireExposureQualifiedEvent(exposureData);
                BRM.logExposureResult(exposureData, this.chatType);
			}
			// if we have no chat id, then no chat should be launched
			// return immediately without creating a chat.
			if (inu1(chatData.chatID)) {
				if(chatData.serviceMissedEvent) {
					BRM.fireServiceMissedEvent(this.rule, this.chatData.chatType);
				}
				if (this.chatType == this.CHAT_TYPES.EXTERNAL_CHAT) {
					var cb = C2CM.getC2C(this.c2cIdx).extJSlaunchCb;
					cb && cb({state:"missed"}, chatData);
				} else if(this.chatType == this.CHAT_TYPES.EXTERNAL_POPUP_CHAT) {
					if (isWebSDK) {
						FrameBridge.postMessageToBootStrap("PROACTIVE_CHAT_LAUNCH", {state: "missed"});
					} else {
						fireCustomEvent("externalPopup", {state: "missed"}, this.rule);
					}
				}
				this.save();
				return;
			}
			this.chatData['id'] = chatData.chatID;
            this.chatData['v3TO'] = chatData.v3TO;
            this.chatData['dcTO'] = chatData.dcTO;
			this.chatData['qt'] = chatData.qt;
			if (chatData.reconnect) {
				this.chatData['rec'] = true;
			}
			if (!inu1(chatData.agentID)) {
				// agentID is available under npcs mode, npcs launch needed the aid to be set.
				this.chatData['aid'] = chatData.agentID;
			}
			this.chat = Chat.unmarshal(this.chatData).load();
			var launchTime = new Date();
			if (this.isImagePosition) {
                this.getChatData().getChatSpec().chatTheme.pos = "CENTER";
                this.getChatData().getChatSpec().chatTheme.lx = 0;
                this.getChatData().getChatSpec().chatTheme.ly = 0;
            }

			this.lastChat = {
				id: this.getChatID(),  // chat id
				chatType: this.chat.getChatType(), // chat type
				timestamp : launchTime,
				businessUnitID: this.rule.getBusinessUnitID(),
				brID: this.rule.id,
				agentGroupID: this.rule.getAgentGroupID(),
				agtAttrs: this.chat.agtAttrs
			};

			// MAINT24-208 BR30: do not present further C2Call invitations until the agent closes the call
			if (this.isCallServiceType(this.getChatType())) {
				this.lastCallId = this.getChatID();
			}

			if (this.getChatType() == this.CHAT_TYPES.POPUP) {
				this.lpt = new Date().getTime();
			}
			var iDFV = getInitialDFV();
            if (iDFV) {
				if (isWebSDK) {
					window.Inq.datapass = iDFV.toString();
				} else {
					window.parent.Inq.datapass = iDFV.toString();
				}
            }
            // MAINT27-278 (Create 'engagement.windowDisplayed' event): inHOP value here is used only
			// for windowDisplayed event and don't have to be persisted as part of chat data this.chat.cd
			this.chat.inHOP = chatData.inHOP;
            this.setDisconnectFlag(0);
			this.launchChat(this.chat);
			if (this.getChatType() == this.CHAT_TYPES.MONITOR) {
				this.closeChat();
			}
			this.save();

			// MAINT25-129: chatID=0 in 'conversionFunnel.engaged'
			// Moved firing this event from X43 here to be sure chatid is already available
			if (this.getChatType() == this.CHAT_TYPES.EXTERNAL_CHAT
				|| this.getChatType() == this.CHAT_TYPES.C2C
				|| this.getChatType() == this.CHAT_TYPES.C2CALL
				|| this.getChatType() == this.CHAT_TYPES.C2WEBRTC) {
				BRM.fireServiceEngagedEvent({brID: this.rule.id});
			}
			SVYM.setSurveyShown(0);
		} catch(e) {
			lmt12("Failure to Launch: "+cf21(e), LOG_LEVELS.INFO);
			log("Error parsing Chat Data: \n" + e + "\n" + chatData);
			if (this.earlyPopout) {
				try {
					this.earlyPopout.close();
				} catch(e) {}
			} else if (isWebSDK) {
				FrameBridge.closePeristentWindow(this.c2cIdx);
			}

		} finally {
			/**
			 * if requestChatLaunch request is failed, We should reset the clicked property of c2c So that user can click again 
			 */
			if(!chatData) {
        		C2CM.getC2C(this.c2cIdx).setClicked(false);      
			}
			if (this.chatRequestQ.length > 0) { // send next request
				if (this.isChatInProgress()) {
					this.resetChatRequestsQueue()
				} else {
					var chatLaunchSource = this.getID() + "#onRemoteCallback";
					this.request(null, null, null, null, null, null, null, null, chatLaunchSource);
				}
			}
		}
	};

	/**
	 * Reinitializing chatID for async chat functionality.
	 * <p> For the case when agent leaves chat we need to allow client to continue chatting.
	 * We regenerate chatID but not close chat window (CI) and copy chat data and continue chat.
	 * @param {(string|Object)} response - response from TS with new chat id
	 */
	GR34.prototype.reinitializeChatWithNewId = function (response) {
		var jsonResponse = typeof response == 'string' ? JSON.parse(response) : response;
		var chatId = jsonResponse.data["chatID"];
		this.chat.cd.id = chatId;
		this.chat.setAgentConfig(null, null, null, null);
		this.chat.cd.closed = 0;
		this.chat.cd.rec = false;
		this.lastChat.id = chatId;
		log("Chat ID has been regenerated to " + chatId);
		this.setDisconnectFlag(0);
		var surveyData = SVYM.eventData;
		this.launchChat(this.chat, true, true);
		this.save();
		if (surveyData) {
			SVYM.setEventDataForSurvey(surveyData);
		}
	};

	/**
	 * Sends request to get new chat id
	 */
	GR34.prototype.requestChatId = function() {
		var data = {"siteID":Inq.getSiteID()};
		ROM.post(urls.getNewChatIdUrl, data, null, false, this.reinitializeChatWithNewId.bind(this));
	};

	// TODO: deprecated, looks like that it unused
	GR34.prototype.resetStateAfterPersistentChat = function() {
		if (this.isPersistentChat() && !this.isPersistentChatActive()) {
			this.removeChatInstance();
		}
	};

    /**
     * Sets number cookie to mark if chat was closed by disconnect(1) or normal way(0)
     * @param {Number} value, boolean value as 1 or 0
     * @param {string=} reason - message
     */
    GR34.prototype.setDisconnectFlag = function(value, reason) {
        var disconnectVar = PM.getVar("disconnect");
        if (!disconnectVar) {
            disconnectVar = new VER34("disconnect", 0, resources["state"], "_dcnt", function(o){return parseInt(o);});
            disconnectVar.init();
            disconnectVar.z3(value);
            PM.addVar(disconnectVar);
        } else {
            disconnectVar.z3(value);
        }
        if (value === 1 && !inu1(reason)) {
	        lmt12(plc1(reason), LOG_LEVELS.INFO);
        }
    };


    /**
	 * The onPageLanding event is generated by the LE12. It signifies that the browser
	 * document has changed because a new page has loaded. The chat manager must re-animate
	 * any existing chat at this point.
	 */
	GR34.prototype.onPageLanding = function(evt) {
		if (!this.isChatInProgress()) {
			setCustID(CONVM.getInitialCustomerID(), true);
		}
		this.restoreChat(evt);
	};

	/**
	 * Restores the previous chat or removes the expired instance of the chat.
	 * @param {object} evt - custom event object
	 */
	GR34.prototype.restoreChat = function(evt) {
		try {
		if (evt.isChatLaunched || (!!evt.reinitialized && this.isChatInProgress())) {
			return;
		}
		if (this.isChatClosed()) {
			this.removeChatInstance("Chat already closed");
			if (this.isPersistentChat() || this.isPersistentWindow()) {
				window.parent.close();
			}
			return;
		}
		var chatNotContinueLog = "There is chat interface opened in other tabs, no c2c available or proactive will be displayed ";
		if (this.isPersistentChat() || this.isPersistentWindow()) {
			// Test for persistent chat, if persistent then we are active
			this.testForPersistentChat();
		} else {

			if (typeof NuanIJSFBridge != "undefined") {
				/*
				 * This is will check if the chat is currently in progress
				 * on Native SDK's. if yes then IJSF should consider that
				 * chat is visible.
				 */
				if (NuanIJSFBridge.getChatProgressState()) {
					if(this.chat) {
						this.chat.chatMgr = this;
						this.chat.monitorChatActive();
					} else {
						this.chatType = "POPUP";
						var chatData = {
							chatType: "POPUP",
							pC: false,
							ci: {},
							c2cToPersistent: false
						};
						this.chat = Chat.unmarshal(chatData);
						this.chat.monitorChatActive();
						setTimeout(function(){
							CHM.assignAgent("tmp_agent_name",true,false,{},"","");
						},100);

					}
				} else {
					this.removeChatInstance("Native SDK chat isn't in progress");
				}
			} else if (getIOSNativeSDKInstance()) {
				if (isChatProgressInSDK) {
					if (this.chat) {
						this.chat.chatMgr = this;
						this.chat.monitorChatActive();
					} else {
						this.chatType = "POPUP";
						var chatData = {
							chatType: "POPUP",
							pC: false,
							ci: {},
							c2cToPersistent: false
						};
						this.chat = Chat.unmarshal(chatData);
						this.chat.monitorChatActive();
						setTimeout(function(){
							CHM.assignAgent("tmp_agent_name",true,false,{},"","");
						},100);
					}
				} else {
					this.removeChatInstance("IOS Native SDK chat isn't in progress");
				}

			} else if (this.isV3Continue()) {
				var chatInterfaceData = this.getChatInterfaceData();
				var isEngaged = chatInterfaceData.eng;

				/*
				 * When persistent customer id set if flag secureWithCustToken
				 * is true, it means that id shouldn't be saved to cookies
				 * and it will be only in memory. So if customer reload page
				 * then if setPersistCustID won't be called then we won't have id.
				 * Persistent customer id will be sent in chat.request, and
				 * it should be present in all GET requests to CR, if it is
				 * absent, then CR response will be 401 or 400 from server
				 * and chat will be closed.
				 * If chat wasn't started, it is impossible to check was
				 * persistent customer id changed ot not. So chat should be closed
				 * for avoiding sharing configuration between customers.
				 */
				if (this.getChat().isSecureWithCustToken() && !isEngaged) {
					this.removeChatInstance(
						"Remove chat because secureWithCustToken is true,"
						+ " but chat wasn't engaged before page reload"
					);

					return;
				}

				if ((CM47.chatSessionHelper.isContinueChat === false) /* Cache sholution gets current chat info from Server */
					&& (this.isEngagedChatTimedOut()
						|| this.isNotEngagedChatTimedOut()
						|| this.isResetChatRequiredOnBrowserClose())
				) {
					this.setDisconnectFlag(1, CHM.chatCloseReason.TIMEOUT);
					/*
					 * If we have timed-out, we must clear the Chat Interface
					 * data and the chat this.chat MUST be removed
					 */
					this.removeChatInstance("Chat has timed out");
				} else if (!this.isV3Active() && !this.isPersistentChatActive()) {
					if (v3Lander.isBupMode && inu1(this.getChat().getRule())) {
						// Chat lost it's rule data so we may have wandered off our BU for this chat and BR.
						// we need to call in the rules for that BU before continuing
						v3Lander.loadMbuDataForBU(
							this.getChat().getChatData().buID,
							function (ruleData) {
								CHM.continueChatting(ruleData);
							}
						);
					} else {
						this.continueChatting();
					}
				} else if(getOSType() === "iOS" || getOSType() === "Android") {
					/** This is handle situations where unload event is not fired on ios/Android when user closes the window from multiple window screen.It should be s7 to continue chatting
					 if isV3Active is true ie 1.Only downside with this approach is when the same page is opened in another tab,Chat Launches because of this code. **/
					this.continueChatting();
				} else if (this.isMultiChatSupported() && MM.embeddedTheme.isValid) {
					/** If multi window chat support is on and the page has a valid div for embedded chat, then the chat needs to launch**/
					this.continueChatting();
				} else if (isWebSDK) {
					C2CM.removeListener("onC2CReadyForSDK");
					log(chatNotContinueLog);
				}
			} else if (this.isV3Active()) {
				log(chatNotContinueLog);
			} else {
				/** OK if:
				 *      we are NOT persistent
				 *      we are NOT a continuation
				 *      we have a chat object
				 * Then: we need to delete it because:
				 *      if we are not a continuation and we just landed here, how can we have a chat!
				 * So it is left over from a chat on a previous page like from a chat that has a thank-you image
				 * ... and we transitioned to this page WITHOUT closing the thank-you!
				 *
				 *  JIRA Ticket https://dev.inq.com/jira/browse/MAINT24-254
				 *  Description:  C2C available image becomes unclickable when the customer refreshes or goes to another page without closing TY image
				 */
				this.removeChatInstance("Ended chat was closed");
            }
		}
		} catch (e){
			lmt12("CHM failure on onPageLanding: "+cf21(e), LOG_LEVELS.ERROR);
		}
	};

	/**
	 * Returns 'true' if chat session was timed-out.
	 * If 'true' then chat instance can be removed safely
	 * because in this case we need to start a new chat.
	 * @return {boolean}
	 */
	GR34.prototype.isEngagedChatTimedOut = function() {
		return !!this.getChat() && this.getChat().isTimedOut();
	};

	/**
	 * Returns 'true' if chat session was timed-out, for chats which doesn't
	 * engaged.
	 * If 'true' then chat instance can be removed safely
	 * because in this case we need to start a new chat.
	 *
	 * @return {boolean}
	 */
	GR34.prototype.isNotEngagedChatTimedOut = function() {
		var chatInterfaceData = this.getChatInterfaceData();
		var isEngaged = chatInterfaceData.eng;
		// The "it" cookie updating in SkinControl.InitializeGlue
		var initialTimeOut = chatInterfaceData.it || DEFAULT_INITIAL_TIMEOUT;
		var chatWindowAppeared = chatInterfaceData.cwa;
		var isChatShowTimedOut = (Date.now() - chatWindowAppeared) > initialTimeOut * 1000;
		return isChatShowTimedOut && !isEngaged && !this.isAsyncUnauthUser();
	};

	GR34.prototype.isResetChatRequiredOnBrowserClose = function () {
		return (this.resetChatOnBrowserClose || this.isAsyncUnauthUser())
			&& inu1(this.cip.z0());
	}

	GR34.prototype.start = function(){
		if(this.started) {return;}
		this.started = true;
	};

	/**
	 * The load method is used internally by the GR34 to load its persistent state. This method
	 * should not typically be called by external objects and should be private to the
	 * GR34.
	 */
	GR34.prototype.load = function(){
		var stateData = {};
		var sessionData = {};

		function fixBlockedServicesData() {
			var blocked = {};
			var sessionServices = sessionData["blocked"];
			if(!!sessionServices) {
				for(var service in sessionServices) {
					blocked[service] = sessionServices[service];
				}
			}
			var stateServices = stateData["blocked"];
			if(!!stateServices) {
				for(var service in stateServices) {
					blocked[service] = stateServices[service];
				}
			}
			return blocked;
		}

		this.absorb(this.vitalVar.z0());
		this.absorb(this.stateVar.z0());
		this.absorb(this.sessionVar.z0()); // reconstitute a chat if it e9
		try {
			this.chat = Chat.unmarshal().load();
			if (!inu1(this.chat)) {
				lmt12(
					"Chat instance was restored from cookies " + this.chat,
					LOG_LEVELS.INFO,
					null,
					true
				);
			}
		} catch (e) {
			// We need this in case when we can't create new Chat in order not to use chat which contains in sessionVar
			this.chat = null;
			log(e);
		}
		if(!!this.chat){
			// this saves us a LOT of space on the cookie...
			// we only save the xml "override" objects in the cookie.
			this.rule = this.chat.getRule();
		}
		// fix blocked services
		if (!!this.blocked) {
			stateData = this.stateVar.z0();
			sessionData = this.sessionVar.z0();
			this.blocked = fixBlockedServicesData();
		}
		if (this.getLastChat() && this.getLastChat().svyPrms) {
			MI8.mixAbsorber(this.getLastChat().svyPrms);
		}
		return this;
	};

	/**
	 * The save method is used internally by the GR34 to save its persistent state. This method
	 * should not typically be called by external objects and should be private to the
	 * GR34.
	 *
	 * @param {function=} callback
	 */
	GR34.prototype.save = function (callback) {
		var stateData = {};
		var sessionData = {pmor: this.pmor, cb: this.cb};

		function prepareBlockedServicesData (services) {
			for (var service in services) {
				if (services[service] == 0) {
					if (!sessionData.blocked) {
						sessionData.blocked = {};
					}
					sessionData.blocked[service] = services[service];
				} else if (services[service] == -2) {
					// no persistence... page level blocking
				} else {
					if (!stateData.blocked) {
						stateData.blocked = {};
					}
					stateData.blocked[service] = services[service];
				}
			}
		}

		if (this.chat != null) {
			this.chat.save();
			/*
			Lets get the ruleID and ruleName from their getters in the chat router
			Getting them from the rule can be risky in IE because if the client has been closed,
			then the rules object can cause a fault.
			@see http://dev.inq.com/jira/browse/MAINT22-213
			*/
			sessionData.chat =  {
				id: this.getChatID(),
				ruleID: this.rule ? this.rule.getID() : this.chat.getRuleId(),
				aid: this.chat.getAgentID(), // agentID is necessary "dynamic" data. Not part of any spec or theme
				pC: this.chat.isPersistent()
			};
		}
		var vitalData = {
			lpt: this.lpt,
			lastChat: this.lastChat,
			lastCallId: this.lastCallId
		};
		if (!!this.blocked) {
			prepareBlockedServicesData(this.blocked);
		}

		try {
			this.vitalVar.z3(vitalData);
		} catch (e) {
			log("GR34.save vitalData: " + e, LOG_LEVELS.ERROR);
		}
		try {
			this.stateVar.z3(stateData);
		} catch (e) {
			log("GR34.save stateData: " + e, LOG_LEVELS.ERROR);
		}
		try {
			/*
				Callback can't called few times, so it should be added
				to last resource which will be updated.
			 */
			this.sessionVar.z3(sessionData, callback);
		} catch (e) {
			log("GR34.save sessionData: " + e, LOG_LEVELS.ERROR);
		}
	};

	/**
	 * Determine whether a potential listener should be added to this object's list of
	 * event listeners. To be a GR34 listener, a listener should implement at least one of the following
	 * methods:
	 * 		onChatRequested
	 * 		onChatLaunched
	 * 		onChatClosed
	 *      onChatEngagedEvent
	 * 		onPersistentPush
	 * 		onAgentMsg
	 * 		onCustomerMsg
	 * 	    onAgentDataPass
	 * 	    onReceiveVADataPass
	 * 	    onChatroomReady
	 * 	    onQueueWaitMsg
	 * 		onTranscriptReceived
     *      onFrameworkReady
	 */
	GR34.prototype.isListener = function(l){
        if (l &&
            (l.onChatRequested
                || l.onChatLaunched
                || l.onChatShown
                || l.onChatClosed
                || l.onPersistentPush
                || l.onAgentMsg
                || l.onCustomerMsg
                || l.onAgentAssigned
                || l.onChatEngagedEvent
                || l.onChatEvent
                || l.onBeforeChatClosed
                || l.onAgentDataPass
				|| l.onReceiveVADataPass
				|| l.onChatroomReady
				|| l.onQueueWaitMsg
				|| l.onTranscriptReceived
				|| l.onFrameworkReady
				|| l.onConversationResolved)
		) {
			return true;
		}
		return false;
	};

	GR34.prototype.cloneChatInterfaceData = function(srcobj){
		if(srcobj == null || typeof(srcobj) != 'object')
			return srcobj;
		var newobj = new srcobj.constructor();
		for(var key in srcobj)
			newobj[key] = this.cloneChatInterfaceData(srcobj[key]);
		return newobj;
	};

	GR34.prototype.getChatInterfaceData = function(){
		return !!this.chat?this.chat.getCiData():{};
	};

	GR34.prototype.setChatInterfaceData = function(data){
		if (!this.chat)
			return;
		this.chat.setCiData(data);
		this.save();
	};

	/**
	 * Returns Array of automatons which have already been shown in current chat
	 * @return {Object} Array of automatons, empty array if there is no automatons
	 */
	GR34.prototype.getCiAutomatons = function() {
		var ciData = this.getChatInterfaceData();
		return ciData && ciData.aut ? ciData.aut : {};
	};

	/**
	 * Saves array to Chat Interface data 'aut' property
	 * @param {Object} data array of automaton IDs
	 */
	GR34.prototype.setCiAutomatons = function(data) {
		if (!this.chat) {
			return;
		}
		var ciData = this.chat.getCiData();
		//aut(automatons) is an JS object where properties are entries like: xframeID:{time:<init_time>, dt:<decision_tree_id>}
		ciData.aut = data;
		this.setChatInterfaceData(ciData);
	};

	/**
	 * API: Opens an empty persistent chat to be propagated at chat launch.
	 *   	When a customer clicks .
	 * 		Fires a chat close event on invocation if thank you has not yet been shown.
	 * 		If thankyou has been shown,
	 * 			then the invocation will hide the chat and reset the state of the chat manager for re-chat.
	 * @param cT - contains the chat theme that has the window metrics as follows:
	 * 	cT.px		- offset in the x axis (across) in pixels to put the persistent chat.
	 * 	cT.py		- offset in the y axis (down) in pixels to put the persistent chat..
	 * 	cT.pw		- width in pixels of the persistent chat.
	 * 	cT.ph		- height in pixels of the persistent chat
	 * @return void
	 * @see launch in InqC2CMgr
	 */
	GR34.prototype.wecv56 = function(cT){
		var winTest = null ;
		var url="", target = GR34.persistentTarget;
		var tools = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
					",top=" + cT.py +
					",left=" + cT.px +
					",width=" + cT.pw +
					",height=" + cT.ph +
					",resizable=1" ;
		try {
			winTest = top.open(url, target, tools);
		} catch (e1) {
			winTest = null;
		}

		/* On iPad open() opens a new tab and move focus to the new tab
		 * As the result the opener can not execute callback.
		 */
		try	{
			if ( null != winTest && getOSType() === "iOS" && window.focus )	{
				top.focus();
			}
		} catch (e2) { }

		this.earlyPopout = winTest ; // Window of the soon-to-be pop-out chat
	};

	/**
	 *  engagePersistentChat
	 *  ask persistent chat (via the chat router) whether-or-not it is active
	 *  supply the following information to the chat-router (CR)
	 *  chatID, so CR knows which persistent chat to query
	 *  pd,     protocol and domain of the current client instance
	 *  xfr,    URL where the persistent chat should transfer
	 *
	 *  @param xfr - URL where the persistent chat should transfer
	 *
	 *  called from Inq.CHM.
	 */
	GR34.prototype.engagePersistentChat = function (xfr) {
		var url = this.getChatRouterURL() + urls.isPersistentActive;
		var id = generateRequestId("isPersistentActive");
		var myProtoDomain = window.location.protocol + "//" + window.location.hostname;
		var callback = function(data) {
			if (data.responseStatus !== 200) {
				if (this.getChat() && !this.isAsyncChat()){
					this.removeChatInstance("Persistent chat wasn't found on server");
				}
			} else {
				FP.whenIsPersistent(data);
			}
		}.bind(CHM);

		var postData = {
			"engagementID": this.getChatID(),
			"pd": myProtoDomain,
			"xfr": xfr ? xfr : false,
			"customerID": Inq.getCustID(),
			"siteID": getSiteID()
		};

		ROM.sendToChatrouter(url, postData, id, callback);
	};

	/**
	 *  Gets the current persistent window
	 *  @return {Window} persistent window or null
	 *	Notes: *Different Origin is when the pop-out window's protocol or domain do not match the client window (this window)
	 *			this causes a fault to be thrown when one accesses from client to persistent window.
	 */
	GR34.prototype.__againGetPersistentWindow=function (){

		var winTest = null ;
		/* Special tools string to test if window is available
			The top and left are not in the visible area, so this should fail for non-existent target
			The width and height are zero, so this should fail for non-existent targets
		 */
		var tools = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
					",top="+ "-500" +
					",left=" + "-500" +
					",width="+"0" +
					",height="+"0" +
					"";
		/* Open the window with a blank url to get the window object for the persistent chat
		 * This should return the window by the target specification (argument #2)
		 * Then test for valid window.
		 */
		try {
			winTest = win.open("", GR34.persistentTarget, tools);
			if (winTest != null){
				var loc = "err";	/* Default value of err for case of different origins (see note above)*/
				try {
					loc = winTest.location.href;
				} catch(e) {
					loc = "err";
				}
				/* If this window is different origin then use default value.
				 * If the location is "about:blank" then:
				 *   we have a blank document and not the persistent chat
				 *   we must close the blank document
				 */
				if ("about:blank" == loc || (loc != "err" && (!winTest.document
															|| !winTest.document.body
															|| "" == winTest.document.body.innerHTML))) {
					winTest.close();
					winTest = null;

				}
				if (winTest == top || winTest == self) /* if winTest is the same as this window(self) then not a valid persistent chat */
					return null ; /* IMPORTANT: do not close in this case, because we may close the client (self) */
			}
		} catch(e) {}
		return winTest ;
	};
	/**
	 *   againPopoutChat - popout the chat into an existing popup window
	 *   This is used to:
	 *   1) Move the chat to a new domain
	 *   2) or to reestablish the opener link
	 *
	 *   @param {String} transferURL - new URL to transfer to
	 *   dependent on Inq.v3framesrc - from LandingFramework.js
	 *   references: 	  setPersistentRefresh
	 */
	GR34.prototype.againPopoutChat = function (transferURL) {
		var url, target;
		var port = (window.parent.document.location.port == "") ? "" : (":" + window.parent.document.location.port);
		url = (Inq.v3framesrc.indexOf("/") == 0)
			? window.parent.document.location.protocol + "//" + window.parent.document.location.hostname + port + Inq.v3framesrc
			: Inq.v3framesrc;
		var ix = transferURL.indexOf("#");
		if (ix >= 0) {
			url = transferURL.substr(0, ix);
		} else {
			url = transferURL;
		}

		if ("" == url) {
			log("GR34.prototype.againPopoutChat: ERROR: popup url is empty");
		    return false;
		}

		target = GR34.persistentTarget;
		var tools = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
			",top=" + "-500" +
			",left=" + "-500" +
			",width=" + "0" +
			",height=" + "0";
		/* Get the current persistent chat window
		 * We know we have the persistent chat window because we would not be here if it didn't exist
		 * If we fail to get the persistent chat window, then do not relocate it because it will result
		 * 	in an additional persistent window to pop up :(
		 * This is due to an error in FireFox 3.6.12
		 */
		var winTest = this.__againGetPersistentWindow();
		if (winTest) {
			try {
				winTest = window.parent.open(url, target, tools);
			} catch (e) {
				winTest = Inq.win.open(url, target, tools);
			}

			if (!winTest) {
				log("pop up blocker");
			}

		}

		this.persistentWindow = winTest;

		if (winTest && typeof winTest.focus == "function") {
			winTest.focus();
			return true;
		} else {
			return false;
		}
	};

	/**
	 * Get persistent variable value for "pc" (persistent chat)
	 * @default - true if in persistent chat window, false if not in persistent chat window
	 * @return {boolean} true if pc is set to true, false if set to not true
	 *
	 * @deprecated due to updates in accordance with the ticket RTDEV-15560
	 */
	GR34.prototype.getPersistentChatSetting=function() {
		var pcVar = this.getPCVar("" + this.isPersistentWindow());
		return pcVar.z0() == "true";
	};

	/**
	 * Set persistent variable value for "pc" (persistent chat)
	 * @param {boolean|string} pc - value for persistent chat active
	 *
	 * @deprecated due to updates in accordance with the ticket RTDEV-15560
	 */
	GR34.prototype.setPersistentChatSetting=function(pc) {
		pc = "" + pc;
		var pcVar = this.getPCVar(pc);
		pcVar.z3(pc);
	};

	/**
	 * Returns the instance of variable "pc" (persistent chat) if it is exist
	 * or create a new instance with specified default value and returns it.
	 * @param {boolean|string} pc - default value to create a new variable
	 * @returns {VER34}
	 *
	 * @deprecated due to updates in accordance with the ticket RTDEV-15560
	 */
	GR34.prototype.getPCVar = function(pc){
		var pcVar = PM.getVar("pc");
		if  (inu1(pcVar)) {
			pcVar = new VER34("pc", pc, resources["session"]);
			pcVar.init();
			PM.addVar(pcVar);
		}
		return pcVar;
	};

	GR34.prototype.setPersistentWindowActive = function(status){
		if (!inu1(status)) {
			try {
				if (this.getChat()) {
					this.getChat().setPersistent(status);
				}
				if (this.isPersistentWindow()) {
					// Save the state into persistent storage only in the persistent window context,
					// because we also call this method in the opener context via the 'openerCall',
					// to update the state of chat instance in it.
					this.save();
					openerCall("setPersistentWindowActive", [status], true);
				}
			} catch (e) {
				lmt12("Failure on setPersistentWindowActive: " + cf21(e), LOG_LEVELS.INFO);
			}
		}
	};

	/**
	 *   If the cookie says it is active, beleive it, because the cookie has been corrected at page landing
	 */
	GR34.prototype.isPersistentChatActive = function(){
		return this.isPersistentChat();
	};

	/**
	 * Checks if current chat is persistent
	 * @return {Boolean}
	 */
	GR34.prototype.isPersistentChat = function() {
		return this.getChat() && this.getChat().isPersistent();
	};


	GR34.prototype.r11bv = function() {
		if (isPersistentWindow()) {
			return true;
		}
		var toolsForTest = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
				",top="+ "-500" +
				",left=" + "-500" +
				",width="+"0" +
				",height="+"0" +
				"";
		try {
			if (this.popoutWindow && this.popoutWindow.closed) {
				this.popoutWindow = null;
				return null;
			}
			if (!this.chat.popoutWindow) {
				return null;
			}

			/* If we have the window of the soon-to-be pop-out chat (earlyPopout) ...
			 * Then we don't have an active popout chat, yet
			 */
			if (this.earlyPopout) {
				return null;
			}

			if (isWebSDK) {
				/**
				 * its very unlikely that below test is required for persistent chat in websdk
				 */
				return null;
			}

			var winTest = win.open("", GR34.persistentTarget, toolsForTest);
			if (winTest != null) {
				if ("about:blank" ==  winTest.location.href || !winTest.document || !winTest.document.body || "" === winTest.document.body.innerHTML) {
					winTest.close();
					winTest = null;
				}
				if (winTest == top || winTest == self) {
					winTest = null;
				}
			}
			this.popoutWindow = winTest;
		} catch (e) {
			winTest = null; // there used to be a string called "something" here.
			//winTest should be returning null or else the non popup chat will show in the check for a persistent window.
		}
		return winTest;
	};

	/**
	 * testForPersistentChat - establish whether-or-not persistent chat is active
	 * if not in persistent window (in client window) and the PM says that we are in persistent
	 * then ask the chat-router to determine whether persistent is active.
	 * otherwise see if any other chat is active
	 */
	GR34.prototype.testForPersistentChat = function() {
		if (this.isPersistentWindow()) {
			this.testForContinueChatting();
			var isPersistentInitialization = false;
			if(FP.isInitializationRequired() == true) {
				isPersistentInitialization = true;
				FP.resetInitializationFlag();
			}
			if(isPersistentInitialization) {
				this.chat.transitionMessage(this.PERSISTENT.PERSISTENT_COMPLETE);
			}
		} else {
			if (this.isPersistentChat()
				&& !this.isEngagedChatTimedOut()
				&& this.isChatInProgress()
				&& !this.isResetChatRequiredOnBrowserClose()
			) {
				this.engagePersistentChat(false);
			} else {
				/* If:
				 *    we are NOT in persistent window
				 *    we are NOT a continuation
				 *    we have a chat object
				 * Then: we need to delete it because such situation occurs
				 *       when the persistent chat was closed without 'opener' window
				 */
				this.removeChatInstance("Persistent chat was closed");
			}
		}
	};

	GR34.prototype.testForContinueChatting = function(){
		/* We need to continue, we should do it in persistent window */
		if (this.isV3Continue()) {
			this.continueChatting();
		} else {
			/* If we are here, then we have a click to persistent chat
			 * We must make sure that we have a chat constructed so we can
			 * continue chatting */
			var chat = this.getChat();
			if (!chat) {
				lmt12("Failure to Launch: persistent chat, missing Chat Object", LOG_LEVELS.INFO, function(){
					window.parent.close();
				}, true);
			} else {
				if (chat.isClosed()) {
					this.closeChat();
					// need to close persistent window by oneself
					window.parent.close();
				} else {
					/* NOTICE:
					 * We know that cd of the Chat object is clonable
					 *   but we CANNOT use cd.clone() !!!
					 *   Why? Because the cd is in the client space and therefor the clone is in client space
					 *   This results in a new cd that is in client space, we MUST have it in persistent window space,
					 *     So we will call JSON.clone to perform this in OUR persistent window space to avoid memory problems.
					 */
					var cd = MI8.JSON.clone(chat.cd); // Use new function, clone instead of the clonized function in cd, this is because if the clonized function is used, the memory is still in client window
					this.chat = Chat.unmarshal(cd).load();
					this.chat.show();
				}
			}
		}
	};

	GR34.prototype.continueChatting = function (optRuleData) {
		if (!inu1(optRuleData)){
			for (var idx = 0; idx < optRuleData.rules.length; idx++) {
				var rule = optRuleData.rules[idx];
				if (rule.getID() == this.getLastChat().brID) {
					this.getChat().rule = rule;
					break;
				}
			}
			if (inu1(this.getChat().getRule())) {
				let12("Rule for BU not found. Chat lost.", true);
				throw "Rule for BU not found. Chat lost.";
			}
		}
		this.chat.chatMgr = this;
		this.chat.show();
	};

	/**
	 * Sends exit chat message to the chat router via RM91.
	 * In case when chat id is zero then don't need send any messages,
	 * in this case chat is not present.
	 * @param {string=} chatID - chat id
	 */
	GR34.prototype.nnm89 = function(chatID){
		if (inu1(chatID)) {
			chatID = this.getChatID();
		}
		if (chatID !== "0") {
			var url = this.getChatRouterURL() + urls.exitChatURL;
			var data = {
				"engagementID": chatID,
				"customerID": Inq.getCustID()
			};

			var id = generateRequestId("exitChat");
			ROM.sendToChatrouter(url, data, id, SVYM.fireNativeSurveyLaunchEvent);
		}
	};

	/**
	 * Pass data to the chat Agent as a name/value pair, to appear in the Agent Interface.
	 * This data will NOT appear in the transcript visible to the customer.
	 * Used for paymetric functionality
	 * @see https://jira.touchcommerce.com/browse/RTDEV-8041
	 * @param name Should be free of spaces for best formatting in AI.
	 * @param value The value to display to the chat Agent.
	 */
	GR34.prototype.passNamedDataToAgent = function(name, value) {
		var data = MI8.unmixMutatable(MI8.mixMutatable(MI8.mixAbsorber(MI8.mixMutatable()).absorb(isWebSDK? inqData: s7('inqData'))).set("agentID",this.getAgentID()).set("engagementID",this.getChatID()).set(name, value));
		ROM.sendDataToAgent(this.getAgentID(), data);
	};

	/**
	 * API: Closes the persistent chat in progress on behalf of the persistent chat.
	 *   	Throws an error if a chat is not in progress.
	 * 		Fires a chat close event on invocation if thank you has not yet been shown.
	 * 		If thankyou has been shown,
	 * 			then the invocation will hide the chat and reset the state of the chat manager for re-chat.
	 * @return void
	 * @throws Error if chat is not in progress.
	 * @see this.closeChat below
	 */
	GR34.prototype.r345jjm = function(isConnected, conversationResolved) {
		try {
			// Mobile devices are problematic here.  For some reason
			// inqFrame never gets properly "closed."  So for those
			// devices we're going to put a limit on how long we're
			// willing to wait before moving on.
			if (!isMobileDevice() || this._closeRetries++ < 20) { // 20tries * 50ms-timeout = 1000 == 1 second
				//Sometimes STT team get exception only in IE while accessing "pw.closed" after closing Persistent window.
				//Error is: "An outgoing call cannot be made since the application is dispatching an input-synchronous call"

				// One more IE issue - RTDEV-17067 (scenario #1):
				// See https://jira.touchcommerce.com/browse/RTDEV-17067?focusedCommentId=487376#comment-487376
				// In IE there is specific behavior when the persistent chat window will be not loaded,
				// it is occurring in following use-cases:
				// - persistent window is navigated to other URL and then backward;
				// - persistent window is refreshed but network connection is lost
				//   (in this case is loaded the internal page - "about:blank",
				//   "res://ieframe.dll/dnserror.htm" or similar other - this is the similar to navigation to another URL of internal page,
				//   this case is intermittent and depends from cache settings).
				// In these cases persistent window will have the property "closed" in "true" state (pw.closed is TRUE).
				// The second use-case is more important for us, because we need restore the chat when connection will be reestablished.

				var pw = this.persistentWindow;
				if (pw != null && !pw.closed) {
					this.retryTimeout = setTimeout(function(){
							CHM.r345jjm(isConnected, conversationResolved);
						}, 50);
					return;
				}
			}
			else {
				this._closeRetries = 0;
			}
		}
		catch(e) {
			log("Error in GR34.r345jjm: " + e);
		}

		clearTimeout(this.retryTimeout);
		this.retryTimeout = null;

		if (CM.persistentWindow) {
			CM.persistentWindow = null;
		}
		var isAsync = this.isAsyncChat();
		if (isAsync) {
			this.updateConversationActiveFlagOnChatClose(conversationResolved);
		}

		if (isWebSDK) {
			window.Inq.datapass = null;
		} else if (window.parent.Inq.datapass) {
			window.parent.Inq.datapass = null;
		}
		if (isConnected) {
			this.nnm89();
		}
		// try closing the chat
		this.fireChatClosed();
		this.setPersistentWindowActive(false);
		this.removeChatInstance("GR34#r345jjm closing chat");
		if (isAsync) {
			C2CM.relaunchC2cRules();
		}
	};

	/**
	 * Set parameters (auxiliary to survey spec) that will be passed to survey manager on survey launch.
	 * This method does not erase previously set parameters rather adds them.
	 * Parameters are stored in lastChat object in Chat manager and persisted to inqVital thus available
	 * even after chat is closed.
	 * Note: Chat manager recreates lastChat object when new chat starts.
	 * @param params object with parameters for survey.
	 */
	GR34.prototype.setSurveyAuxParams = function(params){
		if (this.getLastChat()) {
			var svyPrms = this.getLastChat().svyPrms;
			if (!svyPrms) {
				svyPrms = this.getLastChat().svyPrms = MI8.mixAbsorber({});
			}
			svyPrms.absorb(params);
			this.save();
		} else {
			log("Warning: setting survey params failed - last chat data object doesn't exist.");
		}
	};

	/**
	 * Returns survey parameters (auxiliary to survey spec).
	 */
	GR34.prototype.getSurveyAuxParams = function(){
		if (this.getLastChat()) {
			return this.getLastChat().svyPrms;
		} else {
			return null;
		}
	};

	/**
	 * Sets clickstream sent flag.
	 * Flag is stored in lastChat object in Chat manager and persisted to inqVital thus available
	 * even after chat is closed.
	 */
	GR34.prototype.setClickStreamSent = function(isSent){
		if (this.getLastChat()) {
			this.getLastChat().clkstr = isSent;
			this.save();
		} else {
			log("Warning: setting ClickStreamSent flag failed - last chat data object doesn't exist.");
		}
	};

	/**
	 * Returns clickstream sent flag.
	 */
	GR34.prototype.isClickStreamSent = function (){
		if (this.getLastChat()) {
			return this.getLastChat().clkstr;
		} else {
			return null;
		}
	};
	/**
	 * If persistent chat's opener window was closed we can't define if the persistent window was closed or refreshed.
	 * According to RTDEV-17854, nnm89() was deleted. If the persistent window was closed chat router will close
	 * chat by timeout.
	 * @param {boolean} isConnected
	 * @param {boolean} conversationResolved shows if conversation was resolved
	 */
	GR34.prototype.closePersistent = function(isConnected, conversationResolved){
		openerCall("CloseChatFromPersistent", [isConnected, conversationResolved], false);
	};


	/**
	 * API: Quiesses the popup chat on behalf of the persistent chat
	 */
	GR34.prototype.inactivateChat = function(){
		if (this.chat==null) return ;
		this.chat.setVisible(false);
		FP.closeChatInterface();
	};

	/**
	 * Closes the chat and removes the instance if it e9.
	 * Then saves the new state into the persistent storage.
	 * @returns {void}
	 */
	GR34.prototype.removeChatInstance = function(reason) {
		if (this.getChat()) {
			lmt12(
				"Chat instance will be removed. Reason '" + reason + "'",
				LOG_LEVELS.INFO,
				null,
				true
			);
			this.chat.close();
			this.chat = null;
		}
		this.save();
		setCustID(CONVM.getInitialCustomerID(), true);
		this.resetAsyncUnauthUser();
	};

	/**
	 * API: Closes the current chat in progress. Throws an error if a chat is not in progress.
	 * Fires a chat close event on invocation if thank you has not yet been shown. If thankyou
	 * has been shown, then the invocation will hide the chat and reset the state of the chat manager
	 * for re-chat.
	 */
	GR34.prototype.closeChat = function(isConnected){
		if(getFormInIOSSDKInstance()) {
			getFormInIOSSDKInstance().postMessage("hideSurvey")
		}
		if(typeof SDKPushFormInterface != "undefined") {
			SDKPushFormInterface.closeForm()
		}

		if (isCEAPIPostChatSurveyMode()) {
			// avoid unnecessary fireChatClosed failure in ceapi mode.
			if(typeof SDKPostSurveyInterface != "undefined") {
				SDKPostSurveyInterface.closeChat();
			} else if(getPostSurveyInIOSSDKInstance()) {
				getPostSurveyInIOSSDKInstance().postMessage("closeChat");
			}
			return false;
		}
		/** TRICK CODE ALERT
		 * When we are closing as a persistent chat, we do NOT have much time.
		 * The window is rapidly being destroyed.
		 * For this reason we must attach a timer event to the opener window
		 *    and have it perform the close on behalf of this window.
		 */
		var isAsync = this.isAsyncChat();
		if (isAsync) {
			this.updateConversationActiveFlagOnChatClose(SVYM.isConversationResolvedOrEmtpyStatus());
		}
		if (this.isPersistentWindow()) {
			this.closePersistent(isConnected, SVYM.isConversationResolvedOrEmtpyStatus());
		} else if (this.getChat()) {
			// TODO analyze possibility to remove isPersistent check
			if (!this.getChat().isPersistent()) {
				this.fireChatClosed();
			}
			this.removeChatInstance("GR34#closeChat closing chat. Stack: " + (new Error()).stack);
			if (isAsync) {
				C2CM.relaunchC2cRules();
			}
		}
		if(isWebSDK) {
			window.Inq.datapass = null;
		} else if (window.parent.Inq.datapass) {
            window.parent.Inq.datapass = null;
        }
	};

	/**
	 * Reset onBeforeChatClosedFired and chatClosedFired flags
	 */
	GR34.prototype.reset = function () {
		this.onBeforeChatClosedFired = false;
		this.chatClosedFired = false;
	};

	/**
	 * Updates conversation active flag according to close circumstances
	 * @param {boolean} isResolved shows if conversation was resolved
	 */
	GR34.prototype.updateConversationActiveFlagOnChatClose = function (isResolved) {
		var notResolvedOrClosedByCustomer = !isResolved || !this.getChat().isAgentClosedChat();
		var conversationActiveOrAsyncChatWasEngaged = getConversationActive() || this.getChat() && this.getChat().getCustMsgCnt() > 0;
		var isActive = notResolvedOrClosedByCustomer && conversationActiveOrAsyncChatWasEngaged;
		setConversationActive(isActive);
	};

	/**
	 *  This function is called when customer closed the chat on ios.
	 */
	GR34.prototype.closeChatMonitor = function() {
		this.chat.closeChatMonitor();
	};

	/**
	 * Sets the flag "closed" in current chat instance,
	 * it means that current chat session is ended and chat finished.
	 * This state is saved in the persistent storage.
	 * @param {string} chatID
	 */
	GR34.prototype.endChatSession = function(chatID){
		if (this.getChatID() === chatID) {
			this.chat.endChatSession();
		}
	};

	/**
	 * PRIVATE: Assertion to assure that a chat is in or not in progress. Used to protect against
	 * invocation of chat methods against inconsistent chat states.
	 * @param _inProgress true to ensure that a chat is in progress (throws if isn't), false to
	 *   ensure chat is not in progress (throws if chat is in progress)
	 * @return void
	 * @throws Error Depending on param.
	 */
	GR34.prototype._assertChatInProgress = function(_inProgress){
		if(this.chat==null){
			if(_inProgress)
				throw Error("Chat "+(_inProgress?"not ":"")+"in progress");
		}
		else if(this.chat.isVisible()||this.isPersistentChat()){
			if(!_inProgress)
				throw Error("Chat "+(_inProgress?"not ":"")+"in progress");
		}
	};
	GR34.prototype.setOpacity = function(opac){
		if(this.chat) this.chat.setOpacity(opac);
	};
	GR34.prototype.showPersistentButton = function(x,y,w,h){
		this.chat.pb.setPosition(x,y,w,h);
		this.chat.pb.setVisible(true);
	};
	GR34.prototype.showTextInput = function(bShow,y,x,w,h){
		var o, offsetY ;
		offsetY = this.chat.chatSpec.chatTheme.tbh;
		o = getParentPageElById("inqInput4Chat", win.document) ;
		if (o) {
			o.style.display = (bShow) ? "" : "none" ;
			o.style.top     = (y+offsetY) + "px";
			o.style.left    = x + "px";
			o.style.width   = w + "px";
			o.style.height  = h + "px";
		}
	};
	GR34.prototype.hidePersistentButton = function(){
		this.chat.pb.setVisible(false);
	};
	GR34.prototype.setPersistentButtonDebugActive = function(active){
		this.chat.pb.setDebugActive(active);
	};

	/*
	 * PRIVATE: Resets the internal state of the chat and clears chat detritus from DOM.
	 * @return void
	 * @throws Error if chat is not in progress.
	 * @see InqChatMgr.closeChat
	 *
	 * TODO: deprecated?
	 */
	GR34.prototype._resetChat = function(){
		this._assertChatInProgress(true);
		win.document.body.removeChild(this.chat.container);
		this.thankYouShown = !this.displayTYImage;
		this.removeChatInstance();
	};

	/**
	 * API: Sets the currently initialized chat visible/hidden.
	 * @param {boolean} _vis true to set the chat visible in the DOM, false to hide. Uses style.display.
	 * @throws Error if chat is not initialized.
	 */
	GR34.prototype.setChatVisible = function(_vis){
		this.chat.setVisible(_vis);
	};

	/**
	 * Launches an initialized chat and fires a launch event for subscribed listeners.
	 * @param {Chat} chat The source Chat instance. A Chat instance contains rule,chatSpec, and
	 * 	flashvar
	 * @param {boolean} chatInProgress if true then it means that we are not starting a new chat but regenerating chat id for async chats.
	 * @return void
	 * @throws Error if chat is already in progress.
	 *
	 **/
	GR34.prototype.launchChat = function(chat, chatInProgress, reInitialize){
		try {
			this._assertChatInProgress(!!chatInProgress);
			if (this.chat != chat) {
				this.chat = chat;
				lmt12(
					"Chat instance was changed to " + this.chat,
					LOG_LEVELS.INFO,
					null,
					true
				);
			}
			if (!(this.getChatType() == this.CHAT_TYPES.MONITOR)) {
				/** @type {boolean} */
				var asyncChatRule = this.chat.isAsyncChatRule();
				this.chat.setAsyncChat(asyncChatRule);
				/**
				 * webSDK based messaging window should continue conversation with out a relaunch of chat window
                 * WebSDK uses CIV2 by default, but in standard deployment CIV2 is optional and it determines when it <skin-version>2</skin-version>
				 */
				var isCIV2Enabled = this.chat.isCIV2Skin() || isWebSDK;
				if(reInitialize && isCIV2Enabled && typeof Application != "undefined"){
					this.chat.initAppliation();
				} else {
					this.chat.show();
				}

			}
			if (this.resetChatOnBrowserClose) {
				this.cip.z3(1);
			}
			this.fireChatLaunched(this.chat.getChatData());

				// chat launch must result in conversionFunnel.exposed event only for proactive chat
				if(this.getChatType() == GR34.CHM.CHAT_TYPES.POPUP
					|| this.getChatType() == GR34.CHM.CHAT_TYPES.POPUP_CALL
					|| this.getChatType() == GR34.CHM.CHAT_TYPES.EXTERNAL_POPUP_CHAT
				) {
					BRM.fireServiceInvitationEvent(this.chat.getRule(), this.getChatType());
			}
		}catch (e){
			lmt12("Failure to Launch: "+cf21(e), LOG_LEVELS.INFO);
		}
	};

	GR34.prototype.getAgentID = function(){
		return (this.chat) ? this.chat.getAgentID() : null;
	};

	GR34.prototype.getAgentName = function() {
		return (this.chat) ? this.chat.getAgentName() : null;
	};

	/**
	 * Returns the first value of the specific agent attribute if it there's
	 * and empty string if there is no specific attribute or there is no chat.
	 * For example:
	 *   If string of attributes is "attr=foo,attr=bar",
	 *   then only "foo" will be returned.
	 * @param {string} attrName - name of the agent attribute
	 * @returns {string} - value of the agent attribute
	 */
	GR34.prototype.getAgentAttributeValue = function(attrName) {
		return this.chat ? this.chat.getAgentAttributeValue(attrName) : "";
	};

	/**
	 * Return the reformatted string was set in Chat.setAgentConfig().
	 * e.g. 'geography,usa;language,english;department,clothing;department,electronics'
	 * @returns {string}
     */
	GR34.prototype.getAgentAttributesAsString = function () {
        return (this.getChat() && this.getChat().getChatData() ? attributeMapToString(this.getChat().getChatData().agtAttrs) : "");
	};

	/**
	 * Adds each of the first values of agent attributes from specific list.
	 * The list with names of agent attribute is specified through the Business Rules engine
	 * as the "eventAgentAttributeList" variable.
	 * @param {object} evt
	 */
	GR34.prototype.addAgentAttributesToEvent = function(evt) {
		/** @type {VER34} */
		var attrList = PM.getVar("eventAgentAttributeList");
		if (attrList) {
			/** @type {Array} */
			var list = attrList.z0().split(",");
			for (var i = 0, name; i < list.length; i++) {
				name = list[i].trim();
				if (name != "") {
					evt[name] = this.getAgentAttributeValue(name);
				}
			}
		}
	};

	GR34.prototype.getCustomerName = function() {
		return (this.chat) ? this.chat.getCustomerName() : null;
	};

	/**
	 * Getter for window id.
	 *
	 * @return {?number} - returns window id.
	 */
	GR34.prototype.getWindowId = function() {
		return this.chat ? this.chat.getWindowId() : null;
	};

	GR34.prototype.isPersistentWindow = function(){
		return isPersistentWindow();
	};

	GR34.prototype.getChat = function () {
		return this.chat || null;
	};

	/**
	 * Returns business unit id.
	 * @param {object} evt
	 * @param {Rule} rule
	 * @return {number} business unit id
	 */
	GR34.prototype.getBusinessUnitID = function (evt, rule) {
		if (this.chat && this.chat.getChatBusinessUnitID() > 0) {
			return this.chat.getChatBusinessUnitID();
		} else if (this.chat && this.chat.getBusinessUnitID()) {
			return this.chat.getBusinessUnitID();
		} else if (evt && evt.rule && typeof evt.rule.getBusinessUnitID == "function") {
			return evt.rule.getBusinessUnitID();
		} else if (this.lastChat && this.lastChat.businessUnitID) {
			return this.lastChat.businessUnitID;
		} else if (rule) {
			return rule.getBusinessUnitID();
		}
		return getDefaultBusinessUnitID();
	};

	GR34.prototype.getLastChat = function() {
		return this.lastChat ? this.lastChat: null;
	};

	/**
	 * Provide the current email spec id of an active chat
	 * @return a non-negative id if a chat is in progress, otherwise 0
	 */
	GR34.prototype.getEmailSpecId = function() {
		var emailSpecId = 0;
		var chat = this.getChat();
		if (!!chat) {
			emailSpecId = chat.chatSpec.emSpId;
		}
		return emailSpecId;
	};

	/**
	 * Returns active chat ID
	 * @return {string}
	 */
	GR34.prototype.getChatID = function(){
		var id = "0";
		if(!!this.chat) {
			try {
				id = this.chat.getChatID();
			} catch(e) {}
		}
		return id;
	};

	/**
	 * Updates chat properties if chat exist
	 * @param {string} chatID
	 * @param {boolean=} asyncReconnect - reconnect flag for async chat
	 */
	GR34.prototype.updateChat = function(chatID, asyncReconnect){
		if (this.chat) {
			this.chat.setChatID(chatID);
			this.chat.setAsyncReconnect(asyncReconnect);
			this.save();
		}
	};

	GR34.prototype.getLastChatID = function() {
		var id = "0";
		if (!!this.lastChat && !!this.lastChat.id) {
			id = this.lastChat.id;
		}
		return id;
	};

	GR34.prototype.getLastAgentID = function() {
		var agentId = "";
		if (!!this.lastChat && !!this.lastChat.agentID) {
			agentId = this.lastChat.agentID;
		}
		return agentId;
	};

	/**
	 * Returns the last chat's agentAttributes string converted from this.lastChat.agtAttrs.
	 * @returns {string} The value is "" or string with format: attr1=value1,attr2=value2,attr2=value1,attr2=value2
     */
	GR34.prototype.getLastAgentAttributesAsString = function() {
		var attr = "";
		if (!!this.lastChat && !!this.lastChat.agtAttrs) {
			attr = attributeMapToString(this.lastChat.agtAttrs);
		}
		return attr;
	};

	/**
	 * Return this.chat's agentAttributes string from this.chat if this.chat is available, else return the agentAttributesString of
	 * the this.lastChat.
	 * @returns {string} The value is "" or string with format: attr1=value1,attr2=value2,attr2=value1,attr2=value2
	 */
	GR34.prototype.getChatOrLastChatAgentAttributesString = function() {
		return (this.getChat() && this.getChat().getChatData()) ? this.getAgentAttributesAsString() : this.getLastAgentAttributesAsString();
	};

	/**
	 * MAINT24-207: Chat manager remembers id of last call to check agent availability for the next call and
	 * suppress call invitation if agent hasn't closed previous call window in AI.
	 * @return id of last call; if there was no call, 0 will be returned.
	 */
	GR34.prototype.getLastCallID = function() {
		return this.lastCallId;
	};

	GR34.prototype.getChatType = function(){
		return this.chat ? this.chat.getChatType() : null;
	};

	GR34.prototype.getLastChatType = function(){
		return this.lastChat ? this.lastChat.chatType : null;
	};

	/**
	 * Block a specific service/chat type for a period of time
	 * @param serviceType only valid type at this time is "POPUP" and "POPUP_CALL"
	 * @param period duration of blocked service in milliseconds
	 */
	GR34.prototype.tryue = function(serviceType, period) {
		if(serviceType != GR34.CHM.CHAT_TYPES.POPUP &&
				serviceType != GR34.CHM.CHAT_TYPES.POPUP_CALL) {return;}
		if (inu1(this.blocked)) {
			this.blocked = {};
		}
		// block the service if it hasn't already been blocked or block duration has been expired
		if (inu1(this.blocked[serviceType]) || (!inu1(this.blocked[serviceType]) && this.blocked[serviceType] < (new Date).getTime())) {
			if (period > 0)  {
				var now = new Date();
				period += now.getTime();
			}
			this.blocked[serviceType] = period;
			this.save();
		}
	};

	GR34.prototype.unblockService = function(serviceType) {
		if(serviceType != GR34.CHM.CHAT_TYPES.POPUP &&
				serviceType != GR34.CHM.CHAT_TYPES.POPUP_CALL) { return;}
		if (!inu1(this.blocked) && !inu1(this.blocked[serviceType])) {
			delete this.blocked[serviceType];
		}
		this.save();
	};

	GR34.prototype.setCobrowseFlag = function(flag) {
		var val = (flag)?1:0;
		if (this.cb != val) {
			this.cb = val;
			this.save();
		}
	};

	GR34.prototype.getCobrowseFlag = function(){
		return (!!this.cb)?true:false;
	};

	GR34.prototype.isBlocked = function(serviceType) {
		var blockedValue = false;
		if (!inu1(this.blocked) && !inu1(this.blocked[serviceType])) {
			var now = new Date();
			var toDate = this.blocked[serviceType];
			if (toDate <= 0) { // 0 - session, -1 forever
				blockedValue = true;
			}
			else {
				blockedValue = toDate >= now.getTime();
			}
		}
		return blockedValue;
	};

	GR34.prototype.isAnyBlocked = function() {
		if (inu1(this.blocked)) {
			return false;
		}
		return Object.keys(this.blocked).length > 0;
	};

	/*
	 * API: Provides the date/time of the latest proactive chat launched.
	 * @return Date object representing last proactive launch datetime. Null if now proactive ever launched.
	 * @throws Error if chat is not initialized.
	 */
	GR34.prototype.isProactiveExpired = function(){
		if(!this.lpt) return false;
		var expireTime = new Date(this.lpt).getTime()+Inq.rechatInterval * 24 * 60 * 60 * 1000;
		var now = new Date().getTime();
		return now > expireTime;
	};

	GR34.prototype.popOutChat = function(transition){
		if( !this.isPersistentChatActive())
			this._firePersistentPushEvt({});
		/**
		 * For cross domain mode (CM.xd==true) we want to make sure
		 *   that cookies are set before we pop out the chat.
		 * To do this we must:
		 *  1) Pop out an empty chat window (no persistent chat, just empty) we must do this because of pop-out blockers
		 *  2) We must send out the transition message
		 *  3) We must, upon commiting the cookies
		 *     a) set the popout window to the early popout window
		 *     b) transfer the href of the early popout window to the frame source making the early popout a persistent window.
		 *     c) set persistent chat flag to true
		 *     d) set early popout to null, because it is the pop out window now.
		 *
		 */
		if (CM.xd) {
			if (transition) {
				this.chat.transitionMessage(this.PERSISTENT.PERSISTENT);
			}
			CM.dump();					/* dump the cookie contents */
			if ((null==this.earlyPopout || this.earlyPopout.closed) && !isWebSDK) {
				this.wecv56(this.chat.chatSpec.chatTheme);
			}
			CM.setWhen3rdPartyCookieCommittedHandler(function(){
					(inqFrame.Inq.CHM).relocateToHostedPage(5);	/* relocate to hosted page with a retry of 5 times */
			});
			return true;
		} else {
			if (isMobileDevice()) {
				inqFrame.Inq.FlashPeer.closePopupChat();
			}
			return this.chat.popOutChat(transition);
		}
	};
	/** relocateToHostedPage - relocates the empty early-popout window to the hosted file to become a persistent chat
	 * if this failes, it will retry until the retry count is zero
	 * @param retryCnt - the number of retries allowed
	 * @return nothing
	 * @see GR34.prototype.popOutChat
	 */
	GR34.prototype.relocateToHostedPage = function(retryCnt){
		try {
			if (isWebSDK) {
				FrameBridge.pushPersistentWindowURL(Inq.v3framesrc, this.c2cIdx, this.chat.chatSpec.chatTheme);
			} else {

				this.popoutWindow = this.earlyPopout;				/* set the popout window to the early popout window */
				this.popoutWindow.location.href = Inq.v3framesrc;	/* make the early popout window a popout window by setting its location to the hosted file */

				if ( getOSType() === "iOS" && this.popoutWindow.focus )	{
					try	{
						this.popoutWindow.focus();
					} catch ( errFocus ) { }
				}
				this.earlyPopout = null;
				/* earlyPopout, your work is done here, thank-you for your service */
			}
			window.Inq.isPersistentInitialization = true;
		} catch (err) {
			/* Add extra information to the Error object (err) to give more detailed information */
			err["this"] = this ;														/* Display "this" */
			err["popoutWindow"] = (this.popoutWindow)?this.popoutWindow:"undefined";	/* Display the popoutWindow object */
			err["earlyPopout"] = (this.earlyPopout)?this.earlyPopout:"undefined";		/* Display the earlyPopout window object */
			err["popoutWindow_location"] = (this.popoutWindow.location)?this.popoutWindow.location:"undefined"; /* Display the window location */
			if (retryCnt==0) 																/* If count is zero, then all retries are exhausted */
				err["PersistentFailure"] = "Persistent Popout failed, all retries exhausted"; /* Add that info to error object as well */
			/* Post the error information with trace to the tag server */
			lmt12("Failure to relocateToHostedPage("+retryCnt+"): "+cf21(err), LOG_LEVELS.INFO);

			if (retryCnt > 0) {
				setTimeout(function () {
					this.relocateToHostedPage(--retryCnt);
				}.bind(this), 50);
			} else { /* We have exhausted all retries, so we must close the popout window */
				/* Depending where the failure was, the popout window may be (earlyPopout) or (popoutWindow), try closing both */
				var wins=[this.earlyPopout, this.popoutWindow]; /* possible pointers to the popout window */
				while (wins.length) {
					w = wins.shift()							/* get window */
					if (w) {									/* if window is not null, then close it */
						try {
							if (!w.closed)						/* if not closed then close it */
								w.close();						/* close */
						} catch(e) {}
					}
				}
				this.earlyPopout = this.popoutWindow = null;	/* clean up the pointers */
			}
		}
	};

	GR34.prototype.toString = function(){
		return "GR34: "+MI8.JSON.stringify(this);
	};

	GR34.prototype._addListener = function(_l,_lArr){
		if (!_l.id)
			_l.id = Math.random();
		_lArr.push(_l);
	};

	GR34.prototype.hasAlreadyChatted = function(chatData) {
		if (!this.lastChat) return false;
		var lastChatTimeMS = new Date(this.lastChat.time).getTime();

		var nowMS = (new Date()).getTime();
		var reChatTimeMS = lastChatTimeMS + Inq.rechatInterval*(24*60*60*1000);
		return (reChatTimeMS>=nowMS);
	};

	GR34.prototype.clearAllChatListeners = function() {
		this._listeners=[];
	};

	/**
	 * Sets agent data to chat
	 *
	 * @param {string} aid - agent ID
	 * @param {boolean} noSave - flag to show if chat data should be saved
	 * @param {boolean} cobrowseEnabled - flag to show if CoBrowse is enabled
	 * @param {Object} eventData - JSON string includes agents' first name, last name and site attributes
	 * @param {number} buID - business unit for chat
	 * @param {number} agID - agent group id of chat owner
	 * @return void
	 */
	GR34.prototype.assignAgent = function(aid, noSave, cobrowseEnabled, eventData, buID, agID){
		log("Agent Assigned: GR34.assignAgent("+aid+")");
		try{
            var agentAttrs;
			if (typeof(eventData) == "object") {
				agentAttrs = eventData["agtAttrs"];
			}
			var msg = plc1("Set agent config : agentID=" + aid + ",buID=" + buID + ",agID=" + agID + ",agentAttrs=" + agentAttrs + ". ");
			ROM.post(urls.loggingURL, {level:LOG_LEVELS.INFO, line: msg});
			this.chat.setAgentConfig(aid, buID, agID, agentAttrs);
			if (!noSave) {
				this.save(
					this.assignAgentActions.bind(
						this,
						aid,
						cobrowseEnabled,
						eventData,
						buID,
						agID,
						noSave
					)
				);
			} else {
				this.assignAgentActions(aid, cobrowseEnabled, eventData, buID, agID, noSave);
			}
		} catch (er) {
			log("FAILED ATTEMPT TO SET AGENT ID FROM FLASH: " + er, LOG_LEVELS.ERROR);
		}
	};

	/**
	 * Fires agentAssigned event on current window
	 * and in main page if it is persistent chat.
	 *
	 * We fire AgentAssigned in both windows but behaviour in opener
	 * and persistent windows is different
	 * See rules 621 and 624 in ProgramRules, for c2call and c2c to persistent chat
	 * we handle onAgentAssigned event to fire "assisted" event in rule 624.
	 * And in opener window these chat types are excluded for "assisted" firing  in rule 621.
	 *
	 * @param {string} aid - agent ID
	 * @param {boolean} cobrowseEnabled - flag to show if CoBrowse is enabled
	 * @param {object} eventData - JSON string includes agents' first name, last name and site attributes
	 * @param {number} buID - business unit for chat
	 * @param {number} agID - agent group id of chat owner
	 * @param {boolean} noSave - flag to show if chat data should be saved
	 */
	GR34.prototype.assignAgentActions = function (aid, cobrowseEnabled, eventData, buID, agID, noSave) {
		this.fireAgentAssigned(aid, cobrowseEnabled, eventData, buID, agID, !noSave);
		if (this.isPersistentWindow() && Inq.isSameOrigin()) {
			if (typeof (eventData) == "object") {
				eventData = MI8.JSON.stringify(eventData);
			}
			openerCall("assignAgent", [aid, true, cobrowseEnabled, eventData, buID, agID], true);
		}
	};

    /**
     * Returns agent group name by ID.
     * @param agID the agent group id.
     * @returns the agent group name if successful or undefined otherwise.
     */
    GR34.prototype.getAgentGroupNameByID = function(agID) {
        // Returns undefined instead of empty string if agID is not available.
        var agName;
        if (!inu1(agID) && site.siteAgentGroups.hasOwnProperty(agID)) {
            agName = site.siteAgentGroups[agID];
        }
        return agName;
    };

	/**
	 * Returns agent group display name by ID.
	 * @param agID the agent group id.
	 * @returns the agent group display name if successful or undefined otherwise.
	 */
	GR34.prototype.getAgentGroupDisplayNameByID = function(agID) {
		var agDisplayName;
		if (!inu1(agID) && site.siteAgentGroupsDisplayNames.hasOwnProperty(agID)) {
			agDisplayName = site.siteAgentGroupsDisplayNames[agID];
		}
		return agDisplayName;
	}

	/**
	 * Returns business unit name by ID.
	 * @param buID the business unit id.
	 * @returns the business unit name if successful or undefined otherwise.
	 */
	GR34.prototype.getBusinessUnitNameByID = function(buID) {
		var buName;
		if (!inu1(buID) && site.siteBusinessUnitsNames.hasOwnProperty(buID)) {
			buName = site.siteBusinessUnitsNames[buID];
		}
		return buName;
	}

	/**
	 * Returns business unit display name by ID.
	 * @param buID the business unit id.
	 * @returns the business unit display name if successful or undefined otherwise.
	 */
	GR34.prototype.getBusinessUnitDisplayNameByID = function(buID) {
		var buDispName;
		if (!inu1(buID) && site.siteBusinessUnitsDisplayNames.hasOwnProperty(buID)) {
			buDispName = site.siteBusinessUnitsDisplayNames[buID];
		}
		return buDispName;
	}

	/**
	 * Checks the chat instance and its flag "closed".
	 * @returns {boolean}
	 */
	GR34.prototype.isChatClosed = function() {
		if (this.getChat()) {
			return this.getChat().isClosed();
		} else {
			return false;
		}
	};

	GR34.prototype.isV3Continue = function(){
		var ciData = this.getChatInterfaceData();
        return ciData ? ciData.c == 1 : false;
	};

	/** isV3Active - returns whether-or-not V3 chat is active on another page
	  *		so, if we go from page to page, we want it to be "inactive" when the page closes
	  *		we only want to know if there is a "visible" chat somewhere else,
	  *		NOT if we have an active chat session.
	  *
	  * @return {boolean} true if active, false if not
	  * @see  this.testForContinueChatting
	  */
	GR34.prototype.isV3Active = function(){
		if (CM.xd){
			try {
				var activeFlag = CM.getV3ActiveValue();		/* Get the active flag (called "inqCA") */
				var activeCount;
				if (activeFlag==null)						/* if it does not exist, then return false */
					return false ;							/* It does NOT exist */
				if (isNaN(activeCount = parseInt(activeFlag))){	/* Get the numeric value of the flag */
					return false;
				}

				if (activeCount <= 0) return false;			/* If the value is less than 1, return false */
					return true;							/* If the count is greater than 1, return true */
			} catch (e) {
				log("Error detecting isV3Active:" + e);
				return false ;
			}
		} else {
			var ciData = this.getChatInterfaceData();
			if(!!ciData) {
				return (ciData.a==true);
			}
			return false;
		}
	};

	GR34.prototype.isChatInProgress = function() {
		if (isCEAPIPostChatSurveyMode()) {
			// avoid unnecessary checkCoolieValidity failure in ceapi mode.
			return false;
		}
        if (this.isV3Active() || CM47.chatSessionHelperIsChatInProgress())
            return true;

		if (this.isChatClosed()) {
			return false;
		} else {
			if (this.isPersistentChat()) {
				// '!CM.xd ||' means the condition after || is checked only in xd mode.
				return (this.isPersistentChatActive() && (!CM.xd || this.isV3Active()));
			} else {
				return this.isV3Continue();
			}
		}
	};

	/**
	 * Returns is chat visible on current page.
	 * @return {boolean} - is chat visible
	 */
	GR34.prototype.isInlineChatInProgress = function(){
		return (!!this.chat && this.chat.isVisible());
	};

	GR34.prototype.isThankYouEnabled = function(){
		return this.thankYouEnabled;
	};

	GR34.prototype.getChatData = function(){
		return this.getChat();
	};

	GR34.prototype.getLaunchPageId = function(){
		if (this.chat && this.chat.getChatData()) {
			return this.chat.getChatData().launchPageId;
		} else {
			return "";
		}
	};

	GR34.prototype.onChatLaunched = function(evt){
		//If only Session Cookies are allowed for IE browser, writing the information to the TagServer Logs.
		// Both in XD and Non-XD mode.
		if (!CM.isPersistentCookiesAllowed() && isIE()) {
			var sesOnlyCookieMsg = "Only Session Cookies are allowed for this chatID. "+this.getChatID();
			if (!JSLoggingDisabled) {
				log(""+sesOnlyCookieMsg);
				lmt12(sesOnlyCookieMsg, LOG_LEVELS.INFO);
			}
		}
	};

	GR34.prototype._fireChatEvt = function(evt){
		this._fireEvt(
			function(l,evt){if(l.onChatEvent) l.onChatEvent(evt);},
			evt
		);
	};

	/**
	 * Fires agentDataPassEvent event.
	 *
	 * param {string} agentDataPass - agentDataPass value of the agent message.
	 */
	GR34.prototype.fireAgentDataPassEvent = function (agentDataPass) {
		if (inu1(this.chat)) {
			let12(
				"Error firing event onAgentDataPass: chat instance doesn't exist.",
				true
			);
			return;
		}
		var event = {
			customerID: getCustID(),
			chatID: this.getChatID(),
			agentDataPass: agentDataPass
		};
		this._fireEvt(
			function (l, event) {
				try {
					if (typeof l.onAgentDataPass == "function") {
						l.onAgentDataPass(event);
					}
				} catch (e) {
					let12("Error firing event onAgentDataPass on "
						+ l.toString() + ": \n" + cf21(e));
				}
			},
			event
		);
		if (!this.isPersistentWindow() || !isIE()) { // This is to fix IE8 quirk in XD Mode
			this.chat.save();
		}
	};

	/**
	 * Saves vaDataPass and fires vaDataPassEvent event.
	 *
	 * @param {string} vaDataPass - vaDataPass value of the virtual agent message.
	 */
	GR34.prototype.fireVADataPassEvent = function (vaDataPass) {
		if (inu1(this.chat)) {
			DMgr.let12(
				"VA_DATA_PASS",
				"Error firing event onReceiveVADataPass: chat instance doesn't exist."
			);
			return;
		}
		this.chat.setVADataPass(vaDataPass);

		var event = {
			vaDataPass: vaDataPass
		};
		this._fireEvt(
			function (l, event) {
				try {
					if (typeof l.onReceiveVADataPass == "function") {
						DMgr.logDebugToTagServer(
							"VA_DATA_PASS",
							"Fires onReceiveVADataPass event"
						)
						l.onReceiveVADataPass(event);
					}
				} catch (e) {
					let12(
						"Error firing event onReceiveVADataPass on "
						+ l.toString() + ". " + e,
						true
					);
				}
			},
			event
		);
	};

	/**
	 * ChatroomReady event is fired with 1st NDEP response if it is chat authorized message.
	 * No Agent is assigned, and this event doesn't need any event detail.
	 *
	 */
	GR34.prototype.fireChatroomReadyEvent = function (evt) {
		if (inu1(this.chat)) {
			return;
		}

		var event = {
		};

		this._fireEvt(
			function (l, event) {
				try {
					if (typeof l.onChatroomReady == "function") {
						l.onChatroomReady(event);
					}
				} catch (e) {
					log("Error firing event ChatroomReady on " + l.toString() + ": \n" + e);
				}
			},
			event
		);
	};

	GR34.prototype.fireAgentMsgEvent = function(evt) {
		if (inu1(this.chat)) { return; }
		this.chat.bumpAgtMsgCount();
		var event = {
			customerID: Inq.getCustID(),
			chatID: this.getChatID(),
			custMsgCnt:this.chat.getCustMsgCnt(),
			agtMsgCnt:this.chat.getAgentMsgCnt(),
			textLine: evt.textLine
		};
		this._fireEvt(
				function(l, event){
					try {
						if(typeof l.onAgentMsg=="function") l.onAgentMsg(event);
						if(typeof l.onChatEvent=="function") l.onChatEvent(event);
					} catch(e) {
						log("Error firing event onAgentMsg on " + l.toString() + ": \n" + e);
					}
				},
				event
			);
		if(!this.isPersistentWindow() || !isIE()) // This is to fix IE8 quirk in XD Mode
			this.chat.save();
	};

	GR34.prototype.fireCustomerMsgEvent = function(evt) {
		if (inu1(this.chat)) { return; }
		this.chat.bumpCustMsgCount();
		var event = MI8.mixAbsorber({
			customerID: Inq.getCustID(),
			chatID: this.getChatID(),
			custMsgCnt:this.chat.getCustMsgCnt(),
			agtMsgCnt:this.chat.getAgentMsgCnt(),
			textLine: evt.textLine.substring(0, 50)
		});
		this._fireEvt(
				function(l, event){
					try {
						if(typeof l.onCustomerMsg=="function") l.onCustomerMsg(event);
						if(typeof l.onChatEvent=="function") l.onChatEvent(event);
					} catch(e) {
						log("Error firing event onCustomerMsg on " + l.toString() + ": \n" + e);
					}
				},
				event
			);
		if(!this.isPersistentWindow() || !isIE()) // This is to fix IE8 quirk in XD Mode
			this.chat.save();
	};

    GR34.prototype.fireQueueWaitMsgEvent = function() {
        if (inu1(this.chat)) {
            return;
        }
        var event = MI8.mixAbsorber({
            customerID: Inq.getCustID(),
            chatID: this.getChatID()
        });
        this._fireEvt(
            function(l, event) {
                try {
                    if (typeof l.onQueueWaitMsg == "function") {
                        l.onQueueWaitMsg(event);
                    }
                } catch(e) {
                    log("Error firing event onQueueWaitMsg on " + l.toString() + ": \n" + e);
                }
            },
            event
        );
    };

	/**
	 * GR34 fires this event when a chat has been requested. Chat requests
	 * typically originate from business rule actions.
	 * @param src origin from which the event was fired.
	 * @param evtData contains the following data:
	 * 		siteID,
			pageID,
			chatSpec,
			chatType,
			rule
	 */
	GR34.prototype.fireChatRequested = function(src, evtData) {
		var evt = MI8.mixAbsorber({});
		evt.absorb(evtData);
		evt.id = ++this.evtIdx;
		evt.evtType = this.EVTS.REQUESTED;
		evt.timestamp = new Date();
		evt.src = src;
		this._fireEvt(
			function(l, evt) {
				if (typeof l.onChatRequested == "function") l.onChatRequested(evt);
			},
			evt
		);
	};

	/**
	 * RM91 fires this event when a chat conversation transcript has been received.
     *
	 * @param {Object} evtData - TranscriptReceived event data
	 * @param {integer} evtData.requestCount - number of retries before success
 	 * @param {integer} evtData.responseTime - time in milliseconds before reply
	 *
	 * @fires GR34#onTranscriptReceived
	 */
	GR34.prototype.fireTranscriptReceivedEvent = function(evtData) {
		/**
		 * @event GR34#onTranscriptReceived
		 * @type {object}
		 * @property {string} chatID - chat session id
		 * @property {string} chatType - chat type (ex: c2c)
		 * @property {string} customerID - customer id
		 * @property {string} timestamp - time that event was fired at
		 * @property {integer} requestCount - evtData.requestCount absorb
		 * @property {integer} responseTime - evtData.responseTime absorb
		 */
        var evt = MI8.mixAbsorber({
			chatID: this.getChatID(),
			chatType: this.getChatType(),
			customerID: Inq.getCustID(),
			timestamp: (new Date()).toString()
		});
		evt.absorb(evtData);
		this._fireEvt(
			function(l, evt) {
				if (typeof l.onTranscriptReceived == "function") {
					l.onTranscriptReceived(evt);
				}
			},
			evt
		);
	};

	/**
	 * LandingFramework fires this event when all framework managers have started.
     *
	 * @param {Object} evtData - FrameworkReady event data
 	 * @param {integer} evtData.loadingTime - framework load time in ms
	 *
	 * @fires GR34#onFrameworkReady
	 */
	GR34.prototype.fireFrameworkReadyEvent = function(evtData) {
		/**
		* @event GR34#onFrameworkReady
		* @type {object}
		* @property {string} timestamp - time that event was fired at
		* @property {integer} loadingTime - evtData.loadingTime absorb
   		*/
		var evt = MI8.mixAbsorber({
			timestamp: (new Date()).toString()
		});
		evt.absorb(evtData);
		this._fireEvt(
			function(l, evt) {
				if (typeof l.onFrameworkReady == "function") {
					l.onFrameworkReady(evt);
				}
			},
			evt
		);
	};

	/**
	 * Invoked when chat is launched...
	 *
	 */
	GR34.prototype.fireChatLaunched = function(chatData){
		if (chatData==null) chatData = this.chat.getChatData() ;
		var evt = MI8.mixAbsorber({id:++this.evtIdx, evtType:this.EVTS.LAUNCHED, src:this, chatID:chatData.id});
		evt.absorb(chatData).absorb({"customerID": Inq.getCustID(), rule:this.rule});
        if (this.chat) evt.inHOP = this.chat.inHOP;

		var custEvt = MI8.mixAbsorber({customerID: Inq.getCustID(), chatID: chatData.id, evtType:this.EVTS.LAUNCHED, chatType: this.getChatType(), bizRuleName: this.rule.getName(), startDateTimestamp: this.startDateTimestamp});

		var buID = null;
		var agID = null;
		if (evt["buID"]) {
			buID = evt["buID"];
			delete evt["buID"];
		}
		if (evt["agID"]) {
			agID = evt["agID"];
			delete evt["agID"];
		}
		if (! (buID && agID) || parseInt(buID) <= 0 || parseInt(agID) <= 0) {
			var rule = BRM.rb41(chatData.ruleID) ? BRM.rb41(chatData.ruleID) : this.rule;
			if (rule) {
				buID = buID && parseInt(buID) > 0 ? buID : rule.getBusinessUnitID();
				agID = agID && parseInt(agID) > 0 ? agID : rule.getAgentGroupID();
			}
		}

		if (agID && parseInt(agID) > 0) {
			custEvt.absorb({agentGroupID: agID});
			evt.absorb({agentGroupID: agID});
		}
		if (buID && parseInt(buID) > 0) {
			custEvt.absorb({businessUnitID: buID});
			evt.absorb({businessUnitID: buID});
		}

		this._fireEvt(
			function(l, evt){
				var event = inu1(l.custApi) ? evt : custEvt;
				try {
					if(typeof l.onChatLaunched=="function") l.onChatLaunched(event);
					if(typeof l.onChatEvent=="function") l.onChatEvent(event);
				} catch(e) {
					log("Error firing event onChatLaunched on " + l.toString() + ": \n" + e);
				}
			},
			evt
		);

		if (this.isPersistentWindow()) {
			openerCall("fireChatLaunched", null, true);
		}
	};
	/**
	 * Invoked when chat is shown (after skin loaded)
	 */
	GR34.prototype.fireChatShown = function(chatData){
		if (chatData==null) chatData = this.chat.getChatData() ;
		var evt = MI8.mixAbsorber({id:++this.evtIdx, evtType:this.EVTS.SHOWN, src:this, chatID:chatData.id});
		evt.absorb(chatData).absorb({"customerID": Inq.getCustID(), rule:this.rule});
		if (this.chat) evt.inHOP = this.chat.inHOP;
		this._fireEvt(
			function(l, evt){
				try {
					if(typeof l.onChatShown=="function") l.onChatShown(evt);
					if(typeof l.onChatEvent=="function") l.onChatEvent(evt);
				} catch(e) {
					log("Error firing event onChatShown on " + l.toString() + ": \n" + e);
				}
			},
			evt
		);
	};

	GR34.prototype.fireBeforeChatClosed = function () {
		if (!this.onBeforeChatClosedFired) {
			this.onBeforeChatClosedFired = true;
			try {
				var chatData = this.chat.getChatData();
				var evt = MI8.mixAbsorber({
					id: ++this.evtIdx,
					chatID: chatData.id,
					evtType: this.EVTS.BEFORE_CLOSED,
					timestamp: new Date(),
					rule: this.rule,
					src: this
				});
				evt.absorb(chatData).absorb({"customerID": Inq.getCustID(), "agentID": this.getAgentID()});

				this._fireEvt(/* NOTICE: This cauased a fault due to id not being defined */
					function (l, evt) {
						try {
							if (typeof l.onBeforeChatClosed == "function") l.onBeforeChatClosed(evt);
							if (typeof l.onChatEvent == "function") l.onChatEvent(evt);
						} catch (e) {
							log("Error firing event onBeforeChatClosed on " + l.toString() + ": \n" + e);
						}
					},
					evt);
			} catch (e) {
				lmt12("Failure to fireBeforeChatClosed: " + cf21(e), LOG_LEVELS.INFO);
			}
		}
	};

	GR34.prototype.fireChatClosed = function(chatData){
		if (this.chatClosedFired) {
			return;
		}

	    try {
			this.chatClosedFired = true;
		    if (chatData==null) chatData = this.chat.getChatData();
		    this.hasEngaged=false;
		    var evt = MI8.mixAbsorber({id:++this.evtIdx, chatID: chatData.id, evtType:this.EVTS.CLOSED, timestamp:new Date(), rule:this.rule, src: this});
		    evt.absorb(chatData).absorb({"customerID": Inq.getCustID(), "agentID":this.getAgentID()});


			var buID = null;
			var agID = null;
			if (evt["buID"]) {
				buID = evt["buID"];
				delete evt["buID"];
			}
			if (evt["agID"]) {
				agID = evt["agID"];
				delete evt["agID"];
			}
			if (! (buID && agID) || parseInt(buID) <= 0 || parseInt(agID) <= 0) {
				var rule = BRM.rb41(chatData.ruleID) ? BRM.rb41(chatData.ruleID) : this.rule;
				if (rule) {
					buID = buID && parseInt(buID) > 0 ? buID : rule.getBusinessUnitID();
					agID = agID && parseInt(agID) > 0 ? agID : rule.getAgentGroupID();
				}
			}

			if (agID && parseInt(agID) > 0) {
				evt.absorb({agentGroupID: agID});
			}
			if (buID && parseInt(buID) > 0) {
				evt.absorb({businessUnitID: buID});
			}

			// if chat duration is less than one minute, then most likely it's not common chat
			// this counter need for stop spamming chat.requests for embedded chats
			if ((Date.now() - this.startDateTimestamp) < this.MAX_REFRESH_NEW_EMBEDDED_CHAT_DELAY) {
				this.chatLaunchCounter++;
			} else {
				this.chatLaunchCounter = 0;
				this.chatLaunchTimeoutIncrement.reset();
			}

		    var custEvt = {customerID: Inq.getCustID(), chatID: chatData.id, agentID: this.getAgentID(), bizRuleName: this.rule.getName(),
                businessUnitID: buID, agentGroupID: agID, evtType:this.EVTS.CLOSED, chatType:this.getChatType()};
		    this._fireEvt(                        /* NOTICE: This cauased a fault due to id not being defined */
			    function(l, evt){
				    var event = inu1(l.custApi) ? evt : custEvt;
				    try {
					    if(typeof l.onChatClosed=="function") l.onChatClosed(event);
					    if(typeof l.onChatEvent=="function") l.onChatEvent(event);
				    } catch(e) {
					    log("Error firing event onChatClosed on " + l.toString() + ": \n" + e);
				    }
			    },
				evt);
		} catch(e) {
            lmt12("Failure to fireChatClosed: "+cf21(e), LOG_LEVELS.INFO);
		}
	};

	GR34.prototype.fireChatEngaged = function(_src){
		if(this.hasEngaged){return;}
		this.hasEngaged=true;
		var evt = MI8.mixAbsorber({
				evtType:this.EVTS.ENGAGED,
				timestamp:new Date(),
				src:_src,
				chat: this.getChatData(),
				bizRuleName: this.rule.getName()
		});
		var chatData = this.getChatData();
		evt.absorb(chatData).absorb({"chatID":this.getChatID(), "chatType":this.getChatType(), "customerID": Inq.getCustID(), "agentID":this.getAgentID()});

		var custEvt = MI8.mixAbsorber({customerID: Inq.getCustID(), chatID: chatData.id, evtType:this.EVTS.LAUNCHED, chatType: this.getChatType(), bizRuleName: this.rule.getName()});

		var buID = null;
		var agID = null;
		if (evt["buID"]) {
			buID = evt["buID"];
			delete evt["buID"];
		}
		if (evt["agID"]) {
			agID = evt["agID"];
			delete evt["agID"];
		}
		if (! (buID && agID) || parseInt(buID) <= 0 || parseInt(agID) <= 0) {
			var rule = BRM.rb41(chatData.ruleID) ? BRM.rb41(chatData.ruleID) : this.rule;
			if (rule) {
				buID = buID && parseInt(buID) > 0 ? buID : rule.getBusinessUnitID();
				agID = agID && parseInt(agID) > 0 ? agID : rule.getAgentGroupID();
			}
		}

		if (agID && parseInt(agID) > 0) {
			custEvt.absorb({agentGroupID: agID});
			evt.absorb({agentGroupID: agID});
		}
		if (buID && parseInt(buID) > 0) {
			custEvt.absorb({businessUnitID: buID});
			evt.absorb({businessUnitID: buID});
		}

		this._fireEvt(
			function(l, evt){
				if(typeof l.onChatEngagedEvent=="function") l.onChatEngagedEvent(evt);
				if(typeof l.onChatEvent=="function") l.onChatEvent(evt);
			},
			evt
		);
	};

	GR34.prototype.firePersistentPush = function(){
		this._fireChatEvt({id:++this.evtIdx, chatType:this.chat.getChatType(), evtType:this.EVTS.PERSISTENT_PUSH, chat:this.getChatData(), timestamp:new Date()});
	};

	GR34.prototype._firePersistentPushEvt = function(evt){
        var chatData = null;
        var inh = null;
        if (this.chat){
            inh = this.chat.inHOP;
            chatData = this.chat.getChatData() ;
        }
		evt = MI8.mixAbsorber({id:++this.evtIdx, evtType:this.EVTS.PERSISTENT_PUSH, src:this, chatID:(chatData ? chatData.id : null), inHOP: inh});
        evt.absorb(chatData).absorb({"customerID": Inq.getCustID(), rule:this.rule});

		this._fireEvt(function(l, _evt){if(l.onPersistentPush) l.onPersistentPush(_evt);}, evt);
	};

	/**
	 * @param _agtID text agentID
	 * @param _cobrowseEnabled boolean cobrowseEnabled.
	 * @param eventData JSON (string or object) with agent's first, last name, agent alias, requested attribute.
	 * @param buID business unit of assigned agent
	 * @param [agID] (optional) agent group of assigned agent
	 * @param {boolean} save - flag for saving data to cookie.
	 */
	GR34.prototype.fireAgentAssigned = function(_agtID, _cobrowseEnabled, eventData, buID, agID, save){
		try {
			this.evtIdx++;
			var evt = MI8.mixAbsorber({
				id: this.evtIdx,
				agentID: _agtID,
				cobrowseEnabled: !!_cobrowseEnabled,
				ruleID: this.chat.getRule().getID(),
				chatID: this.getChatID(),
				timestamp: new Date(),
				businessUnitID: buID,
				startDateTimestamp: this.startDateTimestamp
			});

			if (agID) {
				evt.agentGroupID = agID;
			}
			this.addAgentAttributesToEvent(evt);

			this.getChat().resetReconnectFlag(save);

			if (typeof(eventData) == "object") {
				evt.absorb(eventData);
			} else if (typeof(eventData) == "string") {
				evt.absorb(MI8.JSON.parse(eventData));
			}
			this._fireEvt(
				function (l, evt) {
					if (l && typeof l.onAgentAssigned == "function") {
						l.onAgentAssigned(evt);
					}
				},
				evt
			);
		} catch (e) {
			ROM.post(urls.loggingURL, {level:LOG_LEVELS.WARN, line: "Failure to fireAgentAssigned: " + cf21(e)});
		}
	};

	/**
	 * Returns true if specified chat type is supported, false otherwise.
	 * @param chatType service type to check support for. See valid values in CHAT_TYPES.
	 * @return true if specified chat type is supported, false otherwise.
	 */
	GR34.prototype.isServiceSupported = function(chatType) {
		return !!this.CHAT_TYPES[chatType];
	};

	/**
	 * Fires the rule for valid embedded theme chats
	 * @param {Object} the event.
	 * @return void.
	 */
	GR34.prototype.onChatClosed = function (evt) {
		if (MM.embeddedTheme.isValid) {
			MM.embeddedTheme.isValid = null;
			var delay = 1000;
			if (this.chatLaunchCounter > this.MAX_NUMBER_OF_EMBEDDED_CHATS_WITHOUT_DELAY) {
				delay = this.chatLaunchTimeoutIncrement.getNextTimeout();
			}
			evt.rule.setTimeout(delay, false);
		}
	};

	/**
	 * Returns true if specified chat type represents a call service.
	 * @param chatType service type to check.
	 * @return true for call types.
	 */
	GR34.prototype.isCallServiceType = function(chatType) {
		return (this.CHAT_TYPES.C2CALL == chatType || this.CHAT_TYPES.POPUP_CALL == chatType);
	};

	/**
	 * Returns true if current chat is started with Virtual Assistant
	 * @return true for VA chats.
	 */
	GR34.prototype.isVAChat = function() {
		var ciData = this.getChatInterfaceData();
		return ciData ? ciData.va == 1 : false;
	};

	/**
	 * Returns true if specified chat type represents a call service.
	 * @return "call" for call chat (click2call and proactive call), "chat" for normal chats
	 * and "virtualAssistant" for chats with Virtual Assistant. If there is no chat returns "null"
	 */
	GR34.prototype.getConversionType = function() {
        if (!!this.chat) {
			if (this.isVAChat()) {
				return "virtualAssistant";
			}
            return this.isCallServiceType(this.getChatType()) ? "call" : "chat";
        } else {
            return null;
        }
	};

	/**
	 * Method checks and returns "in progress" status for specified service type.
	 * @param {String} chatType see CHAT_TYPES
	 * @return {Boolean} true if service of specified type is in progress
	 * @throws error "ServiceTypeNotRecognized" if provided service type is not recognized.
	 */
	GR34.prototype.isServiceInProgress = function(chatType) {
		if (isCEAPIPostChatSurveyMode()) {
			// service is not in progress in ceapi mode, do not trigger rule "700".
			return false;
		}
		var inProgress = false;
		if (!!this.chat) {
			var thisChatType = this.chat.getChatType();
		if (chatType == "ANY") {
			return !inu1(thisChatType);
		}
		if (!this.isServiceSupported(chatType)) {
			throw "ServiceTypeNotRecognized - not supported chat type provided: '" + chatType + "'";
		}

		if (!inu1(chatType)) {
			if(this.isPersistentWindow() && chatType==this.CHAT_TYPES.PERSISTENT){
				inProgress = true;
			}
			else{
				inProgress = (chatType == thisChatType);
			}
		}
		}
		return inProgress;
	};

	/**
	 * Registers flash var functions in this manager.
	 * Flash vars are not sent to controller among other parameters when chat launch is requested.
	 * On callback from server flash vars are appended to other parameters and passed on to Haxe code through
	 * FlashPeer.js
	 * @param fcn function that returns flash vars
	 */
	GR34.prototype.registerFlashvarFcn = function(fcn) {
		this._flashvarFcns.push(fcn);
	};

	/**
	 * Caches InqFramework to enhance client page performance during the chat window loading
	 */
	GR34.prototype.preloadInqFramework = function() {
		var path = this.getInqFrameworkUrl();
		prefetchResource(path, function () {
			lwt12("InqFramework wasn't able to preload from " + path);
		});
	};

	/**
	 * Returns URL of InqFramework which depends on chat type and framework obfuscation level
	 * @return {string}
	 */
	GR34.prototype.getInqFrameworkUrl = function() {
		/** @type {string} */
		var src;
		var serverPath = urls.mediaLaunchCiURL;
		if (site.noJSHosting) {
			serverPath = site.clientStaticUrl;
		}

		var isExternalChat = this.getChatType() === CHM.CHAT_TYPES.EXTERNAL_CHAT;
		var isExternalChatPopup = this.getChatType() === CHM.CHAT_TYPES.EXTERNAL_POPUP_CHAT;
		var isThemeModernCIVersion = this.chat && this.chat.isCIV2Skin();

		/*
		 On preload we don't know if a Business Rules will decide to use civ2 or old mxml.
		 If the modernSkin variable is true and no chat is init load the inqFrameworkService.
		 */
		var isModernSkinNoChatInstance = !isWebSDK && window.parent.v3Lander.modernSkin && this.chat == null;

		if (isExternalChat || isExternalChatPopup || isWebSDK
			|| isThemeModernCIVersion || isModernSkinNoChatInstance
		) {
			src = serverPath + "/InqFrameworkService";
		} else {
			src = serverPath + "/InqFramework";

		}
		src += this.getObfuscationSuffix();
		src += ".js?codeVersion=" + ((v3Lander) ? encodeURIComponent(v3Lander.codeVersion) : "undefined");
		return src;
	};

	/**
	 * Returns text suffix which depends on CI obfuscation level
	 * and will be applied to the InqFramework's URL
	 * @return {string}
	 */
	GR34.prototype.getObfuscationSuffix = function() {
		/** @type {string} */
		var suffix = "";
		switch (getCiObfuscationLevel()) {
			case 1:
				suffix = "-w";
				break;
			case 2:
				suffix = "-s";
				break;
			case 3:
				suffix = (isJsLoggingActive()) ? "-a" : "-qa";
				break;
			case 0:
			default:
				break;
		}
		return suffix;
	};

	GR34.prototype.getCobrowseBannerText = function(){
		return !!this.chat ? this.chat.getCobrowseBannerText() : "";
	};

	GR34.prototype.endCobrowseSessionFromBanner = function(){
		try{
			var parentRef = window.parent;

			if( ! this.isChatInProgress() ){
				parentRef = this.r11bv();
			}
			parentRef.inqFrame.Application.application.customerEndsCobrowse();
		}catch( e ){
			log("We have a cobrowse error"+e);
		}
	};

	/**
	 * Builds and returns flash vars object from all flash vars functions registered in this manager.
	 * @return flash vars object
	 */
	GR34.prototype.getFlashVarData = function() {
		var retval = null;
		if(this._flashvarFcns.length > 0){
			retval = MI8.mixAbsorber({});
			for(var idx = 0; idx < this._flashvarFcns.length; idx++){
				retval.absorb(this._flashvarFcns[idx]());
			}
		}
		return retval;
	};

	/**
	 * Defines and returns agent group ID
	 * @param {object} evt event object
	 * @param {boolean} agentAssignedStage boolean variable, indicates if agent is assigned, passed from the agent-group-id.jsp
	 * @return {number} agent group ID
	 */
	GR34.prototype.getAgentGroupID = function (evt, agentAssignedStage) {
		var agentGroupID = getDefaultAgentGroupId();

		if (this.getChat() && this.getChat().getChatAgentGroupID()) {
			return this.getChat().getChatAgentGroupID();
		}

		if (agentAssignedStage) {
			return agentGroupID;
		}

		if (this.getChat() && this.getChat().getAgentGroupID()) {
			return this.getChat().getAgentGroupID();
		} else if (evt && evt.rule && typeof evt.rule.getAgentGroupID == "function") {
			return evt.rule.getAgentGroupID();
		} else if (this.getLastChat() && this.getLastChat().agentGroupID) {
			return this.getLastChat().agentGroupID;
		}

		return agentGroupID;
	};

	/**
	 * Turns on the beacon flag on postToServer iframe in the corresponding domain.
	 * It is needed to be able to send beacon to the server when corresponding window will be unloaded.
	 *
	 * @see Chat#setCABeacon
	 *
	 * @param {string} action - the action for setting the state of the beacon
	 * @param {object} data - interface for additional data (optionally)
	 */
	GR34.prototype.setCABeacon = function(action, data) {
		if (this.chat) {
			this.chat.setCABeacon(action, data);
		}
	};

    /**
     * Sets the active windowId (master window id) on the server to an active list of ids
     * setCABeacon will remove the window id when a page is unloaded.
     * @see RTDEV-23774
     */
    GR34.prototype.setActiveWindowId = function () {
        if (this.chat) {
            this.chat.setActiveWindowId();
        }
    };

    /**
     * Determines if multiple chats across windows are supported or not.
	 * Currently this is enabled for all chats that are triggered through embedded chats.
     * @see RTDEV-23774
     */
	GR34.prototype.isMultiChatSupported = function () {
		// Currently multi chat will be supported for all the chats that are triggered through embedded chats.
		// TODO: A site level setting that controls multi chat support
		return !!(this.getChat() && this.getChat().getEmbeddedTheme());
	};

	/**
	 * Returns Queue Threshold parameter of Rule (AG/BU if not overridden in rule)
	 * @return {Number} qt, undefined if not set.
	 */
	GR34.prototype.q6t = function() {
		return this.getChat() ? this.getChat().getChatData().qt : null;
	};

	/**
	 * Returns the fallback-agent-group-enabled value specified in <agent-profile/> element
	 * when agent-id or agent-name is specified.
	 * @return boolean true if fallbackAgentGroupEnabled is defined and is true; otherwise returns false.
	 */
	GR34.prototype.getFallbackAgentGroupEnabled = function() {
		var getFallbackAgentGroupEnabled = this.getChat() ? this.getChat().getRule().getFallbackAgentGroupEnabled : undefined;
		return getFallbackAgentGroupEnabled ? getFallbackAgentGroupEnabled() : false;
	};

	/**
	 * Returns the Queue Messaging SpecId for the opened chat.
	 *
	 * @returns {?number}
	 */
	GR34.prototype.getQueueMessagingSpecId = function() {
		if (this.chat && this.chat.chatSpec) {
			return this.chat.chatSpec["qmspec"];
		}
	};

	GR34.prototype.setAdblockOn = function() {
		this.adblockOn = true;
	};

	GR34.prototype.setAdblockOff = function() {
		this.adblockOn = false;
	};

	GR34.prototype.isAdblockOn = function() {
		return this.adblockOn;
	};

	/**
	 * Set engagement attributes to the current chat session and sends customer.customAttribute ETL event.
	 * @param {Object[]} engAttrs
	 */
	GR34.prototype.setEngagementAttributes = function(engAttrs) {
		if (this.chat && engAttrs.length > 0) {
			this.chat.setEngagementAttributes(engAttrs);
			var encodedValues = new Array(engAttrs.length);
			for (var i = 0; i < engAttrs.length; i++) {
				encodedValues[i] = encodeURIComponent(engAttrs[i].name) + "," + encodeURIComponent(engAttrs[i].value) + ",set";
			}
			var data = {
				_domain: "customer",
				evt: "customAttribute",
				attributeType: "engagementAttribute",
				siteID: siteID,
				customerID: Inq.getCustID(),
				chatID: CHM.getLastChatID(),
				attr: encodedValues.join(";")
			};
			ROM.send(urls.logDataURL, data);
		}
	};

	/**
	 * Returns engagement attribute value by their name
	 *
	 * @returns {?string}
	 */
	GR34.prototype.getEngagementAttributeValue = function (attrName) {
		/** @type {object} */
		return this.chat ? this.chat.getEngagementAttributeValue(attrName) : null;
	};

	/**
	 * Returns the value of timeout when chat will be lost due to the disconnection.
	 *
	 * @returns {number}
	 */
	GR34.prototype.getDisconnectionTimeout = function() {
		if (this.chat) {
			return this.chat.getDisconnectionTimeout();
		}
	};

	/**
	 * Returns true if chat is asynchronous.
	 *
	 * @returns {boolean}
	 */
	GR34.prototype.isAsyncChat = function() {
		var chat = this.getChat();
		if (chat) {
			return chat.isAsyncChat();
		}
		return false;
	};

	/**
	 * Getter for enableAgentEncryptedData flag.
	 *
	 * @returns {boolean}
	 */
	GR34.prototype.isEnableAgentEncryptData = function() {
		return site.enableAgentEncryptedData;
	};

	/**
	 * Sets secureWithCustToken flag to chat instance.
	 *
	 * @param {boolean} isSecureWithCustToken
	 */
	GR34.prototype.setSecureWithCustToken = function (isSecureWithCustToken) {
		if (this.chat) {
			this.chat.setSecureWithCustToken(isSecureWithCustToken);
		}
	};

	/**
	 * Sets asyncUnauthUser to true and variable to detect browser closing.
	 * This functionality will work when AsyncUnauthTokenInfoMessage
	 * will be recived from server.
	 */
	GR34.prototype.asyncUnauthUser = function () {
		this.asyncUnauthUserVar.z3(1);
		this.setUpResetChatOnBrowserClose();
		this.cip.z3(1);
	}

	GR34.prototype.resetAsyncUnauthUser = function () {
		if (this.isAsyncUnauthUser()) {
			CONVM.resolveConversation();
		}
	}

	GR34.prototype.resetAsyncUnauthUserVariables = function () {
		this.asyncUnauthUserVar.reset();
		this.cip.reset();
		CONVM.setConversationIDs(null, null);
	}

	GR34.prototype.isAsyncUnauthUser = function () {
		return !!this.asyncUnauthUserVar.getValueOrDefault();
	}

	GR34.prototype.onConversationResolved = function () {
		if (this.isAsyncUnauthUser()) {
			this.resetAsyncUnauthUserVariables();
		}
	}

	GR34.prototype.EVTS = {LAUNCHED:"LAUNCHED",PERSISTENT_PUSH:"PERSISTENT_PUSH",CLOSED:"CLOSED",REQUESTED:"REQUESTED",SHOWN:"SHOWN", ENGAGED:"ENGAGED", BEFORE_CLOSED: "BEFORE_CLOSED"};
	GR34.prototype.PERSISTENT = {PERSISTENT:"persistent",PERSISTENT_COMPLETE:"persistent.complete"};

	/** @type {number} The same value as in ConnectionSweeper on ChatRouter, milliseconds */
	GR34.prototype.TIMEOUT_LATENCY = 30000;

	/** @type {object} Client's disconnection reason */
	GR34.prototype.chatCloseReason = {
		TIMEOUT: "Chat was closed by timeout. ",
		DISCONNECTION: "Chat was closed due to the connection issues. "
	};

	/** @type {number} */
	GR34.prototype.REFRESH_NEW_EMBEDDED_CHAT_DELAY_INCREMENT = 5000;
	/** @type {number} */
	GR34.prototype.MAX_REFRESH_NEW_EMBEDDED_CHAT_DELAY = 60000;
	/** @type {number} */
	GR34.prototype.MAX_NUMBER_OF_EMBEDDED_CHATS_WITHOUT_DELAY = 2;
	/** @type {number} */
	GR34.MODERN_CI_VERSION = 2;

	/**
	 * Manager for C2C and C2Call
	 * @class Manager for C2C and C2Call
	 * @constructor
	 * @param id
	 * @param data
	 * @borrows XJA3#absorb as #absorb
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @borrows Persistable#load as #load
	 * @borrows Persistable#save as #save
	 * @borrows Persistable#getPersistentID as #getPersistentID
	 * @borrows Persistable#agrtyer as #agrtyer
	 * @see XJA3
	 * @see Persistable
	 * @see FM2
	 */
	function X43(id, data){
		this._observable();
		this._frameworkModule(id);
		this.absorb(data);
		this._c2cList = [];
		this.stateVar = null;
		this.sessionVar = null;
		this.requestInProgress = false;
	}

	MI8.prepare(X43).im13(MI8.XJA3).im13(MI8.FM2).im13(MI8.Persistable).im13(MI8.Observable);

	/**
	 * obtains a unique id amongst all Persistable types. This instance returns the FM2 id.
	 */
	X43.prototype.getPersistentID = function(){ return this.getID(); };
	/**
	 * initializes the mgr and readies it's internal state for start. Module
	 * should be ready to start once initialized.
	 */
	X43.prototype.init = X43.prototype.start = function(){
	};

	/**
	 * Reset all C2C each managed by X43).
	 */
	X43.prototype.reset = function () {
		for (var i = 0; i < this._c2cList.length; i++) {
			if (typeof this._c2cList[i] !== "undefined") {
				this._c2cList[i].reset();
				this._c2cList[i].onChatClosed = null;
				delete this._c2cList[i];
			}
		}
	};

	/**
	 * Loads C2C Manager state from cookie data
	 */
	X43.prototype.load = function(){
		var stateData = {};
		var sessionData = {};

		function fixBlockedServicesData() {
			var blocked = {};
			var sessionServices = sessionData["blocked"];
			if(!!sessionServices) {
				for(var sessionService in sessionServices) {
					blocked[sessionService] = sessionServices[sessionService];
				}
			}
			var stateServices = stateData["blocked"];
			if(!!stateServices) {
				for(var stateService in stateServices) {
					blocked[stateService] = stateServices[stateService];
				}
			}
			return blocked;
		}

		this.stateVar = new VER34(this.getID(), {}, resources["state"]);
		this.sessionVar = new VER34(this.getID(), {}, resources["session"]);
		stateData = this.stateVar.z0();
		this.absorb(stateData);
		sessionData = this.sessionVar.z0();
		this.absorb(sessionData);
		// fix blocked services
		if (!!this.blocked) {
			this.blocked = fixBlockedServicesData();
		}
	};

	/**
	 * Persists C2C Manager state to cookies
	 */
	X43.prototype.save = function(){
		var stateData = {};
		var sessionData = {};

		function prepareBlockedServicesData(services) {
			for(var service in services) {
				if(services[service] == 0) {
					if(!sessionData.blocked) {
						sessionData.blocked = {};
					}
					sessionData.blocked[service]=services[service];
				} else if(services[service] == -2){
					// no persistence... page level blocking
				} else {
					if(!stateData.blocked) {
						stateData.blocked={};
					}
					stateData.blocked[service] = services[service];
				}
			}
		}

		if(!!this.blocked) {
			prepareBlockedServicesData(this.blocked);
		}
		try {
			this.stateVar.z3(stateData);
		} catch (e) {
			log("X43.save stateData: " + e);
		}
		try {
			this.sessionVar.z3(sessionData);
		} catch (e) {
			log("X43.save sessionData: " + e);
		}
	};

	X43.prototype.agrtyer = function(){ 
		this.load();
	};

	/**
	 * Blocking C2C services
	 * @param {String} serviceType type of service (C2C, C2CALL, C2WEBRTC)
	 * @param {Number} period period to block
	 */
	X43.prototype.tryue = function(serviceType, period) {
		if(serviceType != GR34.CHM.CHAT_TYPES.C2C && 
				serviceType != GR34.CHM.CHAT_TYPES.C2CALL && serviceType != GR34.CHM.CHAT_TYPES.C2WEBRTC) {return;}
		if (inu1(this.blocked)) {
			this.blocked = {};
		}
		// block the service if it hasn't already been blocked or block duration has been expired
		if (inu1(this.blocked[serviceType]) || (!inu1(this.blocked[serviceType]) && this.blocked[serviceType] < (new Date).getTime())) {
			if (period > 0) {
				var now = new Date();
				period += now.getTime();
			}
			this.blocked[serviceType] = period;
			this.save();
		}
	};

	/**
	 * Unblocking C2C services
	 * @param {String} serviceType type of service (C2C, C2CALL, C2WEBRTC)
	 */
	X43.prototype.unblockService = function(serviceType) {
		if(serviceType != GR34.CHM.CHAT_TYPES.C2C && 
				serviceType != GR34.CHM.CHAT_TYPES.C2CALL && serviceType != GR34.CHM.CHAT_TYPES.C2WEBRTC) {return;}
		if (!inu1(this.blocked) && !inu1(this.blocked[serviceType])) {
			delete this.blocked[serviceType];
		}
		this.save();
	};

	/**
	 * Checks if C2C service blocked
	 * @param {String} serviceType type of service (C2C, C2CALL, C2WEBRTC)
	 */
	X43.prototype.isBlocked = function(serviceType) {
		var blockedValue = false;
		if (!inu1(this.blocked) && !inu1(this.blocked[serviceType])) {
			var now = new Date();
			var toDate = this.blocked[serviceType];
			if (toDate <= 0) { // 0 - session, -1 forever
				blockedValue = true;
			}
			else {
				blockedValue = toDate >= now.getTime();
			}
		}
		return blockedValue;
	};

	/**
	 * Checks if any C2C service blocked
	 */
	X43.prototype.isAnyBlocked = function() {
		if (inu1(this.blocked)) {
			return false;
		}
		if (Object.keys(this.blocked).length > 0) {
			return true;
		}
		return false;
	};

	/**
	 * Launches chat and updates cookies before request chat.
	 * If chat is in progress or clearing cookies was detected then disables c2c and resets chat requests queue
	 * @param {number} idx c2c image index
	 * @param {string=} callThisNumber phone number
	 */
	X43.prototype.launchChat = function (idx, callThisNumber) {
		if (CM.cleaningDetected) {
			this.showDisabledIcon();
		} else {
			CM.requestSessionData(function () {
					if (CHM.isChatInProgress()) {
						var rule = this.getC2C(idx) ? this.getC2C(idx).getRule() : null;
						log("Chat already in progress... rule chat request ignored." + (rule ? " Rule=" + rule.toString() : ""));
						this.showDisabledIcon();
						CHM.resetChatRequestsQueue(rule);
					} else {
						var chatLaunchSource = this.getID() + "#launchChat";
						CHM.removeChatInstance(chatLaunchSource);
						this.agrty(idx, callThisNumber, chatLaunchSource);
					}
				}.bind(this)
			);
		}
	};

	/**
	 * Sends request to TagServer to launch chat after click on C2C
	 * @param {number} idx c2c image index
	 * @param {?string} callThisNumber phone number
	 * @param {string} callerName function which call this one
	 */
	X43.prototype.agrty = function(idx, callThisNumber, callerName) {
		var c2c = this.getC2C(idx);
		if (!c2c) {
			log("can't find c2c " +  idx);
			return;
		}
		delete c2c.lastDat;

		if ((c2c.c2p && c2c.getChatType() != GR34.CHM.CHAT_TYPES.C2CALL) || (callThisNumber!=null&&(!c2c.isClicked()))) {
			if (!isWebSDK) {
				CHM.wecv56(c2c.c2cSpec.chatSpec.chatTheme);
			}
		}
		if (!c2c.isClicked()) {
			this.fireC2CClicked(c2c);
			CHM.request(c2c.getRule(), c2c.getChatType(), c2c.getXmlChatSpec(), callThisNumber || null, c2c.c2p, idx, c2c.useNative, null, callerName);
			c2c.setClicked(true);
			X43.lastusedC2CId = c2c.pageElementID;
			X43.c2cBtnId = null;
		}
		else{
			log("Ignored C2C double click");
		}
	};

	/**
	 * This method is called from c2c click handler presented in WebSDK Bootstrap or CIAPI based chat
	 * @param idx
	 * @param callback
	 */
	X43.prototype.requestExtChat = function(idx, callback) {
		this.getC2C(idx).extJSlaunchCb = callback;
		if (CM.cleaningDetected) {
			/**
			 * this call back is fired when c2c is clicked but some reason chat is still present and needs cleanup. when that happens
			 * callback is fired with state disabled
			 */
			callback({state:"disabled"});
		} else {
			CM.requestSessionData(function () {
					if (CHM.isChatInProgress()) {
						var rule = this.getC2C(idx) ? this.getC2C(idx).getRule() : null;
						log("Chat already in progress... rule chat request ignored." + (rule ? " Rule=" + rule.toString() : ""));
						callback({state:"disabled"});
						CHM.resetChatRequestsQueue(rule);
					} else {
						var chatLaunchSource = this.getID() + "#requestExtChat";
						CHM.removeChatInstance(chatLaunchSource);
						this.agrty(idx, null, chatLaunchSource);
					}
				}.bind(this)
			);
		}
	};
	/**
	 * showDisabledIcon
	 * Forces disabled icon display for each C2C instances.
	 */
	X43.prototype.showDisabledIcon = function() {
		for (var i = 0; i < this._c2cList.length; i++) {
			if (typeof this._c2cList[i] !== "undefined") {
				this.getC2C(i).showDisabledIcon();
			}
		}
	};

	/**
	 * Gets C2C object by index
	 * @param {Number} idx
	 * @return {C2C} C2C instance
	 */
	X43.prototype.getC2C = function(idx) {
		return this._c2cList[idx];
	};

	/**
	 * Sends request to Tag Server to get and show C2C image
	 * @param {(Rule|BusinessRule)} rule
	 * @param {String} chatType
	 * @param {Function} dataFcn
	 * @param {Boolean} clickToPersistent
	 * @param {Boolean} useNative
	 */
	X43.prototype.request = function(rule, chatType, dataFcn, clickToPersistent, useNative) {
		if(this.isBlocked(chatType)) { return; }

		var c2c = new C2C(
			this,
			rule,
			chatType,
			dataFcn,
			clickToPersistent ? clickToPersistent : isC2cPersistent(),
			this.adaCompliant,
			this.ariaEnhanced,
			this.ariaEnhancedChatAvailableMessage,
			this.adaAndroidC2cSupportDomains,
			useNative
		);

		if (c2c.getPlugin()) {
			/**
			 * c2c plugin dynamically loads c2c plugin js from theme folder. This is a new feature to support new c2c types
			 */
			if (CHM.isV3Continue() && typeof c2cPlugin != "undefined") {
                log("Plugin already executed for rule: " + rule.getName());
                this.callC2CRequest(c2c, rule);
                return;
            }

			var pPath = c2c.getPluginPath();
			if (pPath) {
                this._c2cList[c2c.getIdx()] = c2c;
                if (!this.requestInProgress) {
                    this.requestInProgress = true;
                    loadScript(getSkinRootUrl(), pPath, pPath, function () {
                        c2c.request();
                    });
                }
			}
		} else if (isWebSDK || c2c.getDiv()) {
			this.callC2CRequest(c2c, rule);
		} else {
			C2C.IDX--;
			if (c2c.isDivOccupied()) {
				var exposureData = {
					siteID: Inq.getSiteID(),
					customerID: Inq.getCustID(),
					incrementalityID: asi4(),
					sessionID: getSessionID(),
					brID: rule.id,
					group: PM.getVar("incGroup").z0(),
					businessUnitID: rule.getBusinessUnitID(),
					result: "existing_offer",
					rule: rule
				};
				BRM.fireExposureQualifiedEvent(exposureData);
				log("C2C div already occupied: " + rule.getName());
			} else {
				log("C2C div not found for " + rule.getName());
			}
		}
	};

	/**
	 * handles invoking the c2c instance request method only if there is no request in progress
	 * @param {C2C} c2c
	 */
	X43.prototype.callC2CRequest = function(c2c, rule) {
		this._c2cList[c2c.getIdx()] = c2c;
		if (!this.requestInProgress) { // if we are not in progress, start request
			this.requestInProgress = true;
			c2c.request();
		}
		log('X43 request: {ruleName: \"' + rule.getName() + '\"}');
	};
	/**
	 * Request Ext Launcher functionality is mostly same as above c2cmgr.request , mainly the difference comes how the c2c is displayed.
	 * In this case responsibility of displaying the c2c lies with the client. Upon successfull response for requestC2CImageURL ,c2c onRemoteCallback invokes the function
	 * configured in the <ext-c2c-js> tag in the BR
	 *
	 * @param rule
	 * @param chatType
	 * @param dataFcn
	 * @param clickToPersistent
	 */
	X43.prototype.requestExtLauncher = function(rule, chatType, dataFcn, clickToPersistent) {
		if(this.isBlocked(chatType)) { return; }

		var c2c = new C2C(
			this,
			rule,
			chatType,
			dataFcn,
			clickToPersistent ? clickToPersistent : isC2cPersistent(),
			this.adaCompliant,
			this.ariaEnhanced,
			this.ariaEnhancedChatAvailableMessage,
			this.adaAndroidC2cSupportDomains
		);

		c2c.isExtC2C = true;
		this._c2cList[c2c.getIdx()] = c2c;
		if (!this.requestInProgress) { // if we are not in progress, start request
			this.requestInProgress = true;
			c2c.request();
		}

	};

	X43.prototype.nextRequest = function(completedC2C){
		log("C2C request complete for "+completedC2C.getRule().getName());
		this.requestInProgress = false;
		var nextIdx = completedC2C.getIdx()+1; // get the next one
		var nextC2C = this._c2cList[nextIdx];
		// if there is a next one and this is initial C2C request, then request it
		if(!!nextC2C && nextC2C.timeout_id === C2C.INITIAL_TIMEOUT_ID){
			log("Issuing next C2C request for "+nextC2C.getRule().getName());
			this.requestInProgress = true; // request back in progress

            if (nextC2C.getPlugin() && typeof c2cPlugin == "undefined") {
                var pPath = nextC2C.getPluginPath();
                if (pPath) {
                    loadScript(getSkinRootUrl(), pPath, pPath, function () {
                        nextC2C.request();
                    });
                }
            } else {
                nextC2C.request();
            }
		}
	};

	/**
	 * Showing C2Call image button
	 * @param {Number} indx
	 * @param {String} source
	 * @param {Number} left
	 * @param {Number} top
	 * @param {Number} number
	 * @param {Boolean=} show
	 * @param {Boolean=} giveFocus
	 * @param {String} title
	 */
	X43.prototype.showCallButton = function(indx, source, left, top, number, show, giveFocus, title){
		var c2c = this.getC2C(indx) ;
		if (c2c!=null)
			c2c.showCallButton(source, left, top, number, show, giveFocus, title) ;
	};

	/**
	 * Determine whether a potential listener should be added to this object's list of
	 * event listeners. To be a X43 listener, a listener should implement at least
	 * one of the following methods:
	 * 	onC2CDisplayed
	 * 	onC2CClicked
	 *
	 * @param l listener object to check
	 */
	X43.prototype.isListener = function(l){
		return !!(l && (l.onC2CDisplayed || l.onC2CClicked || l.onC2CStateChanged || l.onC2CReadyForSDK));
	};

	/**
	 * TODO: Should be deleted or reworked in RTDEV-30370.
	 * @deprecated
	 */
	X43.prototype.onChatClosed = function() {
		this.clicked = false;
	};

	X43.prototype.fireC2CStateChanged = function(data) {
		var evt = {c2c:data.c2c, oldState:data.oldState, newState:data.newState, rule: data.rule, serviceType: CHM.CHAT_TYPES.C2C, customerID: Inq.getCustID(), data: data.data, bizRuleName: data.rule ? data.rule.getName() : null};
		function f(l, evt) {
			try {
				if (!!l.onC2CStateChanged) {
					l.onC2CStateChanged(evt);
				}
			} catch(e) {
				log("Error firing event fireC2CStateChanged on "+ l.toString()+":"+e);
			}
		}
		this._fireEvt(f, evt);
	};

	/**
	 * Generate various c2c event params
	 * @return {C2C} c2c - c2c object instance
	 */
	X43.prototype.makeC2CEventParams = function (c2c) {
		var evt = MI8.mixAbsorber({
			c2c: c2c,
			rule: c2c.getRule(),
			serviceType: CHM.CHAT_TYPES.C2C,
			customerID: Inq.getCustID(),
			data: c2c.data,
			bizRuleName: c2c.getRule() ? c2c.getRule().getName() : null
		});
		var buID = c2c.getRule() ? c2c.getRule().getBusinessUnitID() : null;
		var agID = c2c.getRule() ? c2c.getRule().getAgentGroupID() : null;
		if (agID && parseInt(agID) > 0) {
			evt.absorb({agentGroupID: agID});
		}
		if (buID && parseInt(buID) > 0) {
			evt.absorb({businessUnitID: buID});
		}

		return evt;
	};

	X43.prototype.fireC2CDisplayed = function(data) {

		var evt = this.makeC2CEventParams(data.c2c);
		function f(l, evt) {
			try {
				if (!!l.onC2CDisplayed) {
					l.onC2CDisplayed(evt);
				}
			} catch (e) {
				log("Error firing event C2CDisplayed on " + l.toString() + ":" + e);
			}
		}
		this._fireEvt(f, evt);
	};

	/**
	 * Invoke the c2c ready for SDK event when chat framework is invoked from within a sandbox iframe
	 * @param {Object} data
	 */

    X43.prototype.fireC2CReadyForSDK = function(data) {

		var evt = this.makeC2CEventParams(data.c2c);
		evt.absorb({isFocus: data.setFocus});
		function f(l, evt) {
			try {
				if (!!l.onC2CReadyForSDK) {
					l.onC2CReadyForSDK(evt);
				}
			} catch (e) {
				log("Error firing event C2CReadyForSDK on " + l.toString() + ":" + e);
			}
		}
		this._fireEvt(f, evt);
    };

	X43.prototype.fireC2CClicked = function(c2c) {
		var evt = this.makeC2CEventParams(c2c);

		function f(l, evt) {
			try {
				if (!!l.onC2CClicked) {
					l.onC2CClicked(evt);
				}
			} catch (e) {
				log("Error firing event C2CClicked on " + l.toString() + ":" + e);
			}
		}
		this._fireEvt(f, evt);
	};

	X43.prototype.relaunchC2cRules = function () {
		if (!isFireC2cRulesOnChatClose()) {
			return;
		}
		this.reset();
		var rules = BRM.getRules();
		for (var i = 0; i < rules.length; i++) {
			var rule = rules[i];
			if (rule.active || typeof rule.tt1 === 'function') {
				var triggers = rule.tt1();
				var pageLandingRule = false;
				for (var j = 0; j < triggers.length; j++) {
					if (triggers[j].id === "onPageLanding") {
						pageLandingRule = true;
					}
				}
				if (pageLandingRule && (rule.ruleType === CHM.CHAT_TYPES.C2C || rule.ruleType === CHM.CHAT_TYPES.EXTERNAL_CHAT || rule.ruleType === CHM.CHAT_TYPES.C2CALL)) {
					var page = LDM.getPage();
					rule.fireRule({page: page, data: page});
				}
			}
		}
	};

	X43.prototype.IMAGETYPES = {disabled: "d", busy: "b", afterHours: "ah", ready: "r"};
	X43.prototype.STATES = {"d" : "chatactive", "b": "busy", "ah": "outofhours", "r": "ready"};
	X43.c2cBtnId = null;

/**
 * af4 creates the instance of ACIF loader to load ACIF only on chat showing.
 * @constructor
 */
function af4() {
	var isACIFOptOut = gc7('ACIF_OPT_OUT', null);
	if (isACIFOptOut) {
		this.preload = function() {};
		this.load = function() {};
		return;
	};

	/** @const {string} */
	var ACIF_IFRAME_ID = "nuance-acif";
	/** @const {string} */
	var ACIF_IFRAME_NAME = "nuance-automaton-frame";

	var ACIF = {};
	var isClientJSHostingEnabled = site.noJSHosting;
	var clientHostedJSRootPath = isClientJSHostingEnabled ? site.clientStaticUrl : null;
	var doc = window.parent.document;
	var baseUrl = isClientJSHostingEnabled
		? site.clientStaticUrl
		: urls.mediaRootURL + '/media/launch';

	/** @type {?HTMLIFrameElement} reference to ACIF's iframe to avoid unnecessary DOM queries */
	var acifIFrame = null;

	ACIF.preAcifJsUrl = (isClientJSHostingEnabled? site.clientStaticUrl : urls.vanityURL + '/tagserver/acif') + '/pre-acif.js';
	ACIF.baseUrl = baseUrl + '/acif';

	this.load = function () {
		if (!!getAcifFrame() || isACIFLoadedFromBR()) {
			return;
		}

		ACIF.isLoadedNatively = true;

		win.inQ = win.inQ || {};
		win.inQ.ACIF = ACIF;

		addListeners();
		loadAcifIframe();
		loadAcifScripts();
	};

	/**
	 * Preloads ACIF's scripts (pre-acif.js, acif.js, acif-configs.js)
	 * to enhance client page performance during chat window rendering
	 */
	this.preload = function() {
		/** @type {Array} */
		var jsUrls = getAcifScriptsUrls();
		jsUrls.forEach(function (scriptUrl) {
			prefetchResource(scriptUrl);
		});
	};

	ACIF.EVM = {
		// The queue will be used to catch any events that are fired before
		// the acif.js is fully loaded.  ACIF will process this queue
		// during framework initialization.
		queue: []
	};

	function addListeners() {
		var events = ['onSkinLoaded', 'onAgentMsg', 'onAgentDataPass', 'onChatClosed'];

		events.forEach(function (eventName) {
			var eventRegistry = {};

			eventRegistry[eventName] = function () {
				var args = Array.prototype.slice.call(arguments);

				if (typeof ACIF.EVM[eventName] !== 'function') {
					ACIF.EVM.queue.push({event: eventName, args: args})
				}
			};

			EVM.addListener(eventRegistry);
		});
	}

	/**
	 * Creates blank IFRAME, if doesn't exist, to store ACIF's JS scripts
	 */
	function loadAcifIframe() {
		if (!getAcifFrame()) {
			/** @type {HTMLIFrameElement} */
			acifIFrame = doc.createElement("iframe");
			acifIFrame.name = ACIF_IFRAME_NAME;
			acifIFrame.id = ACIF_IFRAME_ID;
			acifIFrame.style.display = "none";
			doc.body.appendChild(acifIFrame);
		}
	}

	/**
	 * Loads ACIF's scripts (pre-acif.js, acif.js, acif-configs.js) into {@link acifIFrame}
	 */
	function loadAcifScripts() {
		/** @type {Document} */
		var iframeDoc = getAcifFrame().contentWindow.document;
		/** @type {Array} */
		var jsUrls = getAcifScriptsUrls();
		/** @type {string} */
		var scripts = jsUrls.map(function(src) {
			return "<script src='" + src + "' type='text/javascript' charset='UTF-8'></script>";
		}).join("\n");
		/** @type {string} */
		var html =
			"<!doctype html>" +
			"<html>" +
			"<head>" +
			"</head>" +
			"<body>" + scripts + "</body>" +
			"</html>"
		;
		iframeDoc.open();
		iframeDoc.write(html);
		iframeDoc.close();
	}

	/**
	 * Returns ACIF's iframe from the closure to avoid
	 * unnecessary DOM queries, since range of DOM elements allowed to query
	 * could be limited by the client (e.g. WellsFargo's facade
	 * implementation of {@link getParentElByIDTFacade})
	 * @return {?HTMLIFrameElement}
	 */
	function getAcifFrame() {
		return acifIFrame;
	}

	/**
	 * Returns array with URLs of all ACIF's scripts
	 * @return {Array<string>}
	 */
	function getAcifScriptsUrls() {
		return [
			ACIF.preAcifJsUrl,
			getAcifUrl(),
			getConfigsUrl()
		];
	}

	function getAcifUrl() {
		var version = getVersion('stable', 'acif');

		if (version === 'local') {
			ACIF.baseUrl = 'https://localhost:4200';
			return ACIF.baseUrl + '/acif.js';
		}

		var filename = version === 'debug' ? 'acif-debug.js' : 'acif.js';

		return ACIF.baseUrl + '/' + filename;
	}

	function getConfigsUrl() {
		var configsVersion = getVersion(null, 'configs');

		if (configsVersion === 'local') {
			return 'https://localhost:8080/acif-configs.js'
		} else if (isClientJSHostingEnabled) {
			return ACIF.baseUrl + '/acif-configs.js';
		} else {
			var cdnUrl = urls.mediaSiteURL;
			return cdnUrl + "/assets/automatons/acif-configs.js";
		}
	}

	function getVersion(defaultVersion, appName) {
		var _top = window.parent;

		try {
			_top = window.top;
		} catch (e) {
		}

		var regex = new RegExp('nuance[-_]?' + appName + '[-_]?version=([^&]+)', 'i');
		var storageKey = 'nuance_' + appName + '_version';

		var version =
			(_top.location.href.match(regex) || [])[1]
			|| _top[storageKey]
			|| (sessionStorage ? sessionStorage.getItem(storageKey) : null)
			|| (localStorage ? localStorage.getItem(storageKey) : null)
			|| defaultVersion;

		// Persist the non-default version so that the specified version will
		// continue to load even when navigating to other URLs on the
		// client's website.
		if (version !== defaultVersion) {
			sessionStorage.setItem(storageKey, version);
		}

		return version;
	}
}

	/**
	 * A Chat object represents an active, ongoing chat. It contains a fully formed chatspec with
	 * its appropriate theme.
	 * @param chatData -- contains the following items
	 * 	id
	 * 	rule
	 * 	chatType
	 * 	chatSpec
	 * 	chatMgr
	 *  persistentChat
	 * @borrows XJA3#absorb as #absorb
	 */
	function Chat(chatData){
		this.sesVar = new VER34("chat", {}, resources["session"]);
		this._stage = getParentElByIDTFacade("inqChatStage");
		this._isVisible = false;
		this.dragHandleID = "inqTitleBar";
		this.cd = MI8.clonize(chatData);
		this.rule = null;
		this.agID = null;
		this.agName = null;
		this.vaDataPass = null;
		this.disconnectionTimeout = 0;
		this.BEACON_DATA = "DATA";
		this.windowId = Math.round(Math.random() * 1E8);
		this.agentClosedChat = false;
		/** @type {?string} */
		this.beaconURL = null;
		this.beaconRequest = [];
		CHM.reset();
		SVYM.reset();
	}

	MI8.prepare(Chat).im13(MI8.XJA3);

	/**
	 * This is the name of chat data cookie property to set the flag
	 * meaning that current chat was initialized as Async chat.
	 * @type {string}
	 */
	Chat.ASYNC_CHAT_FLAG = "async";

	/**
	 * sets survey data into the chat data persistence.
	 * @param sdat Object the data for the survey.
	 */
	Chat.prototype.setSurvey = function(sdat){
		if(!!sdat && sdat.id>0){
			this.cd.sid = sdat.id;
			this.save();
		}else{
			log("chat.setSurvey(): Survey data set failed. sdat undefined or invalid sid"+sdat);
		}
	};

	/**
	 * Method that validates instantiation data and initializes internal objects using the that data.
	 * If not data was provided, an attempt to grab data from persistence is made. If no data is found
	 * in persistence, then null value is returned.
	 * @returns fully initialized chat instance if chat data is found and validates. null if neither chat data
	 * nor persistence data is obtained.
	 * @throws Error if validation of data fails.
	 * mpk: Unit tested
	 */
	Chat.prototype.load = function(){
		var cd = this.cd;
		if(inu1(cd)){
			cd = MI8.clonize(this.sesVar.z0());
			if(inu1(cd)){
				return null;
			}
		}
		if(!inu1(cd)){
			cd.aMsgCnt = (inu1(cd.aMsgCnt))?0:cd.aMsgCnt;
			cd.cMsgCnt = (inu1(cd.cMsgCnt))?0:cd.cMsgCnt;
			if (inu1(cd.launchPageId)) {
				cd.launchPageId = LDM.getPageID();
			}
		}
		Chat.validate(cd); // throws here if invalid
		this.cd = cd;
		this.chatSpec = MM.mergeChatSpec(cd.xmlSpec); // reconstitute the chatSpec object
		this.rule = BRM.rb41(cd.ruleID); //look up rule object
		/**
		 * Needs only for chat creating.
		 * @see Chat#setSecureWithCustToken
		 */
		this.setSecureWithCustToken(secureWithCustToken);
		return this;
	};

	/**
	 * Returns data from CI cache data
	 * @return {Object}
	 */
	Chat.prototype.getCiData = function(){
		return !!this.cd?this.cd.ci:{};
	};

	/**
	 * Sets data to CI cache
	 * @param {Object} dat
	 * @param {Boolean} doNotSave do not persist data to cookies
	 */
	Chat.prototype.setCiData = function(dat, doNotSave){
		if(this.cd){
			this.cd.ci = dat;
			if(!doNotSave)
				this.save();
		}
	};

	/**
	 * Updates data in CI cache
	 * @param {Object} data
	 */
	Chat.prototype.updateCiData = function (data) {
		if (this.cd) {
			for (var key in data) {
				if (data.hasOwnProperty(key)) {
					this.cd.ci[key] = data[key];
				}
			}
			this.save();
		}
	};

	/**
	 * Unified factory method for Chat class. Creates and initializes a new chat instance.
	 * @param chatData Object Optional param that contains all the initializing data for the chat.
	 * If null or undefined, an "unprimed" chat instance will be returned that can be loaded from persistence via the load method.
	 * @return Chat A primed but uninitialized chat instance representing an ongoing or new chat.
	 * @see load instance method
	 */
	Chat.unmarshal = function(chatData){
		return new Chat(chatData);
	};

	/**
	 * Increments agent messages count
	 */
	Chat.prototype.bumpAgtMsgCount=function(){
		if(!!this.cd)
			this.cd.aMsgCnt += 1;
	};

	/**
	 * Increments customer messages count
	 */
	Chat.prototype.bumpCustMsgCount=function(){
		if(!!this.cd)
			this.cd.cMsgCnt += 1;
	};

	/**
	 * Returns agent messages count
	 * @return {Number}
	 */
	Chat.prototype.getAgentMsgCnt=function(){
		if(!!this.cd)
			return this.cd.aMsgCnt;
		return 0;
	};

	/**
	 * Returns customer messages count
	 * @return {Number}
	 */
	Chat.prototype.getCustMsgCnt=function(){
		if(!!this.cd)
			return this.cd.cMsgCnt;
		return 0;
	};

	/**
	 * Gets the chat data as a clone. Clone used because external manipulation of the
	 * chat's actual internal data can kill the chat.
	 */
	Chat.prototype.getChatData=function(){
		try{
			// this has the potential to throw "Error: attempt to run compile-and-go script on a cleared scope"
			// See MAINT27-250 for details.
			// TODO: find out why this throws when closing persistent window
			return !!this.cd?this.cd.clone():null;
		}catch(err){
			MI8.clonize(this.cd); // reattach the clone() method with local scope.
			return this.cd.clone(); // try again
		}
	};

	/**
	 * Updates chat data for current chat
	 * @param {Object} chatData
	 */
	Chat.prototype.updateChatData = function (chatData) {
		this.cd = chatData;
	};

	/**
	 * Persist chat data to session cookie
	 */
	Chat.prototype.save=function(){
		this.sesVar.z3(this.cd);
	};

	/**
	 * Returns customer ID
	 * @return {Number}
	 */
	Chat.prototype.getCustID = function(){
		return getCustID();
	};

	/**
	 * Returns chat ID
	 * @return {Number}
	 */
	Chat.prototype.getChatID = function(){
		if(!!this.cd)
			return this.cd.id;
		return null;
	};

	/**
	 * Sets chat ID
	 * @param {string} chatID
	 */
	Chat.prototype.setChatID = function (chatID) {
		if (!!this.cd) {
			this.cd.id = chatID;
		}
	};

	/**
	 * Returns chat type
	 * @return {String}
	 */
	Chat.prototype.getChatType = function() {
		return this.cd.chatType;
	};

	/**
	 *  Returns c2c to persistent flag, it can be overridden in <show-c2c*> tags
	 */
	Chat.prototype.isC2cToPersistent = function() {return this.cd.c2cToPersistent;};

	/**
	 *  Return language specified in the rule or default language
	 */
	Chat.prototype.getLanguage = function() {
		var language;
		try {
			language = this.getRule().getLanguage();
		} catch (e) {
			log("Error while getting language from Rule: \n" + e + "\n");
		}

		/* Double checking since Business rule can have language as an empty string */
		if (!language) {
			language = getDefaultLanguage();
		}

		return language;
	};

	// TODO check is this still relevant
	Chat.prototype.onLocalCallback = function(){
		try {
			this.show();
		} catch(e) {
			log("Error in above code: \n" + e + "\n" + data);
		}
	};

	/**
	 * Returns rule which started this chat
	 * @return {Rule}
	 */
	Chat.prototype.getRule = function() {
		return this.rule;
	};

	/**
	 * getRuleId getter for rule id,
	 * saved in the chat context,
	 * if not there, then get it from the rule
	 * The rule can get stale.
	 * On IE in pop-out mode (persistent) the rule can become unusable when:
	 * 1) the client window (parent.opener) is closed
	 * At creation of the persistent window we know that we have a client window
	 * So we get the ruleId and ruleName at that time
	 * @return the textual rule id
	 * @see constructor for chat (function Chat)
	 * @see getRuleName
	 * @see http://dev.inq.com/jira/browse/MAINT22-213
	 */
	Chat.prototype.getRuleId = function() {
		var ruleID = this.rule.getID();
		return !!ruleID?ruleID:"";
	};

	/**
	 * getRuleName getter for rule id,
	 * saved in the chat context,
	 * if not there, then get it from the rule
	 * The rule can get stale.
	 * On IE in pop-out mode (persistent) the rule can become unusable when:
	 * 1) the client window (parent.opener) is closed
	 * At creation of the persistent window we know that we have a client window
	 * So we get the ruleId and ruleName at that time
	 * @return the textual rule name
	 * @see constructor for chat (function Chat)
	 * @see getRuleId
	 * @see http://dev.inq.com/jira/browse/MAINT22-213
	 */
	Chat.prototype.getRuleName = function() {
		return this.rule.getName();
	};

	/**
	 * get WindowId
	 * should be used in all the messages to chat router
	 * Unique page ID gives an opportunity to watch if the page instance was changed and handle cases
	 * when customer navigates to new page but we still get message from unloading page.
	 *
	 * @return {number} window id
	 */
	Chat.prototype.getWindowId = function () {
		return this.windowId;
	};

	/** monitorChatActive
	 *  Sets the active flag (inqCA) to "1" or "2".
	 *  When window will be unloaded, the active flag will be turned off
	 *		The non XD chat keeps a flag in the cookie for active chat
	 *		The XD chat can set the cookie flag but cannot unset it before the parent window was closed.
	 *		Therefore we use a workaround to do this in XD mode
	 *			we have an IFRAME set the cookie on, when we launch a chat
	 *			when the client frame closes, we set the cookie off via the "unload" event.
	 *		The cookie manager is used to perform "postRequestToIframeProxy" to send request to IFRAME,
	 *			the IFRAME's source is postToServer.htm and it performs the function "CHATACTIVE"
	 *				the CHATACTIVE:
	 *				1) Sets up flag in the cookie inqCA (for inq Chat Active)
	 *				2) Sets up to catch the event "unload"
	 *				3) Upon unload the cookie inqCA sets flag "0" (chat inactive)
	 */
	Chat.prototype.monitorChatActive = function(){
		if (CM.xd) {
			/* The command is "CHATACTIVE", we give the site id, so it can be suffixed to the cookie name */
			CM.setV3ActiveValue(1);
			// TODO remove true, it is here only for backward compatibility
			var request = [
				"CHATACTIVE",
				"CHATACTIVE",
				Inq.siteID,
				isPersistentWindow(),
				this.getChatData().v3TO,
				true
			];
			CM.postRequestToIframeProxy(request);	/* We tell the CookieManager to post the request to the IFRAME, get'r done */
		} else {
			this.updateCiData({"a": true});
		}
	};

	/** closeChatMonitor
	 * Sets the active flag to "0" via the "unload" event.
	 * When the active flag is zero, it is considered "off".
	 * In XD-mode sends to IFRAME request to make the CA flag set to inactive.
	 * In non-XD-mode sets to cookies flag for active chat to inactive.
	 *
	 * @see  this.monitorChatActive
	 * @see  this.close
	 * @see  postToServer.htm command "CHATACTIVE"
	 */
	Chat.prototype.closeChatMonitor = function(){
		if (CM.xd) {
			// TODO remove true, it is here only for backward compatibility
			/** @type {Array} */
			var request = ["CHATDEACTIVATE", "", Inq.siteID, true];
			CM.setV3ActiveValue(0);
			if (CM.cleaningDetected) {
				// setup the command action to turn off only unload handler without updating of cookie
				request[1] = "UNLOAD_HANDLER";
			}
			CM.postRequestToIframeProxy(request);
		} else {
			var chatData = {};
			chatData["a"] = false;
			chatData["lt"] = Date.now();
			this.updateCiData(chatData);
		}
	};

	/**
	 * Turns on the beacon flag on postToServer iframe in the corresponding domain.
	 * It is needed to be able to send beacon to the server when corresponding window will be unloaded.
	 * CA means "Chat Active".
	 *
	 * @param {string} action - the action for setting the state of the beacon:
	 *              "ACTIVATE" - to activate sending of beacon;
	 *              "DEACTIVATE" - to deactivate sending of beacon;
	 *              "DATA" - to update data value for beacon.
	 * @param {object=} data - interface for additional data
	 */
	Chat.prototype.setCABeacon = function(action, data) {
		var beaconData = {};
		beaconData[KEY_ENGAGEMENT_ID_STRING] = this.getChatID();
		beaconData[KEY_CUSTOMER_ID_STRING] = this.getCustID();
		if (action == this.BEACON_DATA && data) {
			for (var key in data) {
				beaconData[key] = data[key];
			}
		}

		this.beaconURL = CHM.getChatRouterURL() + urls.pageUnloadURL;
		// these parameters only for identification request in access log
		this.beaconURL += "?" + KEY_ENGAGEMENT_ID_STRING + "=" + this.getChatID()
			+ "&" + KEY_CUSTOMER_ID_STRING + "=" + this.getCustID()
			+ "&" + KEY_WINDOW_ID_STRING + "=" + this.getWindowId();

		this.beaconRequest = [
			"BEACON",
			action,
			MI8.JSON.stringify(beaconData),
			this.beaconURL
		];

		PSC.setBeaconData(this.beaconURL, action, this.beaconRequest[2]);
	};

	/**
	 * setActiveWindowId
	 *
	 * public function setActiveWindowId():Void
	 * Adds the window Id to the list of active window Ids on the server for this specific chat.
	 * @see RTDEV-23774: For more details
	 *
	 * @return {void}
	 */
	Chat.prototype.setActiveWindowId = function () {
		if (CHM.isMultiChatSupported()) {
			var data = KEY_ENGAGEMENT_ID_STRING + "=" + this.getChatID() + "&" + KEY_CUSTOMER_ID_STRING + "=" + this.getCustID();
			var url = CHM.getChatRouterURL() + urls.addActiveWindowIdURL
				+ "?" + KEY_WINDOW_ID_STRING + "=" + this.getWindowId();
			var id = generateRequestId("addActiveWindowId");
			ROM.sendToChatrouter(url, data, id);
		}
	};

	/**
	 * Shows chat window
	 */
	Chat.prototype.show = function() {
		var type = this.getChatType();
		if (CHM.resetChatOnBrowserClose) {
			CHM.cip.z3(1);
		}
		if (this.chatSpec!=null &&
			((type==CHM.CHAT_TYPES.C2C) || (type==CHM.CHAT_TYPES.C2WEBRTC) || (type==CHM.CHAT_TYPES.PERSISTENT)) && this.isC2cToPersistent()) {

			/*
			 * By checking for r11bv only when we already have v3C2cPersistent
			 * set to true we save a pop up appearing and disappearing. Better user
			 */
			if( ! CHM.r11bv() ){
				CHM.popOutChat(true);
				return;
			}
		}


		/* Prevent the DIV chat rendering(showing) when chat was started in persistent window for DIV layer only.
		 * The problem is reproducible for IE in quirks mode. The reason of the problem for the mentioned case:
		 * double send of the POSTBR30 message between frames/windows because of SYNCHRONOUS work of function
		 * `postMessage` in quirks IE mode for old browsers. `postMessage` works ASYNCHRONOUS mode for modern
		 * browsers and no double message spamming.
		 * Fix is only for IE in quirks mode.
		 * The Fix can be done in several ways but other solutions are not acceptable for now.
		 * 1) Asynchrony emulation can be done with help of setTimeout when postMessage is performed in
		 *    LR45#sendRequest. Disadvantage: when pageUnload is fired then all timeouts(timers) are stopped
		 *    and never executed in opposite to postMessage.
		 * 2) Asynchronous like way for the sending only POSTBR30 message in RM91#post. Disadvantage:
		 *    potential problems with proactive chats. Also possible problems from the 1st way.
		 *
		 * Summary:
		 *  - we need to draw skin only once per click
		 *  - only for persistent window when on the page is used click-to-persistent button (C2C-to-persistent)
		 */

		if(this.cd.launchNative) {
			if(type == CHM.CHAT_TYPES.C2C || type == CHM.CHAT_TYPES.POPUP) {
				if(typeof NuanIJSFBridge != "undefined" || getIOSNativeSDKInstance()){
					FP.launchNativeSDK({});
					return;
				}
			}
		}


		if ((type != CHM.CHAT_TYPES.C2C && type != CHM.CHAT_TYPES.PERSISTENT)
			// Only C2C and PERSISTENT must satisfy next 2 conditions
			|| !this.isC2cToPersistent() || isPersistentWindow()
		) {
			var scriptObj = this.preloadChat();
			if (type == CHM.CHAT_TYPES.C2WEBRTC) {
				var _pWin = window.parent;
				var isIOSusingSDK = _pWin.webkit && _pWin.webkit.messageHandlers && _pWin.webkit.messageHandlers.tcrtc;
				if (!isIOSusingSDK && !window.parent.NuanRTCSDK)
					this.preloadVidyo();
			}

			this.monitorChatActive();
			FP.startChatInterface();
			var useCiv2Skin = this.isCIV2Skin();
			if (type == CHM.CHAT_TYPES.EXTERNAL_CHAT) {
				var chat = C2CM.getC2C(CHM.c2cIdx);
				var cb = chat && chat.extJSlaunchCb;
				external.bind(this)(cb);
			} else if (type == CHM.CHAT_TYPES.EXTERNAL_POPUP_CHAT) {
				if (isWebSDK) {
					FrameBridge.postMessageToBootStrap("PROACTIVE_CHAT_LAUNCH", {state: "show"});
				} else {
					external.call(this, EVM.fireCustomEvent.bind(EVM, "externalPopup", this.rule));
				}
			} else if (isWebSDK || useCiv2Skin) {
                /**
                 * if it is a civ2 skin and if chat is already is visible to customer or if chat is lauched as part of proactive chat
                 * and c2c plugin is used ie present in storage and to double check if plugin is not already loaded.
                 * If all above is true then loaded the plugin mentioned in pn variable
                 */
                var civ2ChatVisible = CHM.isV3Continue() || type == CHM.CHAT_TYPES.POPUP;
                var usePlugin = this.chatSpec.pn !== undefined;
                var pluginNotLoadedYet = typeof c2cPlugin == "undefined";
                if (useCiv2Skin
                    && civ2ChatVisible
                    && usePlugin
                    && pluginNotLoadedYet
                ) {
                    var skinPath = getSkinRootUrl() + getThemeName();
                    var embeddedFile = "/" + this.chatSpec.pn + ".js";
                    loadScript(skinPath, embeddedFile, embeddedFile, function () {
                        external.call(this);
                    }.bind(this));
                } else {
                    external.call(this);
                }
			}
		}

		function external(cb) {
			var _that = this;
            if (typeof Application !== "undefined") {
                // Need to clear Application.main call in initTimer
                if (_that.initTimer) {
                    clearTimeout(_that.initTimer);
                }
                setTimeout(function () {
                    _that.setupCIAPIChat(cb);
                }, 100);
            } else if (scriptObj) {
				scriptObj.onload = function () {
					_that.setupCIAPIChat(cb);
				};
				scriptObj.onreadystatechange = function () {
					if (this.readyState === 'complete' || this.readyState === 'loaded') {
						_that.setupCIAPIChat(cb);
					}
				}
			}
		}
	};

	/**
	 * Calls the external c2c launch function and if it is websdk then launches the websdkci
	 * @param {function(Object)} externalLaunchCb
	 */
	Chat.prototype.setupCIAPIChat = function(externalLaunchCb) {
		var _that = this;
		_that.initAppliation();
		externalLaunchCb && externalLaunchCb({state: "show"});
		if (!externalLaunchCb && (isWebSDK|| this.isCIV2Skin())) {
			if (typeof window.messagingApp != "undefined") {
				_that.initWebSKDCI();
			} else {
				var sdkuiScript = _that.loadWebSDKCI();
				sdkuiScript.onload = function () {
					_that.initWebSKDCI();
				};
				sdkuiScript.onreadystatechange = function () {
					if (this.readyState === 'complete' || this.readyState === 'loaded') {
						_that.initWebSKDCI();
					}
				};
			}

		}
	};

	/**
	 * WIll handle the invokation of webSDK/C1V2 messaging window,
	 * in case of webSDK the request is send to WebSDK Bootstrap, Other wise send to CIV2 to messaging frame code.
	 */
	Chat.prototype.initWebSKDCI = function() {
		var spec = this.getChatSpec();
		var pcID = spec && spec.chatTheme.pcsID;
		if (isWebSDK) {
			FrameBridge.positionMessagingWindow(pcID);
		} else if (this.isCIV2Skin()) {
			window.messagingApp.showMessagingFrame(pcID);
		}

	};

	Chat.prototype.isCIV2Skin = function() {
	    return this.chatSpec.chatTheme.sv == GR34.MODERN_CI_VERSION;
    };

	/**
	 * Clean up data when CI closed
	 */
	Chat.prototype.close = function() {
		this.setVisible(false);
		this.closeChatMonitor();						/* If we are XD mode, have the Chat Active monitor decrement the active cookie */
		FP.closeChatInterface();
		this.endChatSession();
		this.sesVar.z3(null);
		this.endCobrowseSession();
		CommunicationMgr.resetNetworkBackup();
	};

	/**
	 * Sets the flag "closed" in current chat instance,
	 * it means that current chat session is ended and chat finished.
	 * This state is saved in the persistent storage.
	 */
	Chat.prototype.endChatSession = function() {
		this.cd.closed = 1; // flag is chat closed
		this.save();
	};

	Chat.prototype.isClosed = function() {
		return !!this.cd.closed;
	};

	Chat.prototype.isVisible = function() {
		return this._isVisible;
	};

	Chat.prototype.setVisible = function(vis) {
		this._isVisible = vis;
	};

	Chat.prototype.getDragHandle = function(){
		return this.dragHandleID;
	};

	Chat.prototype.setDragHandle = function(handleElementID){
		this.dragHandleID=handleElementID;
	};

	Chat.prototype.setResizable = function(){
		if(this._stage==null)
			this._stage = getParentElByIDTFacade("inqChatStage");
		var resizeHandleElem = getParentElByIDTFacade("inqDivResizeCorner");
		if(typeof Inq.Resize != "undefined" && resizeHandleElem) {
			Inq.Resize.__init(resizeHandleElem, this._stage);
		}
	};

	Chat.prototype.setDragable = function(){
		if(this._stage==null)
			this._stage = getParentElByIDTFacade("inqChatStage");
		var dragHandleElem = getParentElByIDTFacade("inqTitleBar");

		try {
			if(typeof Inq.Drag != "undefined" && dragHandleElem)
				Inq.Drag.__init(dragHandleElem, this._stage);
		} catch (e){}
	};

	/**
	 * Sends the transition message to Tagserver and ChatRouter that chat moves to persistent window.
	 * @param persistentState {string} shows the beginning and the completion of the moving to persistent mode.
	 */
	Chat.prototype.transitionMessage = function(persistentState) {
		var params = {
			agentID: this.getAgentID(),
			chatID: this.getChatID(),
			customerID: this.getCustID(),
			transitioning: persistentState,
			siteID: getSiteID()
		};
		ROM.send(urls.baseURL + "/tracking/persistentMsg", params, false, true, 20, 5000);
		if (persistentState.equals(CHM.PERSISTENT.PERSISTENT_COMPLETE) && this.getCiData().eng) {
			var data = {
				"engagementID": this.getChatID(),
				"customerID": this.getCustID()
			};
			var url = CHM.getChatRouterURL() + urls.persistentComplete;
			var id = generateRequestId("persistentComplete");
			ROM.sendToChatrouter(url, data, id);
		}
	};

	/**
	 * Loads persistent chat window
	 * @param {Boolean} transition
	 * @param {Number} top
	 * @param {Number} left
	 * @param {Number} bottom
	 * @param {Number} right
	 * @return {boolean}
	 */
	Chat.prototype.popOutChat = function(transition, top, left, bottom, right){
		if (transition) {
			this.transitionMessage(Inq.CHM.PERSISTENT.PERSISTENT);
		}
		this.setPersistent(true);

		var winTest = CHM.earlyPopout;
		var sHeight = 300;
		var sWidth  = 400;
		var sLeft   = 40;
		var sTop  	= 20;
		var cdata	= this.chatSpec;
		if (cdata && cdata.chatTheme){
			sHeight = cdata.chatTheme.ph;
			sWidth  = cdata.chatTheme.pw;
			sLeft   = cdata.chatTheme.px;
			sTop	= cdata.chatTheme.py;
		}

		var url, target;

		url = Inq.v3framesrc;
		target = "_inqPersistentChat";
		/* Window of the soon-to-be pop-out chat*/
		if (winTest != null && winTest.closed==false) {
			CHM.earlyPopout = null;
			winTest.location = url;
		}
		else {
			CHM.earlyPopout = null;
			var tools = "toolbar=no,location=no,menubar=no,status=no,scrollbars=no" +
						",top=" + sTop +
						",left=" + sLeft +
						",width=" + sWidth +
						",height=" + sHeight +
						",resizable=1";
			try {
				winTest = window.parent.top.open(url, target, tools);
				if (winTest == top) {
					winTest = null;
				}
				cdata.pC = null != winTest;
			} catch (e) {
				winTest = null;
			}
		}
		CHM.popoutWindow = winTest;
		if (winTest){
			if (winTest.focus && !isMobileDevice()) {
				try {
					 winTest.focus();
				}
				catch(e) {}
			}
			cdata.pC = true;
			return true;
		}
		else
			return false;
	};

	Chat.prototype.toString = function () {
		var val = "Chat: ";
		for (var n in this) {
			if (typeof n !== "function" && this.hasOwnProperty(n)) {
				try {
					val += n + "=" + JSON.stringify(this[n]) + ", ";
				} catch (e){}
			}
		}
		return val;
	};

	/**
	 * Builds data sting for CI Flash Vars
	 * @return {string} data: key-value pairs concatenated with &amp;
	 */
	Chat.prototype.getFlashVars = function(){
		var sesVar = PM.getVar("sesID");
		var incVar = PM.getVar("incID");
		var launchPageId = this.getChatData().launchPageId;
		var launchPageMarker = LDM.getPageMarkerById(launchPageId);
		// Introduced by AUTOMATION-122 "Update the engagement.requested event to include the visitorAttributes field":
		// A sample value with two VAs where 1st one is multivalued would be:
		// 'Noteworthy+Content+Groups=Solutions,Advantage,Sales;Readiness+Indicator=Almost+ready'
		var visitorAttributes = encodeURIComponent(VAM.getCopyAsArray(true).join(';'));
		var externalCustomerIDs = encodeURIComponent(VAM.getExternalCustomerIdVisitorAttributesAsString());

		var flashvars = 'continued='+ (CHM.isV3Continue()?'1':'0')+
						'&sessionID=' + (sesVar?sesVar.z0():123456) +
						'&incAssignmentID='+ (incVar?incVar.z0():123456) +
						'&businessUnitID='+ this.getBusinessUnitID() +
						'&chatID=' + this.getChatID() +
						'&customerID=' + this.getCustID() +
						'&agentName=' + encodeURIComponent(this.getAgentName()) +
						'&overrideAgentAlias=' + this.isAgentNameFinal() +
						'&enableAgentEncryptData=' + CHM.isEnableAgentEncryptData() +
						'&scriptID=' + this.getScriptID() +
						'&agentExitLine=' + encodeURIComponent(this.getAgentExitLine()) +
						'&siteID=' + Inq.siteID +
						'&userName=' + encodeURIComponent(this.getCustomerName()) +
						'&chatTitle=' +  this.rule.name +
						'&crHost='+CHM.getChatRouterURL()+
						'&submitURL='+CHM.getChatRouterURL()+
						'&tagServerBaseURL='+ urls.vanityURL +
						'&brID=' + this.rule.id +
						'&agentAttributes='+ encodeURIComponent(this.getAgentAttributesAsString()) +
						'&ruleAttributes='+ encodeURIComponent(this.ra1t()) +
						'&deviceType=' + getDeviceType() +
						'&browserType=' + getClientBrowserType() +
						'&browserVersion=' + cbtv1() +
						'&operatingSystemType=' + getOSType() +
						'&visitorAttributes=' + visitorAttributes +
						'&launchType=' + this.getChatType() +
						'&language=' + this.getLanguage() +
						'&launchPageMarker=' + launchPageMarker +
						'&launchPageId=' + launchPageId +
						'&asyncChat=' + Number(this.isAsyncChat()) +
						'&sendChatRequestOnDemand=' + Number(this.isSendChatRequestOnDemand()) +
						'&' + KEY_WINDOW_ID_STRING + '=' + this.getWindowId() +
						'&qt=' + CHM.q6t() +
						'&isCachePersistentUsed=' + CM47.isCachePersistentEnabled() +
						'&config.fallback-agent-group-enabled=' + CHM.getFallbackAgentGroupEnabled() +
						'&useAgentAlias=' + this.chatSpec.uaa +
						'&overrideChatTheme=' + this.chatSpec.oct;

		if (this.rule["phoneNumber"]!=null)
			flashvars += '&clickToPhone=' + this.rule.phoneNumber;

		var automatonId = this.getAutomatonId();
		if (!inu1(automatonId)) {
			flashvars += '&automatonId=' + automatonId;
			var automatonFields = this.getAutomatonFields();
			if (!inu1(automatonFields)) {
				flashvars += '&automatonFields=' + encodeURIComponent(JSON.stringify(automatonFields));
			}
		}

		var automatonSpecData = this.getAutomatonSpecData();
		if (!inu1(automatonSpecData)) {
			flashvars += '&automatonSpecData=' + encodeURIComponent(MI8.JSON.stringify(automatonSpecData));
		}

		if (externalCustomerIDs) {
			flashvars += '&externalCustomerIDs=' + externalCustomerIDs;
		}

		if (this.getOpenerName()) {
			flashvars += '&openerName=' + this.getOpenerName();
		} else {
			flashvars += '&openerID=' + this.getOpenerID();
		}

		var agID = this.getAgentGroupID();
		if(!inu1(agID)){
			flashvars += '&agID=' + agID;
			var agName = CHM.getAgentGroupNameByID(agID);
			// Although it may not happen, agName can be undefined if agID is not in siteAgentGroups map.
			if (!inu1(agName)) {
				flashvars += '&agName=' + agName;
			}
		}
		var pushNotificationDeviceId = win.nuancePushNotificationDeviceId;
		if (!isWebSDK) {
			pushNotificationDeviceId = pushNotificationDeviceId || window.top.nuancePushNotificationDeviceId || window.nuancePushNotificationDeviceId;
		}


		if (pushNotificationDeviceId) {
			flashvars += '&pushNotificationDeviceID=' + pushNotificationDeviceId;
		}

		var uniqueAgentName = this.getUniqueAgentName();
		if(!inu1(uniqueAgentName)){
			flashvars += '&uniqueAgentName=' + uniqueAgentName;
		}

		var publicAgentId = this.getPublicAgentId();
		if (!inu1(publicAgentId)) {
			flashvars += '&publicUserId=' + publicAgentId;
		}

		var agentAutoOpenerId = this.getAgentAutoOpenerId();
		if (!inu1(agentAutoOpenerId)) {
			flashvars += '&agentAutoOpenerId=' + agentAutoOpenerId;
		}

		var routingAllocSpecs = (this.getRule().gr0 && this.getRule().gr0()) ? String(this.getRule().gr0()) : null;
		if(routingAllocSpecs) {
			flashvars += '&routingAllocSpecs=' + routingAllocSpecs;
		}
		if (this.isAsyncChat()) {
			var asyncSurveySpecID = this.getAsyncSurveySpecID();
			if (!inu1(asyncSurveySpecID)) {
				flashvars += '&asyncSurveySpecID=' + asyncSurveySpecID;
			}
			var showOpenerForEndedConversation = CHM.getChat() && typeof CHM.getChat().getRule().showOpenerForEndedConversation === "function"  && CHM.getChat().getRule().showOpenerForEndedConversation();
			if (showOpenerForEndedConversation) {
				flashvars += '&showOpenerForEndedConversation=' + showOpenerForEndedConversation;
			}

			var ciEnabledOnResolve = CHM.getChat() && typeof CHM.getChat().getRule().ciEnabledOnResolve === "function" && CHM.getChat().getRule().ciEnabledOnResolve();
			if (ciEnabledOnResolve) {
				flashvars += '&ciEnabledOnResolve=' + ciEnabledOnResolve;
			}

			var createNewConversation = this.isCreateNewConversation();
			if (createNewConversation) {
				flashvars += "&createNewConversation=" + createNewConversation;
			}

			var conversationTranscriptMode = CHM.getChat() && CHM.getChat().getRule().conversationTranscriptMode;
			if (conversationTranscriptMode) {
				flashvars += "&conversationMode=" + conversationTranscriptMode;
			}

		}
		var flashvarFcnsData = decodeURIComponent(Inq.ROM.toParamString(CHM.getFlashVarData()));
		if (flashvarFcnsData && flashvarFcnsData.length > 0) {
			flashvars += "&" + flashvarFcnsData;
		}

		if (secureWithCustToken) {
			flashvars += "&secureWithCustToken=true";
			flashvars += "&secureCustToken=" + FP.getPersistentCustomerID();
		}

		var asyncReconnect = this.isAsyncReconnect();
		if (asyncReconnect) {
			flashvars += "&asyncReconnect=" + asyncReconnect;
		}

		if (getUserObject()) {
			flashvars += "&userObject=" + encodeURIComponent(JSON.stringify(getUserObject()));
		}

		flashvars = this._fixFlashVars(flashvars);

		return flashvars;
	};

	/**
	 * Proxy call to BusinessRule.prototype.getAgentAttributesAsString().
	 */
	Chat.prototype.getAgentAttributesAsString = function () {
		try {
			return this.getRule().getAgentAttributesAsString();
		}
		catch(e) {
			log("Error getAgentAttributes " + e);
		}
			return null;
	};

	/**
	 * Proxy call to BusinessRule.prototype.ra1t().
	 */
	Chat.prototype.ra1t = function () {
		try {
			return this.getRule().ra1t();
		}
		catch(e) {
			log("Error getting rule attributes " + e);
		}
		return null;
	};

	Chat.prototype.getSkin = function(){
		/** change "zip" to "mxml"
		*/
		var format = getChatSkinFormat()
		return Inq.urls.skinURL + getThemeName() + "." + format;
	};

	Chat.prototype.getImagePath = function(){
		return Inq.urls.mediaSiteURL + "/flash/";
	};

	/**
	 * @deprecated
	 * preload kms library files.
	 */
	Chat.prototype.preloadKMS = function(){
		if (getParentElByIDTFacade("tc_kms")) {
			return;
		}
		var script = createScriptElement();
		script.src = secureProtocol(urls.vanityURL)+"/tagserver/kms/kms.js";
		script.id = "tc_kms";
		document.body.appendChild(script);
		script.onload = function(){
			var script = createScriptElement();
			script.src = secureProtocol(urls.vanityURL)+"/tagserver/kms/room-app.js";
			document.body.appendChild(script);
		}.bind(this)
	};

	/**
	 * @deprecated
	 */
	Chat.prototype.preloadVidyo = function(){
		if (window.parent.document.getElementById("tc_connector")) {
			return;
		}

		var script = createScriptElement();
		script.src = secureProtocol(urls.vanityURL)+"/tagserver/vidyo/javascript/CallConnector.js";
		script.id = "tc_connector";
		document.body.appendChild(script);
	};

	/**
	 * Injects CIV2 application code to browser
	 * @return {HTMLScriptElement}
	 */
	Chat.prototype.loadWebSDKCI = function(){
		var script = createScriptElement();
        var serverUrl = site.noJSHosting ? site.clientStaticUrl : urls.mediaLaunchCiURL;
        script.src = serverUrl + this.getWebSDKPath();
		document.body.appendChild(script);
		return script;
	};

	Chat.prototype.getWebSDKPath = function () {
        var modernBrowser = ('fetch' in window && 'assign' in Object);
        var wbsdkFileName = modernBrowser ? "/websdkci" : "/websdkci.ie";
        if (!site.JSDebugMode) {
            wbsdkFileName += ".min";
        }
        wbsdkFileName += ".js";
        return wbsdkFileName;
    }

	/**
	 * Preloads the chat haxe framework
	 */
	Chat.prototype.preloadChat = function () {
		if(AL) {
			AL.load();
		}
		var _that = this;
		// Check if the InqFramework JS file is already loaded.
		if (typeof Application !== "undefined") {
			/** Start Application in 50 ms. This time is required for the finishing all deferred actions/calls/loads. */
			_that.initTimer = setTimeout(function () {
				_that.initAppliation();
			}, 50);
		} else {
			var script = createScriptElement();
			script.src = CHM.getInqFrameworkUrl();
			script.id = "inqChatJs";
			// Application.main() was moved here to hide security sensitive functions from public
			script.onload = function () {
				_that.initAppliation();
			};
			script.onerror = function () {
				lwt12(
					"InqFramework wasn't able to load from " + CHM.getInqFrameworkUrl()
				);
			};
			document.body.appendChild(script);
		}

		if (isPersistentWindow() && !window.parent.Inq.datapass  && isSameOrigin()) {
			window.parent.Inq.datapass = window.parent.opener.Inq.datapass;
		}
		return script;
	};

	Chat.prototype.initAppliation = function () {
		if (typeof Application !== "undefined") {
			as17.init(Application.fpInit);
			Application.main();
		}
	}

	/**
	 * private _fixFlashVars,
	 * if clickstream data is missing in the flashvars, insert it
	 * if the useragent data is missing in the flashvars, insert it
	 */
	Chat.prototype._fixFlashVars = function(fv){
		if( undefined == fv )
			return "";
		if( fv.indexOf("&clickStream=")>=0 )
			return fv;
		var extraFlashVars = "";
		var clickStreamData = null;
		try{
			/*If this is a persistent window, get the click stream data from the opener*/
			/** @type {object} */
			var obj;
			if (CHM.isPersistentWindow()) {
				obj = openerCall("getAgentData");
			}
			if (!obj) {
				obj = FP.getAgentData();
			}

			clickStreamData = decodeURIComponent(ROM.toParamString(obj, true));
		} catch (e) {
			log(e);
		}
		if (clickStreamData != null && clickStreamData != "") {
			extraFlashVars += "&clickStream=" + encodeURIComponent(clickStreamData);
		}
		if (navigator.userAgent) {
			extraFlashVars += "&userAgent=" + encodeURIComponent(navigator.userAgent);
		}
		return (fv+extraFlashVars);

	};

	Chat.prototype.isPersistent = function() {
		return this.cd.pC;
	};

	Chat.prototype.setPersistent = function(state) {
		this.cd.pC = state;
	};

	Chat.prototype.getBusinessUnitID = function() {
		var businessUnitID;
		try {
			businessUnitID = this.getRule().getBusinessUnitID();
		} catch (e) {
			log("Error getting chat business unit id: \n" + e + "\n");
		}
		if (inu1(businessUnitID)) {
			businessUnitID = getDefaultBusinessUnitID();
		}
		return businessUnitID;
	};

	Chat.prototype.getAgentGroupID = function() {
		return this.rule == null ? null : this.rule.getAgentGroupID();
	};

	/**
	 * Returns agent name to be routed from business rule agent profile
	 * @return agent name string or null if it is not provided in rule
	 */
	Chat.prototype.getUniqueAgentName = function() {
		return this.rule == null ? null : this.rule.getUniqueAgentName();
	};

	/**
	 * Returns public agent id to be routed from business rule agent profile
	 * @return public agent id string or null if it is not provided in rule
	 */
	Chat.prototype.getPublicAgentId = function() {
		return this.rule && this.rule.getUniquePublicAgentId();
	};

	/**
	 * Returns agent name selected by priority.
	 * @returns {string} agent name or alias.
	 */
	Chat.prototype.getAgentName = function() {
		var agentName = "";
		try {
			var chatSpecAgentName = this.chatSpec.an;
			var chatSpecAgentAlias = this.chatSpec.daa;
			var chatThemeBRAgentName = this.chatSpec.chatTheme.an;
			var chatThemePortalAgentName = MM.getChatTheme(this.chatSpec.chatTheme.id).an;

			if (this.chatSpec.oct) {
				agentName = this.chatSpec.uaa ? chatSpecAgentAlias : chatSpecAgentName;
			}
			if (!agentName) {
				agentName = chatThemeBRAgentName ? chatThemeBRAgentName : chatThemePortalAgentName;
			}
		} catch (e) {
			log(e);
		}
		return agentName;
	};

	/**
	 * Defines if the current agent name is final or not.
	 * If it's not final, it can be overwritten by Skin XML.
	 * An agent name is not final, when it is empty
	 *   or it has lesser precedence than the Skin XML.
	 * @returns {boolean} true if the agent name is final.
	 */
	Chat.prototype.isAgentNameFinal = function() {
		var chatThemeOverridesAlias = !!this.chatSpec && !!this.chatSpec.chatTheme && !!this.chatSpec.chatTheme.oaa;
		var chatSpecOverridesChatTheme = !!this.chatSpec && !!this.chatSpec.oct;
		var chatSpecWithNoDefaultAlias = chatSpecOverridesChatTheme && !!this.chatSpec.uaa && !this.chatSpec.daa;
		var chatSpecWithNoAgentName = chatSpecOverridesChatTheme && !this.chatSpec.uaa && !this.chatSpec.an;
		var chatSpecOverridesAlias = chatSpecOverridesChatTheme && !chatSpecWithNoDefaultAlias && !chatSpecWithNoAgentName && !this.chatSpec.uaa;
		if (chatThemeOverridesAlias || chatSpecOverridesAlias) {
			return true;
		}
		return false;
	};

	Chat.prototype.getAgentID = function() {
		return inu1(this.cd.aid)?"":this.cd.aid;
	};

	/**
	 * Sets owner agent data to IJSF
	 * @param {String} aid agent ID
	 * @param {Number} buID business unit ID
	 * @param {Number} agID agent group ID
	 * @param {String} agentAttrs
	 */
	Chat.prototype.setAgentConfig = function(aid, buID, agID, agentAttrs){
		var agName = CHM.getAgentGroupNameByID(agID);
		this.cd.aid = inu1(aid)?"":aid;
		this.cd.buID = buID;
		this.cd.agID = agID;
		this.cd.agName = agName;
		this.cd.agtAttrs = attributesStringToMap(agentAttrs);
		CHM.getLastChat().businessUnitID = buID;
		CHM.getLastChat().agentGroupID = agID;
		CHM.getLastChat().agentGroupName = agName;
		CHM.getLastChat().agentID = aid;
		CHM.getLastChat().agtAttrs = this.cd.agtAttrs;
	};

	/**
	 * Sets engagement attributes data to IJSF
	 * @param {array} engAttrs
	 */
	Chat.prototype.setEngagementAttributes = function(engAttrs) {
		if (!this.cd.engAttrs) {
			this.cd.engAttrs = {};
		}
		for (var i = 0; i < engAttrs.length; i++) {
			this.cd.engAttrs[engAttrs[i].name] = engAttrs[i].value;
		}
		CHM.getLastChat().engAttrs = this.cd.engAttrs;
		this.save();
	}

	/**
	 * Function to test if agent has specified attribute's value
	 * @param name string name of attribute
	 * @param testValue attribute's value
	 * @return {boolean} result of checking
	 */
	Chat.prototype.testAgentAttributesValue = function(name, testValue){
		var agentAttrs = this.cd.agtAttrs;
		var values = agentAttrs[name];
		if(values){
			for(var i = 0; i < values.length; i++){
				if(values[i] == testValue) {
					return true;
				}
			}
		}
		return false;
	};

	/**
	 * Used to get bussinesUnitID which is associated with current chat.
	 * 
	 * @return {number} bussinesUnitID associated with current chat or
	 * "-1" if bussinesUnitID is not set or {@link this.cd} is not e9.
	 */
	Chat.prototype.getChatBusinessUnitID = function () {
		if (this.cd && !inu1(this.cd.buID)) {
			return this.cd.buID;
		}
		return -1;
	};

	/**
	 * Used to get agentGroupID which is associated with current chat.
	 *
	 * @return {?number} agentGroupID associated with current chat or
	 * null if agentGroupID is not set or {@link this.cd} is not e9.
	 */
	Chat.prototype.getChatAgentGroupID = function () {
		if (this.cd && !inu1(this.cd.agID)) {
			return this.cd.agID;
		}
		return null;
	};

	// TODO check is this still relevant
	Chat.prototype.getChatAgentGroupName = function() {
		return inu1(this.cd.agName) ? null : this.cd.agName;
	};

	Chat.prototype.getScriptID = function() {
		var id = 0;
		try {
			id = this.chatSpec.stId;
		} catch (e) { }
		return id;
	};

	Chat.prototype.getAgentExitLine = function() {
		return !!this.chatSpec.ael ? this.chatSpec.ael : "";
	};

	Chat.prototype.getOpenerID = function() {
		var opener = 0;
		try {
			opener = this.chatSpec.oId;
		} catch(e) {}
		return opener;
	};

	Chat.prototype.getOpenerName = function() {
		return !!this.chatSpec && !!this.chatSpec.oName ? this.chatSpec.oName : null;
	};

	Chat.prototype.getAgentAutoOpenerId = function() {
		return !!this.chatSpec && !!this.chatSpec.aaoId ? this.chatSpec.aaoId : null;
	};

	Chat.prototype.getCustomerName = function() {
		var name = "";
		try {
			name = this.chatSpec.chatTheme.cn;
			if (!name) {
				name = MM.getChatTheme(this.chatSpec.chatTheme.id).cn;
			}
		} catch(e) {}
		return name;
	};

	Chat.prototype.getChatSpec = function() {
		return this.chatSpec;
	};

	Chat.prototype.getAutomatonId = function() {
		try {
			if (!inu1(this.chatSpec.aId)) {
				return this.chatSpec.aId;
			} else if (!inu1(this.chatSpec.aSpecId)) {
				return this.chatSpec.aSpecId;
			}
		} catch (e) {}
		return null;
	};

	Chat.prototype.getAutomatonFields = function() {
		var result = null;
		try {
			if (this.chatSpec && this.chatSpec.aFields) {
				result = this.chatSpec.aFields;
			}
		} catch (e) {}
		return result;
	};

	Chat.prototype.getAutomatonSpecData = function() {
		try {
			if (!inu1(this.chatSpec.aspecData)) {
				return this.chatSpec.aspecData;
			}
		} catch(e) {}
		return null;
	};

	Chat.prototype.endCobrowseSession = function(){
		if (Inq["CBC"]) {
			Inq.CBC.stop();
		}
	};

	Chat.prototype.getCobrowseBannerText = function(){
		return Inq["CBC"] ? Inq.CBC.getCobrowseBannerText() : "";
	};

	/**
	 * Sets the period of chat disconnection in case of issue with connection to the network.
	 *
	 * @param {number} period - defined by client settings, in seconds
	 * @param {number} v3timeout - defined by client settings, in seconds
	 */
	Chat.prototype.setDisconnectionTimeout = function(period, v3timeout) {
		if (period == 0) {
			period = v3timeout + CHM.TIMEOUT_LATENCY / 1000;
		}
		this.disconnectionTimeout = parseInt(period) * 1000;
	};

	/**
	 * Returns the value of timeout when chat will be lost due to the disconnection.
	 *
	 * @returns {number}
	 */
	Chat.prototype.getDisconnectionTimeout = function() {
		if (!this.disconnectionTimeout) {
			var chatData = this.getChatData();
			if (chatData) {
				this.setDisconnectionTimeout(chatData.dcTO, chatData.v3TO);
			}
		}
		return this.disconnectionTimeout;
	};

	/**
	 * Returns the first value of the specific agent attribute if it there's
	 * and empty string if there is no.
	 * For example:
	 *   If string of attributes is "attr=foo,attr=bar",
	 *   then only "foo" will be returned.
	 * @param {string} attrName - name of the agent attribute
	 * @returns {string} - value of the agent attribute
	 */
	Chat.prototype.getAgentAttributeValue = function(attrName) {
		/** @type {object} */
		var agentAttributes = this.cd.agtAttrs;
		if (typeof attrName == "string" || attrName.length != 0 || agentAttributes[attrName]) {
			return agentAttributes[attrName][0];
		} else {
			return "";
		}
	};

	/**
	 * Returns the value of the specific engagement attribute if it there's
	 * and null if there is no.
	 *
	 * @param {string} attrName - name of the engagement attribute
	 * @returns {?string} - value of the engagement attribute
	 */
	Chat.prototype.getEngagementAttributeValue = function(attrName) {
		/** @type {object} */
		var engagementAttributes = this.cd.engAttrs || {};
		if (typeof attrName === "string" && attrName.length != 0 && engagementAttributes[attrName]) {
			return engagementAttributes[attrName];
		} else {
			return null;
		}
	};

	/**
	 * Validates chat initial data parameters
	 * @param {Object} data
	 */
	Chat.validate = function(data){
		var inou = inu1;
		var cerr = "Chat.constructor Err: ";
		if(inou(data))
			throw (cerr+"chatData empty");
		if(!data.chatType)
			throw (cerr+"chat type missing");
		if(!data.xmlSpec)
			throw (cerr+"chat xml data missing");
		if(!data.ruleID)
			throw (cerr+"ruleID missing");
		if(!data.id)
			throw (cerr+"chatID missing");
		if(inou(data.pC))
			throw (cerr+"persistent chat boolean missing");
		if(inou(data.aMsgCnt) || data.aMsgCnt<0 || inou(data.cMsgCnt) || data.cMsgCnt<0){
			throw (cerr+"agt/cust msg cnt not properly initialized");
		}
		if(inou(data.ci)){
			throw (cerr+"ci data missing");
		}
//		TODO: see what the life cycle is like on the cI data structure.
//		if(inu1(data.cI))
//			throw cerr+"persistent v3 chat data missing";
	};

	/**
	 * Checks received data and returns true if chat data is valid
	 * @param {Object} chatData
	 * @return {boolean}
	 */
	Chat.isChatDataValid = function (chatData) {
		try {
			Chat.validate(chatData);
			return true;
		} catch (e) {
			log(e);
			return false;
		}
	};

	/**
	 * Sets the async chat flag to boolean value meaning that
	 * current chat was initialized as Async chat or not.
	 * @param {boolean} asyncFlag
	 */
	Chat.prototype.setAsyncChat = function(asyncFlag) {
		this.cd[Chat.ASYNC_CHAT_FLAG] = !!asyncFlag ? 1 : 0;
		this.save();
	};

	/**
	 * Gets Async chat flag first from the cookie chat data,
	 * and in another case from the chat launch Rule.
	 * @returns {boolean}
	 */
	Chat.prototype.isAsyncChat = function() {
		return !!this.cd[Chat.ASYNC_CHAT_FLAG];
	};

	/**
	 * Gets Async chat flag from the chat launch Rule.
	 * @returns {boolean}
	 */
	Chat.prototype.isAsyncChatRule = function() {
		return typeof this.getRule().asyncChat === "function" && this.getRule().asyncChat();
	};

	/**
	 * Get async survey spec id from BR.
	 * @returns {string|null}
	 */
	Chat.prototype.getAsyncSurveySpecID = function() {
		if (typeof this.getRule().asyncSurveySpecID !== "function") {
			return null;
		}
		return this.getRule().asyncSurveySpecID();
	};

	Chat.prototype.isSendChatRequestOnDemand = function() {
		return this.getRule().sendChatRequestOnDemand;
	};

	Chat.prototype.isCreateNewConversation = function() {
		return typeof this.getRule().createNewConversation === "function" && this.getRule().createNewConversation();
	};

	/**
	 * Setter for variable {@link Chat#agentClosedChat},
	 * which detects if agent closed chat.
	 */
	Chat.prototype.setAgentClosedChat = function(agentClosedChat) {
		this.agentClosedChat = agentClosedChat;
	};

	Chat.prototype.isAgentClosedChat = function() {
		return this.agentClosedChat;
	};

	/**
	 * Returns 'true' if chat session was timed-out.
	 * @return {boolean}
	 */
	Chat.prototype.isTimedOut = function() {
		var now  = Date.now();
		var then = this.getCiData().lt;
		/* For XD mode we can store time of unload only in inqLT
			for the same reason we keep inqCA */
		if (CM.xd) {
			// Should be number because we have sum of two numbers otherwise it will concatenate values as strings.
			var unloadTime = Number(CM.cookies["inqLT"]);
			if (unloadTime && then && unloadTime > then) {
				then = unloadTime;
			}
		}
		then = (then) ? (then + (1000 * this.getChatData().v3TO)) : null;
		return then != null && then < now;
	};

	/**
	 * Getter {@link Chat#vaDataPass}.
	 * @return {Object}
	 */
	Chat.prototype.getVADataPass = function() {
		return this.vaDataPass;
	};

	/**
	 * Setter {@link Chat#vaDataPass}.
	 * @param vaDataPass
	 */
	Chat.prototype.setVADataPass = function(vaDataPass) {
		this.vaDataPass = vaDataPass;
	};

	/**
	 * Getter {@link Chat#cd#rec}
	 * @returns {boolean}
	 */
	Chat.prototype.isAsyncReconnect = function() {
		return !!(this.cd && this.cd.rec);
	};

	/**
	 * Setter {@link Chat#cd#rec}.
	 * @param {boolean} asyncReconnect
	 */
	Chat.prototype.setAsyncReconnect = function(asyncReconnect) {
		if (!!this.cd) {
			this.cd.rec = asyncReconnect;
		}
	};

	/**
	 * Resets reconnect flag in chat data.
	 * @param {boolean=} save - flag for saving reconnect to cookie.
	 */
	Chat.prototype.resetReconnectFlag = function (save) {
		this.cd.rec = false;
		if (save) {
			this.save();
		}
	};

	/**
	 * Setter {@link Chat#cd#swct}.
	 *
	 * This value could be set only once, because this flag will be sent in
	 * chat.request, if it true then all requests should have persistent
	 * customer id, or chatrouter will close chat. If this flag will be set
	 * in middle of chat then chatrouter won't validate persistent customer id.
	 *
	 * Only true should be set, for reducing size of cookies.
	 *
	 * @param {boolean} isSecureWithCustToken
	 */
	Chat.prototype.setSecureWithCustToken = function (isSecureWithCustToken) {
		if (this.cd && isSecureWithCustToken === true) {
			this.cd.swct = 1;
			this.save();
		}
	};

	/**
	 * Getter {@link Chat#cd#swct}
	 *
	 * @returns {boolean}
	 */
	Chat.prototype.isSecureWithCustToken = function() {
		return !!(this.cd && this.cd.swct);
	};

	/**
	 * Getter for embeddedTheme
	 *
	 * @return {?object}
	 */
	Chat.prototype.getEmbeddedTheme = function() {
		return this.chatSpec.embeddedTheme || null;
	};

	/**
	 * Checks CHAT_ENGAGED flag.
	 *
	 * @return {boolean} returns true if chat was engaged
	 */
	Chat.prototype.isEngaged = function () {
		return !!this.getCiData().eng;
	};

function FlashPeer(id, data){
	var postponedAcifCommands = [];
	var nativeTimeout;

	/*
	 * API: Closes the popup chat on behalf of the persistent chat
	 */
	function isV3C2CPersistent(){
		return !!v3C2cPersistent;
	}

	/**
	 * Closes the popup chat.
	 */
	function closePopupChat() {
		CHM.inactivateChat();
	}

	/**
	 * object used to provide mapping of obfuscated IJSF functions to CI
	 * @param ciInit {Function} - actually this is Application.initFP, in future could be added several params to provide access
	 * to avoid publishing FlashPeer's methods in public.
	 */
	as17.init = function (ciInit) {
		ciInit(mc32);
	};

	/**
	 * Close popup chat in opener.
	 * Additionally is changed the context via asynchronous calling.
	 *
	 * @see RTDEV-13321
	 * The reason of the timeout (async):
	 *   inaccessible frame.windowContent object in IE during message posting.
	 * The reason of the issue:
	 *   persistent window context is used for access to opener window posting mechanism.
	 * The error type:
	 *   Operation aborted in LR45.prototype.sendRequest.
	 * With help of async, persistent context is changed onto the opener context,
	 * as result no issue with the posting messages into another frames.
	 */
	function closePopupChatFromPersistent(){
		var result = openerCall("closePopupChat", null, true);
		if (!result) {
			log("Could not close popup chat");
		}
	}

	function isAutoFixPrechatSurvey() {
		var autoFix	= gc7("AUTO_FIX_PRECHAT_SURVAY", null);
		if (autoFix === undefined) autoFix = true; // default to true;
		return autoFix;
	}

    function setData( data ){
		FlashPeer.data = data;
	}

	function resetStopChatClose() {
		CHM.setStopChatClose(false);
	}

	/**
	 * Proxy call to EVM.fireCustomEvent.
	 * Introduced for MAINT23-155 Implement Support to Fire Custom Events from the Client Interface in BR3.0.
	 * Also used by PR-16 Send Baynote Event when recommendation link clicked.
	 * @see EVM.fireCustomEvent
	 */
    function fireCustomEvent(eventName, rule, evt, evtDataSupplementFcn) {
		EVM.fireCustomEvent(eventName, rule, evt, evtDataSupplementFcn);
    }

	/**
	 * Fires custom events with data instance and data object support. This is a more complete execution of the above method.
	 * @param eventName {String} The name of the custom event to be invoked.
	 * @param jsonData {String} Optional jsonized data string. Will be parsed into an object and passed to the EVM.
	 * @param {function=} dataFcn - function which will be executed by the event manager to produce event data.
	 */
	function fireCustomEvt(eventName, jsonData, dataFcn){
		var evt = null;
		if (typeof jsonData == "string") {
			evt = MI8.JSON.parse(jsonData);
		}
		EVM.fireCustomEvent(eventName, null, evt, dataFcn);
	}

	/**
	*API: Sets the memory based cookie (for XD)
	*HTML file postToServer.htm calls back to this routine.
	* @see CM47.prototype.set3rdPartyCookieFromQueue
	*/
	function set3rdPartyCookieFromQueue(){
		CM.set3rdPartyCookieFromQueue();
	}

	/**
	 * Reinitializing chatID for async chat functionality.
	 * <p> For the case when agent leaves chat we need to allow client to continue chatting.
	 * We regenerate chatID but not close chat window (CI) and copy chat data and continue chat.
	 */
	function reinitializeChatWithNewId(){
		CHM.requestChatId();
	}


	/**
	 * Method: closeChat()- Closes the chat and resets chat state in the chat manager.
	 * @see GR34.closeChat
	 */
	function closeChat(isConnected){
		if(getIOSNativeSDKInstance()) {
			isChatProgressInSDK = false;
			setTimeout(function() {
				CHM.closeChat(isConnected);
			},2000)
		} else {
			Inq.log("closeChat");
			CHM.closeChat(isConnected);
		}
	}

	/**
     * Set parameters (auxiliary to survey spec) that will be passed to survey manager on survey launch.
     * This method does not erase previously set parameters rather adds them.
     * Parameters are stored in lastChat object in Chat manager and persisted to inqVital thus available
     * even after chat is closed.
     * Note: Chat manager recreates lastChat object when new chat starts.
     * @param surveyParams object with parameters for survey.
     * @see GR34.setSurveyParams
     */
	function setSurveyAuxParams(surveyParams){
		  CHM.setSurveyAuxParams(surveyParams);
	}

    /**
     * Returns survey parameters (auxiliary to survey spec).
     * @see GR34.getSurveyParams
     */
	function getSurveyAuxParams(){
		  return CHM.getSurveyAuxParams();
	}

    /**
     * Sets clickstream sent flag.
     * Flag is stored in lastChat object in Chat manager and persisted to inqVital thus available
     * even after chat is closed.
     * @see GR34.isClickStreamSent
     */
	function setClickStreamSent(isSent){
		  CHM.setClickStreamSent(isSent);
	}

    /**
     * Returns clickstream sent flag.
     * @see GR34.isClickStreamSent
     */
	function isClickStreamSent(){
		  return CHM.isClickStreamSent();
	}

	function agentSurveyCall(specID){
		  SVYM.showSurvey(specID, "", CHM.getSurveyAuxParams());
	}

	/**
	 * Sets survey config and fires event to load native post chat survey
	 *
	 * @param {string} url
	 */
	function launchNativePostChatSurvey(url) {
		SVYM.launchNativePostChatSurvey(url);
	}

	/**
	 *	Position and size the text input SWF instance
	 *	This is for internationalization
	 *		This instance of the flash gets the text and sends it to the main popup
	 *		This instance MUST be wmode=window
	 */
	function showTextInput(bShow,y,x,w,h){
		CHM.showTextInput(bShow,y,x,w,h);
	}

	/**
	 *	Position and size the the persistent button
	 *	@param x left position in pixels
	 *	@param y top position in pixels
	 *	@param w width in pixels
	 *	@param h width in pixels
	 *	@deprecated
	 */
	function showPersistentButton(x,y,w,h){
	/*
		log("showPersistentButton()");
		CHM.showPersistentButton(x,y,w,h);
	*/
	}

	/**
	 * Sets disconnect cookie to 1
	 */
	function setDisconnectFlag(){
		CHM.setDisconnectFlag(1, CHM.chatCloseReason.DISCONNECTION);
	}

		/** setPersistentButtonDebugActive
	 *	@param active Show the persistent window overlay with a green halo
	 */
	function setPersistentButtonDebugActive(active){
		log("setPersistentButtonDebugActive()");
		CHM.setPersistentButtonDebugActive(active);
	}

	/** hidePersistentButton
	 *	@param active Show the persistent window overlay with a green halo
	 */
	function hidePersistentButton(){
		log("hidePersistentButton()");
		CHM.hidePersistentButton();
	}

	/** showThankyou
	 *	Show the thankyou layer
	 */
	function showThankyou(){
		log("showThankyou()");
		try {
			CHM.closeChat(this,null,"Flash thankyou.");
			return true;
		}
		catch (e) {
			log(e);
		}
		return false ;
	}
	/*
	 * @TODO Ready the chat client to pass chat ID to close operation
	 */
	/**
	 *	hideFramesetChat
	 *	hide the chat
	 */
	function hideFramesetChat(){
		CHM.closeChat();
	}

    /**
     * postRequestToIframeProxy
     * Make a request via iframe-proxy
     *
     * @param {string} serverPath server path
     * @param {array} request request
     * @param {string} id the unique iframe ID
     * @param {Object} context context
     */
    function postRequestToIframeProxy(serverPath, request, id, context){
        LoadM.postRequestToIframeProxy(serverPath, request, id, context);
    }

	/**
	 * Sends request without postToServer.
	 *
	 * @param {string} serverPath - request url
	 * @param {Array} request - request parameters
	 * @param {string} id - request id
	 * @param {Object=} context - request context
	 */
	function sendRequestToServer (serverPath, request, id, context) {
		CommunicationMgr.doCommands(serverPath, request, id, context);
	}

    /**
     * updateFrameName
     * updates iframe-proxy name
     *
     * @param {string} id unique iframe ID to update
     * @param {string} key the key to fetch iframe from storage
     * @deprecated
     */
    function updateFrameName(id, key){
		throw new Error("Browser is not supported. The function updateFrameName is outdated. Please use another implementation.");
    }

    /** setChatBanished
	 *	@param none
	 */
	function setChatBanished(){
		/* TODO: setChatBanished is incomplete
		PM.addVar( new NVPair("banished", true) );*/
	}

	/**
	 *	setAgentConfig
	 *	@param _agentID text agentID (supplied by chat client)
	 *	@param cobrowseEnabled boolean cobrowseEnabled
	 *	@param eventDataStr (opional) text JSON with agent's first & last name
     *  @param buID Agent business Unit ID
     *  @param agID agent group ID
	 */
	function setAgentConfig(_agentID, cobrowseEnabled, eventDataStr, buID, agID){
		CHM.assignAgent(_agentID, false, cobrowseEnabled, eventDataStr, buID, agID);
	}

    /**
     * registerWDMClient add new client to WatchDogManager for health check
     * @param clientID          string for identification of client
     * @param checkInterval     check interval in msec
     * @param isAliveCallback   callback function for health check (@see WDMClient.hx for prototype)
     * @param resetStateCallback callback function for reset client if not alive (@see WDMClient.hx)
     * @return void
     */
    function registerWDMClient(clientID, checkInterval, isAliveCallback, resetStateCallback) {
        WDM.registerClient(clientID, checkInterval, isAliveCallback, resetStateCallback);
    }

    /**
     * unregisterWDMClient remove client from WatchDogManager
     * @param clientID          string for identification of client
     * @return void
     */
    function unregisterWDMClient(clientID) {
        WDM.unregisterClient(clientID);
    }
	/**
	 * Description: Provides data to the flash for passing on to the agent
	 * on chat launch.
	 */
	function getAgentData(){
		var params = MI8.mixAbsorber({});
		try {
			if (typeof self.inqAgentData != "undefined"){
				params.absorb(self.inqAgentData);
			}
			if(!inu1(self.inqData)){
				if(self.inqData instanceof Array){
					//handle arrays through numerical iterator and convert to data
					for(var i = 0; i < self.inqData.length; i++){
						params["data"+i] = self.inqData[i];
					}
				}
				else if (self.inqData instanceof Object){
					params.absorb(self.inqData);
				}
			}
			params["markerHistory"]=LDM.getLandingHistory().join(", ");
			var launchPageId = CHM.getChatData().getChatData().launchPageId;
			params["launchPageMarker"] = LDM.getPageMarkerById(launchPageId);
		} catch (e){}
		return params;
	}

	/**
	 *	onEngaged
	 *	@param event
	 */
	function onEngaged(event) {
		Inq.CHM.fireChatEngaged(event);
		BRM.fireServiceEngagedEvent(event);
	}

	/**
	 * This handler is fired right after drawing of chat interface and before event 'onChatShown'.
	 */
	function onChatLoaded() {
		deferredStartMgrs();
	}

	/**
	 *	Fire handler of skin loaded and chat shown
	 *	@param event
	 */
	function onChatShown(event) {
		if (CHM && CHM.getChat()) {
			CHM.getChat().setVisible(true);
		}
		CHM.fireChatShown(null);
		if (CHM.needToCloseOnChatShown) {
			CHM.closeChat();
			FP.closeChatInterface();
			window["Application"] = null;
			CHM.needToCloseOnChatShown = false;
		}
	}

    /**
     * Fire event before chat window will be closed
     */
    function onBeforeChatClosed(){
        CHM.fireBeforeChatClosed();
    }

	/**
	 *	onInteracted
	 *	@param event
	 */
	function onInteracted(event) {
		BRM.fireServiceInteractedEvent(event);
	}

	/**
	 *	onCustomerMsg
	 *	@param event
	 */
	function onCustomerMsg(eventData) {
		CHM.fireCustomerMsgEvent(eventData);
	}

	/**
	 *	Fires agentDataPassEvent event.
	 *
	 *	@param {string} agentDataPass - agentDataPass value of the agent message.
	 */
	function onAgentDataPass(agentDataPass) {
		CHM.fireAgentDataPassEvent(agentDataPass);
	}

	/**
	 *	Saves vaDataPass and fires vaDataPassEvent event.
	 *
	 *	@param {string} vaDataPass - vaDataPass value of the virtual agent message.
	 */
	function onVADataPass(vaDataPass) {
		CHM.fireVADataPassEvent(vaDataPass);
	}

	/**
	 * flashPeer interface for CHM.fireChatroomReadyEvent() call
	 * The event is used by servers to send a datapass to a chatroom
	 * @param eventData
	 */
	function onChatroomReady(eventData) {
		CHM.fireChatroomReadyEvent(eventData);
	}

	/**
	 *	onAgentMsg
	 *	@param event
	 */
	function onAgentMsg(eventData) {
		CHM.fireAgentMsgEvent(eventData);
	}

    /**
     * Fire event on queue wait messsage.
     */
    function onQueueWaitMsg() {
        CHM.fireQueueWaitMsgEvent();
    }

	function onAssisted() {
		// e9 only for backward compatibility with previous chat client
	}

	/** This calls  doPushToFrameset once the cookies have been committed.
	  * If non xd mode or no cookies on queue, perform doPushToFrameset
	  * If xd mode and cookies on the queue, perform doPushToFrameset upon cookie completion
	  *
	  * Jira Ticket: https://dev.inq.com/jira/browse/PR-101
	  * On IE8 the _sUrl and _sTarget becomes out of scope in the handler,
	  * So since we are dependent on these values, we embed them in the handler code:
	  * We:
	  *  1) Build a function calling the "doPushToFrameset function and embed the parameters in the function
	  *  2) Pass the dynamically created function to the cookie method "whenCookiesCommitted"
	  *  3) We make doPushToFrameset function visible
	  *
	  * @param _sUrl - the url to go to.
	  * @param _sTarget - the target window
	  * @param _fromClick - means that this request is coming from a mouse click and can avoid popup blockers
	  */
	function PushToFrameset(_sUrl, _sTarget, _fromClick) {
		/* NCI-2041: if target is not set, open it in the same window. */
		_sTarget = _sTarget !== "" ? _sTarget : "_self";
		/*
		 * If we expect to open a window, and the "fromClick" specifier is true
		 * Then check the target to see if it goes to a different window (_parent, _self, _top go to this window)
		 * Then check to see if the cookie setting queue is empty, if not pre-popout the window as blank
		 * When the cookies are committed, they will propagate this window with correct url
		 */
		/* is this a different window or tab? */
		if (_fromClick && (_sTarget != "_self") && (_sTarget != "_top") && (_sTarget != "_parent")) {
			if (!(CM).isThirdPartyCookieQueueEmpty()) { /* Are we waiting for cookies */
				var winTarget = null ;
				var tools = "left=0,top=0,toolbar=1,location=1,menubar=1,status=1,scrollbars=1";
				winTarget = window.parent.top.open("about:blank", _sTarget, tools);
				if (null == winTarget) {
					winTarget = window.parent.top.open("about:blank", _sTarget);
				}
			}
		}

		CM.whenCookiesCommitted(function () {
			doPushToFrameset(_sUrl, _sTarget);
		});
	}

	/** This is the original PushToFrameset
	  * It does not wait for cookies to be set.
	  * Please see new PushToFrameset above.
	  *
	  * @param _sUrl - the url to go to.
	  & @param _sTarget - the target window
	  */
	function doPushToFrameset(_sUrl, _sTarget){
		try {
			if (isPersistentWindow()){
				if (isWebSDK) {
					o1p().FrameBridge.pushToFrameSet(_sUrl, _sTarget);
				} else if ("_self" == _sTarget){
					 o1p().top.document.location.href = _sUrl;
				} else {
					var winTarget = null ;
					var tools = "left=0,top=0,toolbar=1,location=1,menubar=1,status=1,scrollbars=1";
					winTarget = window.parent.top.open(_sUrl, _sTarget, tools);
					if (null == winTarget) {
						winTarget = window.parent.top.open(_sUrl, _sTarget);
					}
				}
			}else{
				if (isWebSDK) {
					FrameBridge.pushToFrameSet(_sUrl, _sTarget);
				} else if ("_self" == _sTarget) {
					window.parent.top.document.location.href = _sUrl;
				} else if(CHM.chat && CHM.chat.chatSpec && CHM.chat.chatSpec.chatTheme && CHM.chat.chatSpec.chatTheme.sv == GR34.MODERN_CI_VERSION) {
                    window.parent.top.open(_sUrl, _sTarget);
                } else {
					var winTarget = null ;
					winTarget = window.parent.top.open(_sUrl, _sTarget, "top=0;left=0");
					if (null == winTarget) {
						winTarget = window.parent.top.open(_sUrl, _sTarget);
					}
				}
			}
		}catch (e) {}
	}

	/*
	 * Description: Determines if the loading browser has flash installed
	 *   or not.
	 */
	function browserHasFlash(){
		var flash_version;
		if(navigator.plugins && typeof navigator.plugins["Shockwave Flash"] == "object"){
			var desc = navigator.plugins["Shockwave Flash"].description;
			if(desc){
				var versionStr = desc.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
				var major = parseInt(versionStr.replace(/^(.*)\..*$/, "$1"));
				var build = parseInt(versionStr.replace(/^.*r(.*)$/, "$1"));
				flash_version = parseFloat(major + "." + build);
			}
		}else if(window.ActiveXObject){
			try{
				var flashObj = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
				var desc = flashObj.GetVariable("$version");
				if(desc){
					var versionArr = desc.replace(/^\S+\s+(.*)$/, "$1").split(",");
					var major = parseInt(versionArr[0]);
					var build = parseInt(versionArr[2]);
					flash_version = parseFloat(major + "." + build);
				}
			}catch(e){}
		}

		if(typeof flash_version != "undefined"){
			return (flash_version >= Inq.requiredFlashVersion);
		}

		return false;
	}

	function ForceFocus(){
		try {
			/* following code is to create an object of type flash in order to allow activation of flash */
			try{
				document.createElement("object").setAttribute("type", "application/x-shockwave-flash");
			}catch(er){}
			var clnt = self.document.getElementById("client");
			var nclnt = self.document.getElementById("notclient");
			if (clnt){
				self.focus();
				clnt.focus();
				if (nclnt) {
					nclnt.focus();
				}
			}
		}catch(e){}
	}

	function requestTranscript( _emailAddress, customerName ) {
		var url = urls.vanityURL + "/tagserver/transcriptrequest/logTranscriptRequest";
        var _chatID = CHM.getChatID();
        var _emailSpecID = CHM.getEmailSpecId();
		var _customerName = ( customerName ? customerName : CHM.getCustomerName() );
		var _siteID = Inq.getSiteID();
		var _customerID = Inq.getCustID();
		var _fpSessionID = CHM.getFPSessionID();

		var map = { chatID:_chatID, emailAddress: _emailAddress,
			emailSpecID: _emailSpecID, customerName: _customerName,
			siteID: _siteID, fpSessionID: _fpSessionID, customerID: _customerID
		};
		fireCustomEvent("ChatTranscriptEmailedToCustomer",CHM.getChatData().rule, map);
		ROM.send( url, map );
	}

	function captureEmailAddress( _emailAddress ) {
        var map = {custID:Inq.getCustID(), chatID: CHM.getChatID(), emailAddress:_emailAddress};
		ROM.send(urls.vanityURL + "/tagserver/emailrequest/logEmailAddressCapture", map);
	}

	function startLaunches(isActive){
		if (!isActive) {
			Inq.CHM.continueChatting() ;
		}
	}

	/*
	 * setDragable
	 *  Description: Enables the dragging of the popup chat
	 */
	function setDragable(){
		if (Inq.CHM.chat != null)
			Inq.CHM.chat.setDragable() ;
	}

	/*
	 * setResizable
	 *  Description: Enables the resizability of the popup chat
	 */
	function setResizable(){
		if (Inq.CHM.chat != null)
			Inq.CHM.chat.setResizable() ;
	}

	/*
	 * setV3Data
	 *  Description: sets persistent (session) client data for V3 chat
	 *  @param dictionary object containing data to be set.
	 */
	function setV3Data(dictionary) {
		CHM.setChatInterfaceData(dictionary) ;
	}

	/*
	 * getV3Data
	 *  Description: retrieves persistent (session) client data for V3 chat client
	 *  @returns  object containing data to be set.
	 */
	function getV3Data() {
		return CHM.getChatInterfaceData() ;
	}

	/*
	 * popOutChat
	 *  Description: starts the pop-out (persistent) chat client
	 *  @returns  true/false on success
	 */
	function popOutChat(b, resizable) {
		return  Inq.CHM.popOutChat(b, resizable) ;
	}

	/*
	 * getBaseURL
	 *  Retrieves the base URL for the tagserver using the vanity name
	 *  Example: "clientsname.inq.com/tagserver",
	 *  @param none
	 *  @returns  String containing the base URL for the tagserver using the vanity name
	 */
	function getBaseURL() {
		return  window.Inq.urls.baseURL ;
	}

	/*
	 * getMediaBaseURL
	 *  Retrieves the base URL for the media server
	 *  Example: "media.inq.com/media",
	 *  @param none
	 *  @returns  String containing the base URL for the media server
	 */
	function getMediaBaseURL() {
		return  window.Inq.urls.mediaBaseURL ;
	}

	/**
	 *  Retrieves the xforms vanity domain
	 *  Example: "xformsv3.inq.com",
	 *  @returns  String containing the xforms vanity domain.
	 */
	function getXFormsDomain() {
		return  window.Inq.urls.xFormsDomain;
	}

    /**
     * getVanityUrl
     *  Retrieves the vanity URL
     *  Example: "http://tagserverv3.inq.com",
     *  @param none
     *  @returns  String containing the vanity URL
     */
    function getVanityUrl() {
		return urls.vanityURL;
    }

    /**
     * getChatRouterVanityUrl
     *  Retrieves the chat router vanity domain
     *  Example: "http://chatrouterv3.inq.com",
     *  @param none
     *  @returns  String containing the chat router vanity domain
     */
    function getChatRouterVanityUrl() {
        return CHM.getChatRouterURL();
    }

    /*
      * getTitleBarHeight
      *  Retrieves the height of the dragable area for V3 chat
      *  @returns  number specifiing the height of the draggable area
      */
	function getTitleBarHeight() {
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.tbh;
		} catch(e){}
		return 50 ;
	}

	/*
	 * setPopoutChatPosAnddim
	 * Sets the popoutChat position and dimension.  This function is called from CI/Application.js
	 * after the skin has been loaded.  The values will be from MXML if available otherwise, they
	 * are from DB.
	 * @param x
	 * @param y
	 * @param w
	 * @param h
	 * @returns void
	 */
	function setPopoutChatPosAndDim(x, y, w, h) {
		if (!inu1(x)) {
			Inq.CHM.chat.chatSpec.chatTheme.px = x;
		}
		if (!inu1(y)) {
			Inq.CHM.chat.chatSpec.chatTheme.py = y;
		}
		if (!inu1(w)) {
			Inq.CHM.chat.chatSpec.chatTheme.pw = w;
		}
		if (!inu1(h)) {
			Inq.CHM.chat.chatSpec.chatTheme.ph = h;
		}
	};

	/*
	 * getPopupCloserWidth
	 *  Retrieves the distance from right-hand portion of the draggable area
	 *  		 and the right-hand portion of the client area.
	 *  This is used to make room for the closer button and other buttons as well.
	 *  @returns  a number specifiing the distance between the right edge of the client skin and the right edge of the dragging area.
	 */
	function getPopupCloserWidth() {
	//	Inq.CHM.chat.chatSpec.chatTheme
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.ciw;
		} catch(e){}
		return 50 ;
	}

	/**
	 * getLocalizedMessage
	 * Returns localized text message by key.
	 */
	function getLocalizedMessage(key, ignoreUndefinedText) {
		return Inq.getLocalizedMessage(key, ignoreUndefinedText);
	}

    /**
     * getCobrowseEnableMinimizeRestore
     * RTDEV-15837
     */
    function getCobrowseEnableMinimizeRestore() {
        return Inq.getCobrowseEnableMinimizeRestore();
    }

	/**
	 * gkg23 returns the current conversation tokenId
	 * @private
	 * @return {string}
	 */
	function gkg23() {
		return CONVM.getConversationTokenID();
	}

	/**
	 * gkh24 returns the current conversation objectId
	 * @private
	 * @return {string}
	 */
	function gkh24() {
		return CONVM.getConversationObjectID();
	}

	/**
	 *
	 * getSkinLocation
	 *  Retrieves the position specifier for where to position the client skin
	 *	@returns string specifiing the initial position of the skin
	 *	Posible values are:
	 *   "UPPER CENTER"  "UPPER_CENTER"  "TOP_CENTER"
	 *   "UPPER_RIGHT", "TOP_RIGHT"
	 *   "UPPER_LEFT", "TOP_LEFT"
	 *   "CENTER_LEFT"
	 *   "CENTER_RIGHT"
	 *   "LOWER_LEFT", "BOTTOM_LEFT"
	 *   "LOWER_CENTER", "BOTTOM_CENTER"
	 *   "LOWER_RIGHT", "BOTTOM_RIGHT"
	 *   "POP_UNDER_CENTER"
	 *   "ABSOLUTE"
	 *   "RELATIVE"
	 *   "CENTER"
	 *
	 */
	function getSkinLocation() { //chatData.chat.flash.location
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.pos;
		} catch(e){}
		return "UPPER_LEFT";
	}

	/*
	 * getSkinHeight
	 *  Retrieves the height of the skin below the dragable area
	 *  @returns  number specifiing the height of the skin below the dragable area
	 */
	function getSkinHeight() {
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.dh;
		} catch(e){}
		return 300 ;
	}

	/*
	 * getSkinHeight
	 *  Retrieves the width of the skin
	 *  @returns  number specifiing the width of the skin
	 */
	function getSkinWidth() {
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.dw;
		} catch(e){}
		return 400 ;
	}

	/*
	 * getSkinLeft
	 *  Retrieves the distance from the left edge of for chat skin
	 *  @returns  number specifiing the distance from the left edge of for chat skin
	 */
	function getSkinLeft() {
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.lx;
		} catch(e){}
		return 0 ;
	}

	/*
	 * getSkinTop
	 *  Retrieves the distance from the top edge of for chat skin
	 *  @returns  number specifiing the distance from the top edge of for chat skin
	 */
	function getSkinTop() {
		try {
			return Inq.CHM.chat.chatSpec.chatTheme.ly;
		} catch(e){}
		return 0 ;
	}

	function fireNativeSurveyLaunchEvent() {
		try {
			return SVYM.fireNativeSurveyLaunchEvent();
		} catch(e) {
		}
	}

    /*
     * getPersistentXPos
     * Retrieves the x position of the popoutChat window from chattheme.
     * @returns number specifying the x position if available or 0 otherwise.
     */
    function getPersistentXPos() {
        try {
            return Inq.CHM.chat.chatSpec.chatTheme.px;
        } catch(e){}
        return 0 ;
    }

    /*
     * getPersistentYPos
     * Retrieves the y position of the popoutChat window from chattheme.
     * @returns number specifying the y position if available or 0 otherwise.
     */
    function getPersistentYPos() {
        try {
            return Inq.CHM.chat.chatSpec.chatTheme.py;
        } catch(e){}
        return 0 ;
    }

    /*
     * getPersistentWidth
     * Retrieves the width of the popoutChat window from chattheme.
     * @returns number specifying the width if available or 0 otherwise.
     */
    function getPersistentWidth() {
        try {
            return Inq.CHM.chat.chatSpec.chatTheme.pw;
        } catch(e){}
        return 0 ;
    }

    /*
     * getPersistentHeight
     * Retrieves the height of the popoutChat window from chattheme.
     * @returns number specifying the height if available or 0 otherwise.
     */
    function getPersistentHeight() {
        try {
            return Inq.CHM.chat.chatSpec.chatTheme.ph;
        } catch(e){}
        return 0 ;
    }

	 /**
	 * _getCustGeoData
	 * @returns {JSONObject} current value of customer's geo data.
	 * Format: {"country_code":"BY", "zip_code":"220007", "region_code":"MN"}
	 */
     function _getCustGeoData() {
         return getCustGeoData();
     }

    /*
     * getFlashVars
     *  Retrieves the flash variables (as we used in v2)
     *  @returns  the flash variables
     */
	function getFlashVars() {
		try {
			return Inq.CHM.chat.getFlashVars();
		} catch(e) {
            log("Error obtaining flashvars from Chat object: " + e);
        }
		return "" ;
	}

	/*
	 * getSkin
	 *  Retrieves the URL for the skin mxml file
	 *  @returns  URL for the skin mxml file
	 */
	function getSkin() {
		try {
			return Inq.CHM.chat.getSkin() ;
		} catch(e){}
		var ext = getChatSkinFmt();
		return "TouchCommerce." + ext ;
	}

	function getChatSkinFmt() {
		return getChatSkinFormat();//This is from Inq scope
	}


	function getImagePath() {
		return Inq.CHM.chat.getImagePath();
	}

	function closePersistent(isConnected) { // Inq.GR34.closePersistent();
		CHM.closePersistent(isConnected) ;
	}

	function isThankYouEnabled(){ // var tY:Bool = untyped Inq.GR34.isThankYouEnabled() ;
		return window.Inq.CHM.thankYouEnabled ;
	}

	function tryue(blockDetails) {
		var serviceType = "ALL"; // by default block all types of service
		var period = -1; // by default block forever; ToDo: declare constants for block periods
		if(!inu1(blockDetails)) {

			// ToDo: subject for review: for some reason URL part of chat.pushpage command comes
			// wrapped in parenthesis. Unwrapping here if parenthesis present.
			if ((blockDetails.charAt(0) == '(') && (blockDetails.charAt(blockDetails.length-1) == ')')) {
				blockDetails = blockDetails.substr(1, blockDetails.length - 2);
			}

			var blockParams = MI8.JSON.parse(blockDetails);
			serviceType = blockParams.serviceType;
			period = blockParams.period;
		}
		window.Inq.tryue(serviceType, period);
	}

    function wasSaleAction() {
        return window.Inq.wasSaleAction();
    }

	/**
	 * Set the visibility of Application.
	 * @param visible Boolean indicating whether the Application should be visible.
	 */
	function setVisible(visible) {
		try {
			var app = window["Application"];
			if (app && app.application && app.application.setVisible) {
				app.application.setVisible(visible);
			}
		}
		catch (e) {
			log(e);
		}
	}


    /**
     * Send chat.automaton_response msg
     * @param eventName event name
     * @param data parameters from chat.automaton_request msg
     */
    function sendDTEvent(eventName, data) {
        try {
            var app = window["Application"] ;
            if (app && app.application && app.application.sendDTEvent) {
                // call HAX to send msg
                app.application.sendDTEvent(eventName, data);
            }
        }
        catch (e) {
            log(e);
        }
    }

	/**
	 * Prepares event data and sends event back to CI
	 * @param {String} eventName
	 * @param {HTMLElement} button
	 * @param {Object} data
	 * @return {boolean}
	 */
	function prepareDataAndSendDTEvent(eventName, button, data) {
		return DT.sendDTEvent(eventName, button, data);
	}

	function _executeCustomCommand(params) {
		executeCustomCommand(params);
	}

	function urtvd3 (response) {
		try {
			var data = JSON.parse(response.data);
			var inst = GR34.getInstance();
			inst.urtvd3(data.isActive, data.protoDomain, data.transferURL, data.needNewOpener);
		} catch (e) {
			let12(plc1("Exception during urtvd3 response processing " + e));
		}
	}

	function registerPersistentWindow(){
		return openerCall("registerPersistentWindowInOpener", [parent], false);
	}

	function isPersistentChat(){
		return CHM.isPersistentChat();
	}

	function setPersistentWindowActive(state){
		var inst = GR34.getInstance();
		inst.setPersistentWindowActive(state);
	}

	/**
	 * This function should be called from the persistent chat window.
	 * @param {boolean} isConnected
	 * @return {boolean}
	 */
	function CloseChatFromPersistent(isConnected, conversationResolved) {
		log("@@@CloseChatFromPersistent");
		CHM.r345jjm(isConnected, conversationResolved);
		return true;
	}

	/**
	 * bind - s7 binding of the method and object.
	 *		This saves the the object and the handler in a anonymous object (json)
	 *		The json has a function that recombinds the object and method by the
	 *		use of the browsers "apply" method.
	 * @param handler - the method that is to be made s7 via a closure
	 */
	function bind(handler) {
		var handlerContext = {obj: this, method: handler, safeFunc: function(){
			var closure = arguments.callee.closure;
			return closure.method.apply(closure.obj, arguments);
			}};
		handlerContext.safeFunc.closure = handlerContext
		return handlerContext.safeFunc;
	}

    /**
     * Get Cobrowse module.
     * @return cobrowse module
     */
    function getCBC() {
        var cbc = null;
        if (CHM.isPersistentWindow()) {
            // Get CBC module of main window if the main window is accessible (not reloaded in current moment)
            // otherwise CBC module of persistent window is used (e.g. for cobrowse acceptation). See RTDEV-2059
            var opener = window.parent.opener;
	        try {
		        if (opener) {
			        if ((opener.inqFrame) && (opener.inqFrame.Inq) && (opener.inqFrame.Inq["CBC"])) {
				        cbc = opener.inqFrame.Inq["CBC"];
			        } else {
				        logInfo("opener.inqFrame.Inq['CBC'] is not accessible");
			        }
		        } else {
			        logInfo("No window opener");
		        }
	        } catch (error) {
		        // opener is not null but when you access SECURITY exception can occur.
	        }
        }
        // it's used for div mode or when the main window is reloading (no access to CBC module of the main window)
        if (!cbc) {
            if (window.Inq) {
                if (window.Inq["CBC"]) {
                    cbc = window.Inq["CBC"];
                }
            } else {
	            if (window.inqFrame && window.inqFrame.Inq && window.inqFrame.Inq.CBC){
		            cbc = window.inqFrame.Inq.CBC;
	            }
            }
        }
        return cbc;
    }

	/**
	 * 	Call CI mothod to send message to CoBrowse server and accepts new CoBrowse session
	 * 	See RTDEV-6954.
	 * @param flagStartBenchmarkTest flag to start benchmark test is true
	 * @return {void}
	 */
	function acceptCobrowseInvitation(flagStartBenchmarkTest) {
		if (site.enableCobrowse) {
            inqFrame.com.inq.flash.client.chatskins.CoBrowseMgr.acceptCobInv(flagStartBenchmarkTest);
		} else {
			logError("Cobrowse is not available for this site");
		}
	}

    /**
     * acceptCobrowseInvitationSafe - performs the following:
     * 	 -  gets the CBC and performs the accept
     * @param flagStartBenchmarkTest flag to start benchmark test is true
	 * @return {void}
     */
	function acceptCobrowseInvitationSafe(flagStartBenchmarkTest) {
		if (site.enableCobrowse) {
            var cbc = getCBC();
            if (cbc) {
                cbc.accept(flagStartBenchmarkTest);
            } else {
                logError("CBC is not defined on acceptCobrowseInvitationSafe() method call");
            }
		} else {
			logError("Cobrowse is not available for this site");
		}
	}

	/**
	 * 	acceptCobrowseShareControl - performs the following:
	 * 	 -  gets the CBC and performs the acceptShare
	 * @param flagStartBenchmarkTest flag to start benchmark test is true
	 * @return {void}
	 */
	function acceptCobrowseShareControl(flagStartBenchmarkTest) {
		if (site.enableCobrowse) {
            var cbc = getCBC();
            if (cbc) {
                cbc.acceptShare(flagStartBenchmarkTest);
            } else {
                logError("CBC is not defined on acceptCobrowseShareControl() method call");
            }
		} else {
			logError("Cobrowse is not available for this site");
		}
	}

	function endCobrowseSession() {
		if (!site.enableCobrowse) {
			return;
		}

		var cbc = getCBC();
		if (cbc) {
			cbc.stopQuiet();
		} else {
			lmt12("CBC is not defined on endCobrowseSession() method call", LOG_LEVELS.WARN, null, true);
		}
	}

	/**
	 *
	 * Stop cobrowse session by etl message
	 * Used by flex ai
	 * @return {void}
	 */
	function endCobByEtlEvent(windowId) {
		if (!site.enableCobrowse) {
			return;
		}

		var cbc = getCBC();
		if (cbc) {
			cbc.stopByEtlEvent(windowId);
		} else {
			lmt12("CBC is not defined on endCobrowseSession() method call", LOG_LEVELS.WARN, null, true);
		}
	}

	function isCobrowseEngaged() {
		var cbc = getCBC();
		return site.enableCobrowse && cbc && cbc.isCobrowseEngaged();
	}

	function isSharedControl() {
		var cbc = getCBC();
		return site.enableCobrowse && cbc && cbc.isSharedControl();
	}

    /**
     * Log message in tagserver log.
     * @param message logged message
     * @private
     */
    function logInfo(message) {
        ROM.send(urls.loggingURL, {level:'INFO', line: message + " [chatID=" + CHM.getChatID() + "]"});
    }

	/**
	 * Log data on tagserver.
	 * @param {String} url url for logging
	 * @param {Object} data object ot send data for logging
	 * @private
	 */
	function logData(url, data) {
		ROM.send(url, data);
	}

    /**
     * Log run-time error in tagserver log.
     * Remark: error details are save in tagserver log, but don't show to the user in the console.
     * @param {string} messagePrefix prefix of logged message
     * @param {Error=} e run-time error
	 * @param {string=} chatId
     * @private
     */
	function logError(messagePrefix, e, chatId) {
		var errorMessage = e ? e.message : "";
		var errorDetails = "";
		if (logError.caller) {
			errorDetails += " Caller: " + logError.caller.toString().split("{")[0];
		}
		if (e && e.stack) {
			errorDetails += " Stack: " + e.stack;
		}
		sendMessageToTagServer(plc1(messagePrefix + errorMessage + errorDetails, chatId), "ERROR");
	}

	/**
	 * Logs message to Tag Server for ACIF
	 * @param {string} message message to log
	 */
	function logAcifError(message) {
		if (message) {
			let12(plc1(message));
		}
	}

	/**
	 * Logs message to Tag Server,
	 * @param {string} message message to log
	 */
	function logErrorToServer(message) {
		if (message) {
			let12(message, true);
		}
	}

	/**
	 * Logs message to Tag Server,
	 * @param {string} message message to log
	 */
	function logInfoToServer(message) {
		if (message) {
			logInfoToTagServer(message);
		}
	}

    /** sendText
	 * @param - none
	 * Please see RTDEV-5404
	 */
	function sendText() {
		this.ciSendText(null);
	}

	/** ciSendText
	 * @param - none
	 * This gets overriden in the CI via com.inq.flash.client.control.FlashPeer.setCiFunction
	 * Please see RTDEV-5404
	 */
	function ciSendText() {
		throw("sendText is not defined");
	}

	function ciAcceptCobInv(flagStartBenchmarkTest){
		throw("ciAcceptCobInv is not defined");
	}

	function ciActionBtnCloseChat(){
		throw("ciActionBtnCloseChat is not defined");
	}

	function ciActionBtnCloseThankyou(){
		throw("ciActionBtnCloseThankyou is not defined");
	}

    /**
     * RTDEV-15908
     */
	function ciActionRestoreAndExitChat(){
		throw("ciActionRestoreAndExitChat is not defined");
	}

	function ciDeclineCobInv(){
        throw("ciDeclineCobInv is not defined");
    }

    function ciAcceptCobShareInv(flagStartBenchmarkTest){
        throw("ciAcceptCobShareInv is not defined");
    }

    function ciDeclineCobShareInv(){
        throw("ciDeclineCobShareInv is not defined");
    }

	function ciCheckCobrowseMgrAvalibility() {
		return false;
	}

	function ciAgentEndsCob() {
		throw("ciAgentEndsCob is not defined");
	}

	function ciSendCobrowseEnded() {
		throw("ciSendCobrowseEnded is not defined");
	}

	function ciSendMessageQuietly() {
		throw("ciSendMessageQuietly is not defined");
	}

	function ciFocusCobEndBtn() {
		throw("ciFocusCobEndBtn is not defined");
	}

	function ciCobrowseSuppressedPage() {
		throw("ciCobrowseSuppressedPage is not defined");
	}

	function ciCobrowseFailHandler() {
		throw("ciCobrowseFailHandler is not defined");
	}

	function ciSendResultOfBenchmarkTest() {
		throw("ciSendResultOfBenchmarkTest is not defined");
	}

	function ciSetFocusOnChatInputField() {
		throw("ciSetFocusOnChatInputField is not defined");
	}

	function ciGetCobEndButtonID() {
		throw("ciGetCobEndButtonID is not defined");
	}

    function ciAcceptVideoInv(){
        throw("ciAcceptVideoInv is not defined");
    }

    function ciDeclineVideoInv(){
        throw("ciDeclineVideoInv is not defined");
    }

    function ciStopVideo(){
        throw("ciStopVideo is not defined");
    }

    function setCiFunction(fName, fBody) {
		if ( /^ci/.test(fName) ) {
			this[fName] = fBody;
		} else {
			throw("Error: CI framework function name must start with ci");
		}
	}

	function Glk4(callback) {
		ROM.Glk4(callback);
	}

    /**
     * ciHideLayer
     *
     * Hides the specified layer.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.XFrameWorker.hideLayer is
     * published in XFrameWorker.js class in CI.
     * @param {String} layerID - the layer to hide.
     */
    function ciHideLayer(layerID) {
        log('ciHideLayer: ' + layerID);
        try {
            var hideLayer = window.inqFrame.com.inq.flash.client.control.XFrameWorker.hideLayer;
            if (!inu1(hideLayer)) {
                hideLayer(layerID);
            }
        } catch (e) {
            log('ciHideLayer: hideLayer function was not published in CI: ' + e.message);
        }
    }

    /**
     * ciShowLayer
     *
     * Shows the specified layer.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.XFrameWorker.showLayer is
     * published in XFrameWorker.js class in CI.
     * @param {String} layerID the layer to show.
     * @return {void}
     */
    function ciShowLayer(layerID) {
        log('ciShowLayer: ' + layerID);
        try {
            var showLayer = window.inqFrame.com.inq.flash.client.control.XFrameWorker.showLayer;
            if (!inu1(showLayer)) {
                showLayer(layerID);
            }
        } catch (e) {
            log('ciShowLayer: showLayer function was not published in CI: ' + e.message);
        }
    }

    /**
     * ciGrowLayer
     *
     * Expands the specified layer.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.XFrameWorker.grow is
     * published in XFrameWorker.js class in CI.
     * @param {String} layerID the layer to expand.
     * @return {void}
     */
    function ciGrowLayer(layerID) {
        log('ciGrowLayer: ' + layerID);
        try {
            var growLayer = window.inqFrame.com.inq.flash.client.control.XFrameWorker.grow;
            if (!inu1(growLayer)) {
                growLayer(layerID);
            }
        } catch (e) {
            log('ciGrowLayer: grow function was not published in CI: ' + e.message);
        }
    }

    /**
     * ciShrinkLayer
     *
     * Collapses the specified layer.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.XFrameWorker.shrink is
     * published in XFrameWorker.js class in CI.
     * @param {String} layerID - the layer to collapse.
     * @return {void}
     */
    function ciShrinkLayer(layerID) {
        log('ciShrinkLayer: ' + layerID);
        try {
            var shrinkLayer = window.inqFrame.com.inq.flash.client.control.XFrameWorker.shrink;
            if (!inu1(shrinkLayer)) {
                shrinkLayer(layerID);
            }
        } catch (e) {
            log('ciShrinkLayer: shrink function was not published in CI: ' + e.message);
        }
    }

    /**
     * ciMinimize
     *
     * Minimizes the Chat Interface.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.MinimizeManager.actionMinimize is
     * published in XFrameWorker.js class in CI.
     * @return {void}
     */
    function ciMinimize() {
        try {
            var minimize = window.inqFrame.com.inq.flash.client.control.MinimizeManager.actionMinimize;
            if (!inu1(minimize)) {
                minimize();
            }
        } catch (e) {
            log('ciMinimize: actionMinimize function was not published in CI: ' + e.message, "error");
        }
    }

    /**
     * ciRestore
     *
     * Restores the Chat Interface.
     * Please make sure that window.inqFrame.com.inq.flash.client.control.MinimizeManager.actionRestore is
     * published in XFrameWorker.js class in CI.
     * @return {void}
     */
    function ciRestore() {
        try {
            var restore = window.inqFrame.com.inq.flash.client.control.MinimizeManager.actionRestore;
            if (!inu1(restore)) {
                restore();
            }
        } catch (e) {
            log('ciRestore: actionRestore function was not published in CI: ' + e.message, "error");
        }
    }

	/**
	 * ciIsMinimized
	 *
	 * Minimizes the Chat Interface.
	 * Please make sure that window.inqFrame.com.inq.flash.client.control.MinimizeManager.isMinimized is
	 * published in XFrameWorker.js class in CI.
	 * @return {boolean}
	 */
	function ciIsMinimized() {
		try {
			var isMinimized = window.inqFrame.com.inq.flash.client.control.MinimizeManager.isMinimized;
			if (!inu1(isMinimized)) {
				return isMinimized();
			}
		} catch (e) {
			log('ciIsMinimized: isMinimized function was not published in CI: ' + e.message, "error");
		}
		return false;
	}

	function isLoggingDisabled(){
		return JSLoggingDisabled;
	}

	function preventChatClose(value){
		try {
			var app = window["Application"] ;
			if (app && app.application && app.application.setPreventChatClosed) {
				app.application.setPreventChatClosed(value);
			} else {
				log("ERROR: setPreventChatClosed failed for layer [" + layerID + "]: app.application is not initialized");
			}
		}
		catch (e) {
			log(e);
		}
	}

	/**
	 * Creates new IFrame for XForm
	 * @param div container div where iframe is created
	 * @param url URL where div will be submitted later
	 * @param businessUnitID channel Id if update is required
	 * @param scrolling optional, controlling scrolbars for IFrame, default value is "no"
	 * @param data
	 * @param initiator
	 * @param location
	 * @param initOnLoad optional, indicates whether the automaton is started during initialization chat skin, default value is "false"
	 * @param {String=} method
	 * @return newly created iframe
	 */
	function createXFrame(div, url, businessUnitID, scrolling, data, initiator, location, initOnLoad, method){
		var ldr = new XFormsLoader();
		return ldr.createXFrame(div, url, businessUnitID, scrolling, data, null, initiator, location, initOnLoad, method);
        }

        function getClientPageURL() {
			if(isWebSDK) {
				return window.pageUrl;
			}
            return win.location.href;
        }

	/**
	 * Sets source of XFrame in CI if CI and XFrame are active, otherwise does nothing.
	 * @param layerID id of div to update
	 * @param url new source for layer
	 * @param businessUnitID optional business unit id parameter
	 */
	function updateXFrameFromBizRule(layerID, url, businessUnitID) {
		try {
			var app = window["Application"] ;
			if (app && app.application && app.application.updateXFrameFromBizRule) {
				app.application.updateXFrameFromBizRule(layerID, url, businessUnitID);
            } else {
                log("ERROR: update-xframe failed for layer [" + layerID + "]: app.application is not initialized");
			}
		}
		catch (e) {
			log(e);
		}
	}


	/**
	 * Set source of XFrame and set visible
	 */
	function showAutomaton(layerId, url, businessUnitId, initiator) {
		try {
			var app = window["Application"] ;
			if (app && app.application && app.application.showAutomaton) {
				app.application.showAutomaton(layerId, url, businessUnitId, initiator);//TODO use new parameters
            } else {
                log("ERROR: showAutomaton failed for layer [" + layerId + "]: app.application is not initialized");
			}
		} catch (e) {
			log(e);
		}
	}

	/**
	 * Returns opener's persistent chat window initialization flag.
	 * @return true is a persistent window is initialization for the first time.
	 */
	function isInitializationRequired() {
		var o = o1p();
		if(o && o.Inq.isPersistentInitialization) {
			return o.Inq.isPersistentInitialization;
		}
		return false;
    }

    /**
     * Once persistent chat window initialization, the flag should be set to false.
     */
    function resetInitializationFlag() {
		var o = o1p();
		if(o && o.Inq.isPersistentInitialization) {
			o.Inq.isPersistentInitialization = false;
		}
    }

    var URL_REGEXP_IS_FORM = /(^.*)(forms(v3)?\.inq\.com)/;

	/**
	 * Parse XFrame url into js object {url:...;, params:{...}}
	 * XFrame should contain relative url, without protocol and domain f.e. source="/orbeon/inq/view?dtid=14"
	 * @param url url to parse
	 */
	function parseXFrameUrl(url) {
		var pattern = new RegExp(URL_REGEXP_IS_FORM);
		// Replace if e9 hardcoded xforms domain in mxml (mx:XFrame) with
		// xform vanity domain from DB, OR concat relative url with vanity domain,
        // otherwise don't change URL
        if (url.search(URL_REGEXP_IS_FORM) >=0) {
            url = url.replace(URL_REGEXP_IS_FORM, getXFormsDomain());
        } else if (url.charAt(0) == '/' && url.charAt(1) != '/') {
            url = getXFormsDomain() + url
        }
		var res = url.split('?');
		var params = {};
		if (res[1] != null) {
			var oldParams = res[1].split('&');
			for (var i=0; i< oldParams.length; i++) {
				var nameValue = oldParams[i].split('=');
				params[nameValue[0]] = nameValue[1];
			}
		}
		return {url: res[0], params: params};
	}

    function getPageID() {
        return Inq.LDM.getPageID();
    }

	/**
	 * Identifies this as a portal implementation of Client Interface
	 * @param none
	 * @return true/false if portal implementation
	 */
	function isPortal() {
		return true;
	}

    /**
	 * delegate that gets the Business Unit ID that replaces the channel id
	 * @param none
	 * @return string containing the BusinessUnitID
	 */
	function getBusinessUnitID() {
		return (CHM.getChat()) ? CHM.getChat().getBusinessUnitID() : getDefaultBusinessUnitID() ;
	}

	/**
	 * delegate that gets the Business Unit ID of the current chat owner.  This can be
	 * different from the buID returned from getBusinessUnitID() when the chat was transferred to another agent.
	 * This function is provided to fix scenario #5 problem of RTDEV-14431.
	 * @param none
	 * @return string containing the BusinessUnitID of the Chat owner if available or empty string otherwise.
	 */
	function getChatOwnerBusinessUnitID(){
		return (CHM.getChat() && CHM.getChat().getChatData() && CHM.getChat().getChatData().buID) || "";
	}

	/**
	 * delegate that gets the customer id
	 * @param none
	 * @return string containing the customer id
	 */
	function getCustID(){
		return Inq.getCustID();
	}

	/**
	 * delegate that gets the session id
	 * @param none
	 * @return string containing the session id
	 */
	function getSesID(){
		return getSessionID();
	}

	/**
	 * return browser finger print RTDEV-13942
	 * @param none
	 * @return string containing the session id
	 */
	function getFPSessionID(){
		return CHM.getFPSessionID();
	}

	/**
	 * delegate that gets the assignment id
	 * @param none
	 * @return string containing the assignment id
	 */
	function getIncAsID(){
		return asi4();
	}

	/**
	 * delegate that gets the page marker id
	 * @param none
	 * @return string containing the page marker id
	 */
	function getPageMarker(){
		return LDM.getPageMarker();
	}

	/**
	 * delegate that gets the automaton data map
	 * @param none
	 * @return automaton data map
	 */
	function getAutomatonDataMap(){
		var automatonDataMap = PM.getVar("automatonDataMap");
		return ((automatonDataMap) ? automatonDataMap.z0() : "");
	}

	/**
	 * delegate that gets automaton datapass
	 * @param none
	 * @return automaton datapass
	 */
	function getAutomatonDatapass(){
		var automatonDatapass = PM.getVar("automatonDatapass");
		return ((automatonDatapass) ? automatonDatapass.z0() : "");
	}

	/**
	 * Get the persistent customer id (external, non-Touch Commerce customerID)
	 * @return {string} persistent customer id that set by BR 'set-persistent-customer-id'
	 */
	function getPersistentCustomerID(){
        return objectAsLogString(getPersistCustID(), true);
	}

	/**
	 * Get the authenticated user
	 * @return {?string} authenticated user that set by BR 'set-authenticated-user'
	 */
	function getAuthenticatedUser() {
		if (getAuthUser()) {
			return JSON.stringify(getAuthUser());
		}
		return null;
	}

	/**
	 * delegate that gets the business rule id
	 * @param none
	 * @return business rule id
	 */
	function getBrID(){
		return CHM.getChat().getRule().getID();
	}

	/**
	 * delegate that gets the business rule name
	 * @param none
	 * @return business rule name
	 */
	function getBrName(){
		return CHM.getChat().getRule().getName();
	}

	/**
	 * delegate that gets the agent id
	 * @param none
	 * @return agent id
	 */
	function getAgentID(){
		return CHM.getAgentID();
	}

	/**
	 * Function the gets agName by agID.
	 * @returns agName of available or empty string otherwise.
     */
	function getAgentGroupName() {
		return CHM.getChat() && CHM.getChat().getChatData() &&  CHM.getChat().getChatData().agName || "";
	}

	/**
	 * Delegate that gets agent group display name.
	 * @returns agDisplayName of available or undefined otherwise.
	 */
	function getAgentGroupDisplayName() {
		var agID = CHM.getChat() && CHM.getChat().getChatData() &&  CHM.getChat().getChatData().agID || undefined;
		return CHM.getAgentGroupDisplayNameByID(agID);
	}

	/**
	 * Delegate that gets agent group id .
	 * @returns agentGroupId of available or undefined otherwise.
	 */
	function getAgentGroupId() {
		return  CHM.getChat() && CHM.getChat().getChatData() && CHM.getChat().getChatData().agID || undefined;
	}

	/**
	 * Delegate that gets business unit name.
	 * @returns buName of available or undefined otherwise.
	 */
	function getBusinessUnitName() {
		var buID = CHM.getChat() && CHM.getChat().getChatData() &&  CHM.getChat().getChatData().buID || undefined;
		return CHM.getBusinessUnitNameByID(buID);
	}

	/**
	 * Delegate that gets business unit display name.
	 * @returns buName of available or undefined otherwise.
	 */
	function getBusinessUnitDisplayName() {
		var buID = CHM.getChat() && CHM.getChat().getChatData() &&  CHM.getChat().getChatData().buID || undefined;
		return CHM.getBusinessUnitDisplayNameByID(buID);
	}

    /**
     * This calls supplied function once the cookies have been committed.
     * @param handler {String|Function} function to be executed
     */
    function onCookiesCommitted(handler) {
		var closure;
		if (typeof handler == "string") {
			lwt12("Handler was passed as a string"
				+ " to onCookiesCommitted. Handler " + handler);
			closure = evaluateLegacySettings("function() {" + handler + "}")
		} else {
			closure = handler;
		}
        CM.whenCookiesCommitted(closure);
    }

	/**
	 * This calls supplied function once the cookies have been committed.
	 * @param {number} vcnt - 3rd party cookie counter (for vital)
	 */
	function when3rdPartyCookieCommitted (vcnt) {
		CM.when3rdPartyCookieCommitted(vcnt);
	}

    /**
     * Returns deviceType based on the Inq.getDeviceType() private function.
     *
     */
    function _getDeviceType() {
        var deviceType = "Other";
        try {
            deviceType = getDeviceType();
        } catch (e) {
            log("Error in getDeviceType: " + e);
        }
        return deviceType;
    }

    function _isIOS() {
		return isIOS();
	}

	function _isAndroid() {
		return getOSType().toLowerCase() === "android";
	}

	function _isMobile() {
		return isMobileDevice();
	}

	/**
	 * Returns boolean value to detect if application is initialized or not
	 * @private
	 * @return {boolean}
	 */
	function _isApplicationInitialised() {
		var app = window["Application"];
		if (app && app.application) {
			return true;
		} else {
			log ("ERROR: Application is not initialized");
			return false;
		}
	}

	/**
	 * Checks that device type returning from the Tag Server matches "Phone".
	 *
	 * @see LandingFramework.js function d8t
	 * @return {boolean}
	 */
	function isPhone() {
		return d8t("Phone");
	}

    /**
     * Close persistent window if it open. This function calls when user click to close button
     * before persisnt chat load.
     */
    function closePersistentWindowIfOpen() {
        if(!inu1(CHM.earlyPopout)) {
    		CHM.earlyPopout.close();
    	}
    	if(!inu1(CHM.popoutWindow)) {
    		CHM.popoutWindow.close();
    	}
    }

    function getBuRuleAgentGroupID(brID) {
        return BRM.rb41(brID).getAgentGroupID();
    }

	/**
	 * startChatInterface - starts the CI
	 * if the application has not been loaded before,
	 * then: set launchWhenReady=true and let the loading js start it up
	 * else: it is a restart, ask main to start it up.
	 */
	function startChatInterface() {
		window.launchWhenReady=true;
	}


	/**
	 * closeChatInterface
	 * Please make sure that Application.application.close is published in CI
	 *
	 */
	function closeChatInterface() {
		var app = window["Application"] ;
		if (app&&app.application&&app.application.close) {
			try {app.application.close();}
			catch (e){
				Inq.log("Could not close ChatInterface: " + e) ;
			}
		}
	}

	/**
	 * postponeAcifCommand
	 * Save missed acif commands after calling setElementPosition
	 * @param {string} elementId -  id of the mxml element
	 * @param {object} attributes - object keys refer to dimensions(attributes) referenced in the mxml.
	 * The object values can be numbers, "null" expressions, or string expressions (i.e. "RightFrame.height - 50").
	 * dimensions(attributes) with null and undefined values are ignored.
	 * @param {boolean} errorLogging -  controls error logging. default value is "true." (optionally)
	 */
	function postponeAcifCommand(elementId, attributes, errorLogging) {
		postponedAcifCommands.push({ID: elementId, ATTR: attributes, LOG: errorLogging});
	}

	/**
	 * applyAcifCommands
	 * Attempt update style for missed acif commands
	 */
	function applyAcifCommands() {
		var tmpStorage = postponedAcifCommands.slice();
		postponedAcifCommands.length = 0;
		for (var i = 0; i < tmpStorage.length; i++) {
			setElementPosition(tmpStorage[i].ID, tmpStorage[i].ATTR, tmpStorage[i].LOG);
		}
	}

	/**
	 * setElementPosition
	 * Manipulate the sizing and positioning of CI elements and layers.
	 * @param {string} elementId -  id of the mxml element
	 * @param {object} attributes - object keys refer to dimensions(attributes) referenced in the mxml.
	 * The object values can be numbers, "null" expressions, or string expressions (i.e. "RightFrame.height - 50").
	 * dimensions(attributes) with null and undefined values are ignored.
	 * @param {boolean} errorLogging -  controls error logging. default value is "true." (optionally)
	 */
	function setElementPosition(elementId, attributes, errorLogging) {
		errorLogging = typeof errorLogging !== "undefined" ? errorLogging : true;
		var app = window["Application"];
		if (app && app.application) {
			if (app.application.getVisible()) {
				try {
					app.application.updateStyle(elementId, attributes);
				} catch (e) {
					if (errorLogging) {
						Inq.log("Cannot reposition element '" + elementId + "'. " + e);
					}
				}
			} else {
				postponeAcifCommand(elementId, attributes, errorLogging);
			}
		} else if (errorLogging) {
			Inq.log("Cannot reposition element '" + elementId + "'. CI is not active.");
		}
	}

	/**
	 * getBrowserTypeAndVersion
	 *
	 *  returns result of getBrowserTypeAndVersion() utility function
	 *  @see cbtv1()
	 *  @return String Array of 0. browser name, 1. browser version
	 */
	function _getBrowserTypeAndVersion() {
		return getBrowserTypeAndVersion();
	}

	/**
	 * _getBrowserMajorVer
	 *
	 * This is interface to invoke utility function "getBrowserMajorVer()" from CI
	 * @see getBrowserMajorVer()
	 * @param {boolean} compatibility - flag for determine version in compatibility mode
	 * @return {number} browser major version or 0 if unable to detect
	 */
	function _getBrowserMajorVer(compatibility) {
		return getBrowserMajorVer(compatibility);
	}

	/**
	 * Run function from Application.js to restart timer to close not started chat with parameters from previously timer parameters
	 */
	function restartTimer() {
		var app = window["Application"];
		var errMessage = "Could not restart timer to close not started chat: ";
		if (app && app.application && app.application.restartTimer) {
			try {
				app.application.restartTimer();
			}
			catch (e){
				Inq.log(errMessage + e);
			}
		} else {
			Inq.log(errMessage + "app.application.restartTimer is not initialized");
		}
	}

	/**
	 * ciActionBtnCloseChat
	 * proxy function to the com.inq.flash.client.chatskins.SkinControl.actionBtnCloseChat
	 * To call; inqFrame.Inq.FlashPeer.ciActionBtnCloseChat()
	 *
	 * Note:
	 * com.inq.flash.client.chatskins.SkinControl.actionBtnCloseChat is set to ciActionBtnCloseChat
	 *            in com.inq.flash.client.chatskins.SkinControl._init
	 */
    function ciActionBtnCloseChat(){
        throw("ciActionBtnCloseChat is not defined");
    }

	function fileTransferSize() {
		return fileUploadSize;
	}
	function fileDelSetting() {
		return fileDeleteSetting;
	}

	function fileTransferServerUrl(){
		return site.fileTransferUrl;
	}

	function fileTransferExtensions() {
    	return site.fileTransferExtensions;
	}

	function fileTransferApiUrl() {
		return site.fileTransferApiUrl;
	}

	function noJSHostingInTagserver() {
		return site.noJSHosting;
	}
	function getClientStaticURL() {
		return site.clientStaticUrl;
	}

	function noV3FrameChat() {
		return site.noChatV3Frame;
	}

    /**
	 * Turns on the beacon flag on postToServer iframe in the corresponding domain.
	 * It is needed to be able to send beacon to the server when corresponding window will be unloaded.
	 *
	 * @see Chat#setCABeacon
	 *
	 * @param {string} action - the action for setting the state of the beacon
	 * @param {object} data - interface for additional data (optionally)
	 */
	function setCABeacon(action, data) {
		CHM.setCABeacon(action, data);
	}

    /**
     * Sets the active windowId (master window id) on the server to an active list of ids
     * setCABeacon will remove the window id when a page is unloaded.
     * @see RTDEV-23774
     */
    function setActiveWindowId() {
        CHM.setActiveWindowId();
    }

	function closeChatMonitor() {
		CHM.closeChatMonitor();
	}

	/**
	 * Prefetch the resource.
	 * @param path {string} - URL of the prefetching resource
	 */
	function prefetchURL(path) {
		prefetchResource(path);
	}

	/**
	 * This method adds kms js files on demand
	 */
	function loadKMSlibraries(){
		Inq.CHM.chat.preloadVidyo();
	}

	function endWebRTCCall(closeOnEnd) {
		window.inqFrame.com.inq.flash.client.control.WebRTCMgr.endCall(closeOnEnd);
	}

	/**
	 * @deprecated
	 *
	 * Returns the Queue Messaging Spec for the opened chat or null.
	 * @returns {?Object}
	 */
	function getQueueMessagingSpec() {
		return null;
	}

	/**
	 * Returns the Queue Messaging Spec Id for the opened chat or null.
	 * @returns {?number}
	 */
	function getQueueMessagingSpecId() {
		return CHM.getQueueMessagingSpecId();
	}

	function getAgentsAvailabilityCheckUrl() {
		return urls.agentsAvailabilityCheckURL;
	}

	function getAutomatonSpecData() {
		return CHM.getChat() && CHM.getChat().getAutomatonSpecData();
	}

	function getChatRule() {
		return CHM.getChat() && CHM.getChat().getRule();
	}

	function getVarValue(name) {
		return PM.getVar(name) && PM.getVar(name).z0();
	}

	function setVarValue(name, value) {
		PM.getVar(name) && PM.getVar(name).z3(value);
	}

	function addListener(listener) {
		EVM.addListener(listener);
	}

	/**
	 * Get chat connection to CR status.
	 * Used by ACIF automaton to check chat connection status
	 * in case if chat engagement process was interrupted by page landing or page refresh.
	 *
	 * @returns {boolean} true if CI connect and can communicate with CR
	 */
	function isChatConnected() {
		try {
			var isChatConnected = window.inqFrame.com.inq.flash.client.control.XFrameWorker.isChatConnected;
			if (!inu1(isChatConnected)) {
				return isChatConnected();
			}
		} catch (e) {
			log('isChatConnected: isChatConnected function was not published in CI: ' + e.message);
		}
	}

	/**
	 * ciPreparingClosingChat - is used to close session and stop the chat activity
	 *
	 * This is the prototype of the function that acif must be used
	 * to correctly close the chat session at the time the thank-you image is displayed.
	 *
	 * @public
	 * @static
	 * @return {void}
	 */
	function ciPreparingClosingChat() {
		try {
			var preparingClosingChat = window.inqFrame.com.inq.flash.client.control.XFrameWorker.preparingClosingChat;
			if (!inu1(preparingClosingChat)) {
				preparingClosingChat();
			}
		} catch (e) {
			log('preparingClosingChat: preparingClosingChat function was not published in CI: ' + e.message);
		}
	}

	function ciCloseChat() {
		try {
			var closeChat = window.inqFrame.com.inq.flash.client.control.XFrameWorker.closeChat;
			if (!inu1(closeChat)) {
				return closeChat();
			}
		} catch (e) {
			log('closeChat: closeChat function was not published in CI: ' + e.message);
		}
	}

	/**
	 * Is used to engage the chat with specified parameters.
	 *
	 * @public
	 * @static
	 * @param {Object} chatParams - parameters to engage the chat
	 * @return {void}
	 */
	function ciEngageChat(chatParams) {
		try {
			var engageChat = window.inqFrame.com.inq.flash.client.control.XFrameWorker.engageChat;
			if (!inu1(engageChat)) {
				engageChat(chatParams);
			}
		} catch (e) {
			log('engageChat: engageChat function was not published in CI: ' + e.message);
		}
	}

	/**
	 * expandChat - is used to resize the chat interface and display the chat in the full screen mode.
	 * The current implementation is supported for iPhone only.
	 * @throws {Error} Application should be initialized
	 * @return {boolean}
	 */
	function expandChat() {
		if (_isApplicationInitialised() && Application.expandChat) {
			return Application.expandChat();
		} else {
			throw("ERROR: expandChat is not initialized");
		}
	}

	/**
	 * shrinkChat - is used to resize the chat interface when software keyboard is displayed.
	 * The current implementation is supported for iPhone only.
	 * @throws {Error} Application should be initialized
	 * @return {boolean}
	 */
	function shrinkChat() {
		if (_isApplicationInitialised() && Application.shrinkChat) {
			return Application.shrinkChat();
		} else {
			throw("ERROR: shrinkChat is not initialized");
		}
	}

	/**
	 * Is used to set specified engage parameters and engage chat on first message from customer.
	 *
	 * @public
	 * @static
	 * @param {Object} chatParams - parameters to engage the chat
	 * @return {void}
	 */
	function ciSetEngageParameters(chatParams) {
		try {
			var setEngageParameters = window.inqFrame.com.inq.flash.client.control.XFrameWorker.setEngageParameters;
			if (!inu1(setEngageParameters)) {
				setEngageParameters(chatParams);
			}
		} catch (e) {
			log('setEngageParameters: setEngageParameters function was not published in CI: ' + e.message);
		}
	}

	/**
	 * Resize chat window.
	 *
	 * @param {number}  stageWidth - new width of chat window
	 * @param {number}  stageHeight - new height of chat window
	 * @return
	 */
	function ciResizeStage(stageWidth, stageHeight) {
		try {
			var resizeStage = window.inqFrame.com.inq.flash.client.control.XFrameWorker.resizeStage;
			if (!inu1(resizeStage)) {
				resizeStage(stageWidth, stageHeight);
			}
		} catch (e) {
			log('resizeStage: resizeStage function was not published in CI: ' + e.message);
		}
	}

	/**
	 * Move chat window.
	 *
	 * @param location the position specifier for where to position the client skin.
	 * @param x the horizontal position of left-top corner of the chat window.
	 * @param y the vertical position of left-top corner of the chat window.
	 * Parameters x and y used if {@code location) is ABSOLUTE or RELATIVE.
	 * Possible values of location are:
	 * "UPPER_CENTER", "TOP_CENTER"
	 * "UPPER_RIGHT", "TOP_RIGHT"
	 * "UPPER_LEFT", "TOP_LEFT"
	 * "CENTER_LEFT"
	 * "CENTER_RIGHT"
	 * "LOWER_LEFT", "BOTTOM_LEFT"
	 * "LOWER_CENTER", "BOTTOM_CENTER"
	 * "LOWER_RIGHT", "BOTTOM_RIGHT"
	 * "POP_UNDER_CENTER"
	 * "ABSOLUTE"
	 * "RELATIVE"
	 * "CENTER"
	 */
	function ciMoveStage(location, x, y) {
		try {
			var moveStage = window.inqFrame.com.inq.flash.client.control.XFrameWorker.moveStage;
			if (!inu1(moveStage)) {
				moveStage(location, x, y);
			}
		} catch (e) {
			log('moveStage: moveStage function was not published in CI: ' + e.message);
		}
	}

	/**
	 * Set Circular Modal Window on given div object
	 * @param div      - div contelement
	 * @param firstEl  - first element in tab order
	 * @param lastEl   - last element in tab order
	 * @return true/false
	 */
	function ciSetCircularModalWindow(div, firstEl, lastEl) {
		try {
			var setCircularModalWindow = window.inqFrame.com.inq.flash.client.control.XFrameWorker.setCircularModalWindow;
			if (!inu1(setCircularModalWindow)) {
				return setCircularModalWindow(div, firstEl, lastEl);
			}
		} catch (e) {
			log('setCircularModalWindow: setCircularModalWindow function was not published in CI: ' + e.message);
		}
	}

	/**
	 * remove Circular Modal Window on given div object
	 */
	function ciRemoveCircularModalWindow() {
		try {
			var removeCircularModalWindow = window.inqFrame.com.inq.flash.client.control.XFrameWorker.removeCircularModalWindow;
			if (!inu1(removeCircularModalWindow)) {
				removeCircularModalWindow();
			}
		} catch (e) {
			log('removeCircularModalWindow: removeCircularModalWindow function was not published in CI: ' + e.message);
		}
	}

	function ciIsCircularTabbingEnabled() {
		try {
			var isCircularTabbingEnabled = window.inqFrame.com.inq.flash.client.control.XFrameWorker.isCircularTabbingEnabled;
			if (!inu1(isCircularTabbingEnabled)) {
				return isCircularTabbingEnabled();
			}
		} catch (e) {
			log('isCircularTabbingEnabled: isCircularTabbingEnabled function was not published in CI: ' + e.message);
		}
	}

	function ciSetAutomatonDataMapXcd(json) {
		try {
			var setAutomatonDataMapXcd = window.inqFrame.com.inq.flash.client.control.XFrameWorker.setAutomatonDataMapXcd;
			if (!inu1(setAutomatonDataMapXcd)) {
				setAutomatonDataMapXcd(json);
			}
		} catch (e) {
			log('setAutomatonDataMapXcd: setAutomatonDataMapXcd function was not published in CI: ' + e.message);
		}
	}

	function ciTransitionPage() {
		try {
			var transitionPage = window.inqFrame.com.inq.flash.client.control.XFrameWorker.transitionPage;
			if (!inu1(transitionPage)) {
				transitionPage();
			}
		} catch (e) {
			log('transitionPage: transitionPage function was not published in CI: ' + e.message);
		}
	}

	function isChatVisible() {
		return CHM.chat && CHM.chat.isVisible();
	}

	/**
	 * Stops the closing of chat.
	 * It's initiated from the persistent chat window.
	 *
	 * @see GR34#r345jjm
	 */
	function stopClosingChatFromPersistent() {
		CHM.StopClosingChatFromPersistent();
	}

	function registerPersistentWindowInOpener(persistentParent) {
		CHM.persistentWindow = persistentParent;
		return true;
	}

	/**
	 * Returns true if persistent window registered in opener
	 * @return {boolean}
	 */
	function isPersistentWindowRegisteredInOpener(){
		return !!CHM.persistentWindow;
	}

	/**
	 * Returns the requested function from closure context,
	 * which name is defined by the string parameter.
	 * @this FlashPeer
	 * @param {string} funcName
	 * @returns {function|undefined}
	 */
	function getInternalFunction(funcName) {
		var closure = {
			"addVisitorAttributes": addVisitorAttributes,
			"assignAgent": assignAgent,
			"banVisitorAttributes": banVisitorAttributes,
			"closePopupChat": closePopupChat,
			"CloseChatFromPersistent": CloseChatFromPersistent,
			"cookiesCleaningDetected": cookiesCleaningDetected,
			"fireChatLaunched": fireChatLaunched,
			"getAgentData": getAgentData,
			"getCachedCookies": getCachedCookies,
			"getChat": getChat,
			"getPage": getPage,
			"isPersistentWindowRegisteredInOpener": isPersistentWindowRegisteredInOpener,
			"logData": logData,
			"registerPersistentWindowInOpener": registerPersistentWindowInOpener,
			"removeVisitorAttributes": removeVisitorAttributes,
			"setPersistentWindowActive": setPersistentWindowActive,
			"stopClosingChatFromPersistent": stopClosingChatFromPersistent,
			"unbanVisitorAttributes": unbanVisitorAttributes
		};
		return closure[funcName];
	}

	/**
	 * Call the function in the scope of the opener window.
	 * Is used to call from another window or tab, e.g. from persistent chat window.
	 * Opener - it is a window that opened the popup window contains a persistent chat.
	 * @param {string} funcName - name of called function
	 * @param {(Array=|Object=)} args - list of arguments, if not defined then is empty list
	 * @param {boolean=} async - flag to call function asynchronously
	 * @returns {*}
	 */
	function callFromPersistent(funcName, args, async) {
		/** @type {?function} */
		var _func = getInternalFunction(funcName);
		if (typeof _func == "function") {
			if (!Array.isArray(args) && Object.prototype.toString.call(args) !== "[object Arguments]") {
                /** @type {Array} */
                var aArgs = [];
                // IE in the compatibility mode uses opener and parent window in a different modes (version 7 for parent, version 5 for opener)
                // It leads to the problem with the args variable. It is automatically converted to "object" type.
                // It is needed to convert it back to Array type
                if (typeof args === "object" && args && args.length) {
                    for (var i = 0; i < args.length; i++) {
                        aArgs.push(args[i]);
                    }
                }
                args = aArgs;
			}
			try {
				if (async) {
					return setTimeout(function() {
						_func.apply(null, args);
					}, 1);
				} else {
					return _func.apply(null, args);
				}
			} catch (e) {
				logErrorToServer("ERROR: Call function from persistent window failed"
					+ ", function=" + funcName
				);
			}
		} else {
			logErrorToServer("ERROR: Call function from persistent window failed"
				+ ", " + funcName + " is not a function."
			);
		}
	}

	/**
	 * Setts flag detecting clearing of cookies to true
	 */
	function cookiesCleaningDetected() {
		CM.cookiesCleaningDetected();
	}

	/**
	 * Returns the value of timeout when chat will be lost due to the disconnection.
	 * @see IJSF GR34#getDisconnectionTimeout
	 * @returns {number}
	 */
	function getDisconnectionTimeout() {
		return CHM.getDisconnectionTimeout();
	}

	function isV3Continue() {
		return CHM.isV3Continue();
	}

	function getVisitorAttributes() {
		return VAM.getCopyAsArray(true).join(";");
	}

	/**
	 * Return cookie cache from CM47
	 * @returns {?Object}
	 */
	function getCachedCookies() {
		return CM.getCachedCookies();
	}

	function addVisitorAttributes(visitorAttributes) {
		VAM.add(visitorAttributes);
	}

	function removeVisitorAttributes(visitorAttributes, fromRemoveAll) {
		VAM.remove(visitorAttributes, fromRemoveAll);
	}

	function banVisitorAttributes(visitorAttributes, duration) {
		VAM.ban(visitorAttributes, duration);
	}

	function unbanVisitorAttributes(visitorAttributes) {
		VAM.unban(visitorAttributes);
	}

	/**
	 * Sends a system message to either or both AI and/or CI depending on the context.  If no context is specified,
	 * message will be sent to both AI and CI.
	 * @param message - the message to be sent.
	 * @param cssClass (optional) - css class name.
	 * @param context (optional) - the message context. Value can be "agentInterface" or "customerInterface", case
	 *        sensitive.
	 */
	function sendSystemMessage(message, cssClass, context) {
		if (inqFrame.com.inq.flash.client.control.sendSystemMessage) {
			try {
				inqFrame.com.inq.flash.client.control.sendSystemMessage(message, cssClass, context);
			} catch (e) {
				log(e);
			}
		}
	}

	/**
	 * Sends automaton message to AI and/or CI
	 * @see sendAutomatonMessage function on CustomerAPI for parameters description.
	 */
	function _sendAutomatonMessage(msgType, message, cssClass, context) {
		// If msgType is datapass, ignore context and just send the message to agent since only agent supports datapass.
		if (msgType === "datapass") {
			ROM.sendDataToAgent(CHM.getAgentID(), message);
		} else {
			sendSystemMessage(message, cssClass, context);
		}
	}

	/**
	 * Returns the chat instance.
	 * @see GR34#getChat
	 * @return {Chat}
	 */
	function getChat() {
		return CHM.getChat();
	}

	/**
	 * Obtains a page marker for a given landing history queue index.
	 * @see LE12#getPage
	 * @param {number} id - Index of the page history queue. 0 is current page.
	 * @return {{id, mID, re, sup, bUnits}|{id, mID, re}} Page object consisting of id, mID and regex. Null if not found or queue is empty.
	 */
	function getPage(id) {
		return LDM.getPage(id);
	}

	/**
	 * Sets the flag "closed" in current chat instance,
	 * it means that current chat session is ended and chat finished.
	 * This state is saved in the persistent storage.
	 * @param {string} chatID
	 */
	function endChatSession(chatID){
		CHM.endChatSession(chatID);
	}

    /**
     * get the Embedded Theme from the chat spec.
	 * @return {?object} embeddedTheme
     */
	function getEmbeddedTheme () {
		return CHM.getChat() && CHM.getChat().getEmbeddedTheme();
	}

    /**
     * is the embedded theme valid.
     * @return boolean
     */
	function isEmbeddedThemeValid () {
		var embeddedTheme = getEmbeddedTheme();
		if (embeddedTheme) {
			return embeddedTheme.isValid;
		}
		return false;
	}

    /**
     * Is multi chat supported.
     * @return boolean
     */
	function isMultiChatSupported () {
		return CHM.isMultiChatSupported();
	}

	/**
	 * getSiteConstants
	 * get Site Constants defined in the BR
	 * @return boolean
	 */
	function getSiteConstants() {
		return site.businessConstants();
	}

	function setIOSSDKProgress(progress){
		if(progress == true) {
			isChatProgressInSDK = true;
		} else {
			isChatProgressInSDK = false;
		}
		if(!Inq.initialized) {
			init.call(Inq);
		}

	}

	function setNativeSDKConversationPlayStatus(pendingMsg) {
		if (pendingMsg) {
			C2CM.showDisabledIcon();
		}
	}

	function launchChatByC2CID(c2cIdx) {
	    if (c2cIdx >= 0) {
            C2CM.agrty(c2cIdx);
        }
    }



	function getSDKAPIInstance() {
		return {
			onC2CClicked:function(idx,callback) {
				if (arguments.length != 2) {
					logError("Missing arguments, needs c2cid and a callback to continue");
					return;
				}
				C2CM.requestExtChat(idx, callback);
			},
			chatDisplayed:function(displayedParams, isRebindngCallbacks){
				if(typeof  displayedParams != "object"){ return; }
				window.inqFrame.Application.application.chatUIRendered(displayedParams, isRebindngCallbacks);
			},
			engageChat:function(initialMessage, callback) {
				window.inqFrame.Application.application.engage(initialMessage, false, null, callback);
			},
			autoEngage:function(autoText, engageParams, callback) {
				window.inqFrame.Application.application.engage(autoText, true, engageParams, callback);
			},
			getMessages:function(callback) {
				window.inqFrame.Application.application.getMessages(callback);
			},
			closeChat:function() {
				window.inqFrame.Application.application.closeEngagement();
			},
			sendMessage:function(msg) {
				window.inqFrame.Application.application.sendMessage(msg);
			},
			sendActivityMessage:function(type) {
				window.inqFrame.Application.application.sendChatActivity(type);
			},
			requestEmailTranscript:function(emailAddress){
				window.inqFrame.Application.application.requestTranscript(emailAddress);
			},
			isChatInProgress:function() {
				if (window.inqFrame.Application) {
					return window.inqFrame.Application.application.isChatInProgress();
				} else {
					return CHM.isChatInProgress()
				}
			},
			getOpenerScripts:function(responseCb, openerID, errorCb) {
				if (typeof responseCb != "function") {
				   return;
				}
				if (window.inqFrame.Application) {
					window.inqFrame.Application.application.getOpeners(responseCb);
				} else if (openerID) {
					ROM.get(
						urls.baseURL + "/scripts/getScript?js=yes&siteID=" + getSiteID() + "&scriptID=" + openerID,
						generateRequestId("getScript"),
						0,
						function (resp) {
							if (resp.responseStatus == 200) {
								responseCb(resp.data);
							} else {
								errorCb(resp)
							}
						},
						errorCb
					);
				}

			},
			setOpeners:function(openers, agentAlias) {
				window.inqFrame.Application.application.setOpeners(openers, agentAlias);
			},
			isVirtualAgent:function() {
				return window.inqFrame.Application.application.isVirtualAgent();
			},
			isAsyncChat:function() {
				return window.inqFrame.Application.application.isAsyncChat();
			},
			isConnected:function() {
				return window.inqFrame.Application.application.isConnected();
			},
			getAsyncChatMode:function() {
				return window.inqFrame.Application.application.getAsyncChatMode();
			},
			showOpenerForEndedConv:function() {
				return window.inqFrame.Application.application.showOpenerForEndedConv();
			},
			getPersistenceManager:function() {
				return window.inqFrame.Application.application.getPersistenceManager();
			},
            getPersistedData: function(key, defaultValue) {
			    return window.inqFrame.Application.application.getPersistedValue(key, defaultValue);
            },
            setPersistedData: function(key, value) {
                window.inqFrame.Application.application.setPersistedValue(key, value);
            },
			removePersistedDataByKey: function(key) {
                window.inqFrame.Application.application.removePersistedValue(key);
            },
            startCobrowseSession:function(shared) {
				if(shared) {
					FP.ciAcceptCobShareInv(true);
				} else {
					FP.ciAcceptCobInv(true);
				}
			},
			declineCobrowseInvite:function(shared) {
				if(shared) {
					FP.ciDeclineCobShareInv();
				} else {
					FP.ciDeclineCobInv();
				}
			},
			sendVALinkMessage:function(event, customerMsgCB, linkClickCb, engagedCb) {
				window.inqFrame.Application.application.sendVALinkClicked(event, customerMsgCB, linkClickCb, engagedCb);
			},
			sendVAMessage:function(msgObj) {
				window.inqFrame.Application.application.sendVAMessage(msgObj);
			},
			sendDataPass:function(dpObject) {
				if (typeof dpObject != "object") {
					logError("sendDataPass only accepts Object as its argument.");
					return;
				} else if (!getAgentID()) {
					logError("sendDataPass can be invoked only afer an agent is assigned.");
					return;
				}
				dpObject["engagementID"] = CHM.getChatID();
				dpObject["agentID"] = getAgentID();
				ROM.sendDataToAgent(getAgentID(), dpObject);
			},
			getPreviousAsyncTranscript:function(callback) {
				Glk4(function(response) {
					callback(response);
				});
			},
			isLastConversationActive: function() {
				return isConversationActive;
			},
			sendRichContentMessage: function(text, data, engagedCallback) {
				if (typeof data == "object") {
					data = JSON.stringify(data);
				}
				window.inqFrame.Application.application.sendRichContentMessage(text, data, engagedCallback);
			},
			getAsyncUnReadMsgCount:function(ruleID, callback) {
				var rule = BRM.rb41(ruleID);
				var data = prepareBaseBodyForAsyncChatDataRequest();
				data.businessUnitID = rule.getBusinessUnitID();
				ROM.post(urls.requestCustomerStatus, data, null, null, callback);
			},
			getImagePath : function() {
				return window.inqFrame.Application.application.getImagePath();
			},
            getSkinDynamicAssetsPath: function() {
			    return getSkinRootUrl() + getThemeName() + "/";
            },
			checkIfMinimized:function() {
				var embeddedTheme = getEmbeddedTheme();
				if (window.inqFrame.Application) {
                    var app = window.inqFrame.Application.application;
                    var isValidEmbedded = embeddedTheme && embeddedTheme.isValid;
                    var isMinimized = app.isMinimized();
                    if (isMinimized && isValidEmbedded) {
                        this.sendActivityMessage("restore");
                        return {"state": false};
                    }
                    return {"state": isMinimized, "count": app.getMinimizedCount()};
                }
                return {"state": false};
			},
			resetMinimizedCount:function() {
				window.inqFrame.Application.application.resetMinimizedCount();
			},
			ACTIVITY_STATE: {
				"MINIMIZED":"minimize",
				"RESTORED":"restore",
				"START_TYPING":"startTyping",
				"STOP_TYPING":"stopTyping"
			},
			isChatQueued:function() {
				return window.inqFrame.Application.application.isChatQueued();
			},
			isPersistentWindow:function() {
				return window.inqFrame.Application.application.isPersistentWindow();
			},
			getDeviceType:function() {
				return  window.inqFrame.Application.application.getDeviceType();
			},
			getThemeInfo:function() {
				var app = window.inqFrame.Application.application;
				var theme = {};
				theme["skinWidth"] = getSkinWidth();
				theme["skinHeight"] = getSkinHeight();
				theme["skinPosition"] = getSkinLocation();
				theme["skinLeft"] = getSkinLeft();
				var skinRight = app.getPersistedValue(RIGHT, -1);
				var skinBottom = app.getPersistedValue(BOTTOM, -1);
				if (skinRight) {
					theme["skinRightSaved"] = skinRight;
				}
				theme["skinTop"] = getSkinTop();
				if (skinBottom) {
					theme["skinBottomSaved"] = skinBottom;
				}
				theme["titleBarHeight"] = getTitleBarHeight();
				theme["deviceType"] = getDeviceType();
				theme["dragAreaOffset"] = getPopupCloserWidth();
				theme["imagePath"] = this.getImagePath();
				theme["skinPath"] = Inq.urls.skinURL +  getThemeName() + "/";
				theme["minimized"] = this.checkIfMinimized();
				var embeddedTheme = getEmbeddedTheme();
                if (embeddedTheme && embeddedTheme.isValid) {
                    theme["embedded"] = embeddedTheme;
                }
				return theme;
			},
			saveWindowPosition:function(bottom, right) {
				var oPos = {};
				oPos[RIGHT] = right;
				oPos[BOTTOM] = bottom;
                window.inqFrame.Application.application.setPersistedValues(oPos);
			},
			getChatParams:function() {
				var params = window.inqFrame.Application.application.getChatParams();
				params.agentID = getAgentID();
				params.countryCode = _getCustGeoData().country_code;
				params.regionCode = _getCustGeoData().region_code;
				params.chatType = CHM.getChatType();
				return params;
			},
			logEventToDW:function(evtList) {
				ROM.post(urls.logDataEvtListURL,  {stringifiedDataArray: JSON.stringify(evtList.eventList)});
			},
			submitNativePostChatSurvey:function(data) {
				if (CHM.isPersistentWindow()) {
					var sdk = isWebSDK ? o1p().FrameBridge.Inq.SDK : window.parent.opener.Inq.SDK;
					sdk.submitNativePostChatSurvey(data);
				} else {
					submitNativePostChatSurvey(data);
				}
			},
			checkAgentAvailability:function(buId, agID, agentAttrs, qt, callback) {
				var data = {
					"siteID": Inq.getSiteID(),
					"buID": buId
				};
				if (agID) {
					data.agID = agID;
				}
				if (agentAttrs) {
					data.agentAttributes = agentAttrs;
				}
				if (qt) {
					data.queueThreshold = qt;
				}
				ROM.post(urls.agentsAvailabilityCheckURL, data, null, null, function (resp) {
					if (resp.responseStatus == 200) {
						callback && callback(resp.data);
					} else {
						callback && callback(null);
					}
				});
			},
			setCustomerName:function(name) {
				if (name) {
					window.inqFrame.Application.application.setCustomerName(name);
				}
			},
			getCustomerName:function() {
				return window.inqFrame.Application.application.getCustomerName();
			},
			uploadFile: function (file, cb) {
                return window.inqFrame.Application.application.uploadFile(file, cb);
			},
            sendSystemMessage: function(text) {
                window.inqFrame.Application.application.sendSystemMsg(text);
			},
			isContinued: function() {
				return window.inqFrame.Application.application.isContinued();
			}
		}
	}

    /**
	 * if called in Biz Rule, one2ManyChat is enabled.
     */
    function enableOne2ManyChat() {
		one2ManyChat = true;
    }

    /**
     * return true if one2ManyChat is enabled.
     */
    function isOne2ManyChatEnabled() {
		return one2ManyChat;
    }

	/**
	 * Setter for variable {@link Chat#agentClosedChat},
	 * which detects if agent closed chat.
	 */
	function setAgentClosedChat(agentClosedChat) {
		var chat = CHM.getChat();
		if (chat) {
			chat.setAgentClosedChat(agentClosedChat);
		} else {
			logError("Chat was not found, survey can be not displayed.");
		}
	}

	function getEngageParams(chatparams) {
		var agID = chatparams["agentGroupId"] || CHM.getChat().getAgentGroupID();
		var buID = chatparams["businessUnitID"] || getBusinessUnitID();
		var priority = CHM.getChat().rule.getPriority();
		var script = chatparams["scriptTreeId"] || CHM.getChat().getScriptID();

		var engageParams = {
			siteID:""+Inq.getSiteID(),
			agID:""+agID,
			buID:""+buID,
			brID:""+getBrID(),
			brName:getBrName(),
			pageID:""+getPageID(),
			custID:""+CHM.getChat().getCustID()
		}
		if(script) {
			engageParams["scriptID"] = ""+script;
		}
		if(priority) {
			engageParams["priority"] = ""+priority;
		}
		if(CHM.q6t()) {
			engageParams["qt"] = ""+CHM.q6t()
		}
		if(CHM.getQueueMessagingSpecId() != null) {
			engageParams["qmSpecID"] = ""+CHM.getQueueMessagingSpecId();
		}
		if(CHM.getChat().getAutomatonId() != null || chatparams["automatonId"]){
			engageParams["autoID"] = ""+ (chatparams["automatonId"] || CHM.getChat().getAutomatonId());
		}
		if(chatparams["clientOutcome"]) {
			engageParams["openerText"] = chatparams["clientOutcome"];
		} else if(CHM.getChat().getOpenerName()) {
			engageParams["opName"] = CHM.getChat().getOpenerName();
		} else if(CHM.getChat().getOpenerID()){
			engageParams["opID"] = ""+CHM.getChat().getOpenerID();
		}

		if(chatparams["custName"]) {
			engageParams["customerName"] = chatparams["custName"];
		}
		if(chatparams["agentOutcome"]){
			engageParams["agentOutcome"] = chatparams["agentOutcome"];
		}
		if(CHM.getEmailSpecId()) {
			engageParams["emailSpecID"] = ""+CHM.getEmailSpecId();
		}

		engageParams["tagUrl"] = urls.vanityURL;

		if(chatparams["agentAttrs"]){
			var aAttrs = chatparams["agentAttrs"].split(",");
			chatparams["agentAttrs"] = ""
			var l=0;
			for(var i=0;i<aAttrs.length;i++) {

				var pp  = aAttrs[i].split("=");
				if(pp.length>1 && pp[1]) {
					if(l>0) {
						chatparams["agentAttrs"]+=";";
					}
					chatparams["agentAttrs"] += (pp[0] + "," + pp[1])
					l++;
				}
			}
		}

		if(chatparams["wCall"]){
			engageParams["callType"] = chatparams["wCall"];
			if(chatparams["closeOnEnd"]) {
				engageParams["closeOnEnd"] = "true";
			}
		}
		if(chatparams["vidyoHost"]) {
			engageParams["host"] = chatparams["vidyoHost"];
			engageParams["appKeyID"] = chatparams["appKeyId"];
		}

		var automatonDatapass = getAutomatonDatapass();
		if (automatonDatapass) {
			var arr = {};
			for (var ix = 0; ix < automatonDatapass.length; ix++) {
				arr[automatonDatapass[ix].key] = automatonDatapass[ix].value;
			}
			engageParams["autoDataPass"] = JSON.stringify({"datapass":arr});
		}

		var automatonSpecData = getAutomatonSpecData();
		var automatonDataMap =  automatonSpecData ? automatonSpecData : getAutomatonDataMap();
		if(automatonDataMap) {
			engageParams["autoDataMap"] = automatonDataMap;
		}

		if(CHM.getChat().ra1t()) {
			engageParams["brAttributes"] = CHM.getChat().ra1t();
		}

		if (CHM.getChat().isAsyncChat()) {
			engageParams["isAsyncEngagement"] = true;
		}
		var mode = CHM.getChat().getRule().conversationTranscriptMode;
		if (mode) {
			engageParams["asyncMode"] = mode;
		}

		var days = CHM.getChat().getRule().conversationTranscriptDays;
		if (days) {
			engageParams["asyncDays"] = days;
		}

		return engageParams;
	}

	function launchNativeSDK(chatparams) {
		var agID = chatparams["agentGroupId"] || CHM.getChat().getAgentGroupID();
		var buID = chatparams["businessUnitID"] || getBusinessUnitID();
		CHM.assignAgent("tmp_agent_name",true,false,{},buID,agID);
		var engageParams = getEngageParams(chatparams);
		CHM.getChat().monitorChatActive();
		if(typeof NuanIJSFBridge != "undefined") {
			NuanIJSFBridge.startChat(JSON.stringify(engageParams), chatparams["agentAttrs"] || CHM.getChat().getAgentAttributesAsString());
		} else {
			engageParams["reqType"] = "engagement"
			if(chatparams["agentAttrs"] || CHM.getChat().getAgentAttributesAsString()) {
				engageParams["attributes"] = chatparams["agentAttrs"] || CHM.getChat().getAgentAttributesAsString();
			}
			if (nativeTimeout) {
				clearTimeout(nativeTimeout);
			}
			nativeTimeout = setTimeout(function() {
				getIOSNativeSDKInstance().postMessage(JSON.stringify(engageParams));
			},200)
		}
	}

	function onChatMinimize() {
		CBM.onChatMinimize();
	}

	/**
	 * ACIF sends survey data as a JSON object to Tag Server. so Tag Server can take next action.
	 *
	 * @param data JSON object built by ACIF
	 */
	function submitNativePostChatSurvey(data) {
		ROM.postJson(urls.nativePostChatSurveyURL, data);
	}

	function getInitialTimeout() {
		return DEFAULT_INITIAL_TIMEOUT;
	}

	function isAdblockEnabled() {
		return CHM.isAdblockOn();
	}

	function setEventDataForSurvey(eventData) {
		SVYM.setEventDataForSurvey(eventData);
	}

	/**
	 * Returns all active virtual Agent IDs
	 * @return {Array}
	 */
	function getVAList(){
		return site.vaList;
	}

	/**
	 * Fires chatLaunched event
	 * @param {Object=} chatData
	 */
	function fireChatLaunched(chatData) {
		CHM.fireChatLaunched(chatData);
	}

	/**
	 * Resets Conversation Manager and clear data
	 */
	function resetConversationManager() {
		CONVM.reset();
	}

	/**
	 * Fires conversationResolved event
	 */
	function fireConversationResolvedEvent() {
		CONVM.fireConversationResolvedEvent();
	}

	/**
	 * Fires customerAuthenticated event
	 */
	function fireCustomerAuthenticatedEvent() {
		CONVM.fireCustomerAuthenticated();
	}

	/**
	 * Fires VerifyToken success event
	 */
	function fireVerifyTokenSuccessEvent() {
		CONVM.fireVerifyTokenSuccessEvent();
	}

	/**
	 * Fires VerifyToken error event
	 */
	function fireVerifyTokenErrorEvent() {
		CONVM.fireVerifyTokenErrorEvent();
	}

	/**
	 * Send message as customer
	 * @param {String} text
	 * @return {boolean|*}
	 */
	function ciSendAutomatonDataAsCustomerMessage(text) {
		throw("ciSendMessageAsCustomer: sendMessageAsCustomer function was not published in CI");
	}

	/**
	 * Active async chatroom lookup
	 * @param {function} successCallback function to update chatID and continue to establish connection to Chat Router
	 * @param {function} errorCallback function continue to establish connection to Chat Router
	 */
	function getActiveChatroomId(successCallback, errorCallback) {
		ROM.getActiveChatroomId(successCallback, errorCallback);
	}

	/**
	 * Sets async chat flag to change chat mode after chat was engaged.
	 * <p> Async chat could be changed to standard chat in case of failed customer validation and we disable async features for such users.
	 * @param {boolean} value
	 */
	function setAsyncChat(value) {
		CHM.getChat().setAsyncChat(value);
	}

	/**
	 * Returns true if need to hide JSON-formatted messages from conversation transcript
	 * @returns {boolean}
	 */
	function _isHideJsonTranscriptMessages() {
		return isHideJsonTranscriptMessages();
	}

	/**
	 * Fires agent assigned event.
	 * @param {string} aid - agent ID
	 * @param {boolean} noSave
	 * @param {boolean} cobrowseEnabled - flag to show if CoBrowse is enabled
	 * @param {Object} eventData
	 * @param {number} buID - business unit ID
	 * @param {number} agID - agent group ID
	 */
	function assignAgent(aid, noSave, cobrowseEnabled, eventData, buID, agID) {
		CHM.assignAgent(aid, noSave, cobrowseEnabled, eventData, buID, agID);
	}

	/**
	 * Sends error message to TS for. Works only if debug is enabled for passed module.
	 *
	 * @param {string} module
	 * @param {string} message
	 */
	function debugLogErrorToTagServer(module, message) {
		DMgr.let12(module, message);
	}

	/**
	 * Sends warn message to TS for. Works only if debug is enabled for passed module.
	 *
	 * @param {string} module
	 * @param {string} message
	 */
	function debugLogWarnToTagServer(module, message) {
		DMgr.lwt12(module, message);
	}

	/**
	 * Sends info message to TS for. Works only if debug is enabled for passed module.
	 *
	 * @param {string} module
	 * @param {string} message
	 */
	function debugLogInfoToTagServer(module, message) {
		DMgr.logInfoToTagServer(module, message);
	}

	/**
	 * Sends debug message to TS for. Works only if debug is enabled for passed module.
	 *
	 * @param {string} module
	 * @param {string} message
	 */
	function debugLogDebugToTagServer(module, message) {
		DMgr.logDebugToTagServer(module, message);
	}

	/**
	 * Switches debug logs for passed module name
	 *
	 * @param {string} name
	 * @param {boolean} value
	 */
	function debugSwitchForModule(name, value) {
		return DMgr.switchForModule(name, value);
	}

	function verifyToken (tokenID) {
		ROM.verifyToken(tokenID, function () {
			CHM.asyncUnauthUser();
			CONVM.createConversationVars();
		}.bind(this));
	}

	function isAsyncUnauthUser () {
		return CHM.isAsyncUnauthUser();
	}

	/**
	 * Sends all network activity with CR as error log
	 */
	function sendNetworkBackup () {
		return CommunicationMgr.sendNetworkBackup();
	}

	/**
	 * JSON parse wrapper to suppress syntax error exception,
	 * this is the expected case when we use an outdated configuration from the Legacy CI.
	 *
	 * @see MI8.JSON.parse
	 *
	 * @return {*|null} returns null in case of syntax error exception
	 */
	function FPJSONParse(JSONString, suppressError) {
		var parseResult = null;
		try {
			parseResult = MI8.JSON.parse.apply(MI8.JSON, [JSONString]);
		} catch(e) {
			if (suppressError) {
				log("MI8.JSON.parse error suppressed");
			} else {
				log(e, LOG_LEVELS.ERROR);
			}
		}
		return parseResult;
	}

	/**
	 * mc32
	 * Array that maps IJSF#FlashPeer functions for use as private in CI#FlashPeer
	 *
	 * *ATTENTION*
	 *  INDEXES ARE IMPORTANT HERE!
	 *  DO NOT CHANGE INDEXES WITHOUT RELEVANT CHANGES IN CI#FlashPeer.init function.
	 * @type {Array}
	 */
	var mc32 = [];
	mc32[0] = Glk4;
	mc32[1] = gkh24;
	mc32[2] = gkg23;

	return {
		acceptCob: acceptCobrowseInvitation,
		acceptCobSafe: acceptCobrowseInvitationSafe,
		acceptCobShare: acceptCobrowseShareControl,
		addListener: addListener,
		agentSurveyCall: agentSurveyCall,
		applyAcifCommands: applyAcifCommands,
		blockTheService: tryue,
		browserHasFlash: browserHasFlash,
		callFromPersistent: callFromPersistent,
		captureEmailAddress: captureEmailAddress,
		closeChat: closeChat,
		closeChatInterface: closeChatInterface,
		closeChatMonitor: closeChatMonitor,
		closePersistent: closePersistent,
		closePersistentWindowIfOpen: closePersistentWindowIfOpen,
		closePopupChat: closePopupChat,
		closePopupChatFromPersistent: closePopupChatFromPersistent,
		createXFrame: createXFrame,
		debugLogErrorToTagServer: debugLogErrorToTagServer,
		debugLogDebugToTagServer: debugLogDebugToTagServer,
		debugLogInfoToTagServer: debugLogInfoToTagServer,
		debugLogWarnToTagServer: debugLogWarnToTagServer,
		debugSwitchForModule: debugSwitchForModule,
		doPushToFrameset: doPushToFrameset,
        enableOne2ManyChat: enableOne2ManyChat,
		isAsyncUnauthUser: isAsyncUnauthUser,
        isOne2ManyChatEnabled: isOne2ManyChatEnabled,
		endChatSession: endChatSession,
		endCob: endCobrowseSession,
		endCobByEtlEvent: endCobByEtlEvent,
		endWebRTCCall: endWebRTCCall,
		executeCustomCommand: _executeCustomCommand,
		expandChat: expandChat,
		fireConversationResolvedEvent: fireConversationResolvedEvent,
		fireCustomerAuthenticatedEvent: fireCustomerAuthenticatedEvent,
		fireCustomEvent: fireCustomEvent,
		fireCustomEvt: fireCustomEvt,
		fileDeleteSetting: fileDelSetting,
		fireNativeSurveyLaunchEvent: fireNativeSurveyLaunchEvent,
		fileTransferExtensions: fileTransferExtensions,
		fileTransferSize: fileTransferSize,
		fileTransferServerUrl: fileTransferServerUrl,
		fileTransferApiUrl: fileTransferApiUrl,
		ForceFocus: ForceFocus,
		formsLoader: XFormsLoader,
		getActiveChatroomId: getActiveChatroomId,
		getAgentData: getAgentData,
		getAgentGroupDisplayName: getAgentGroupDisplayName,
		getAgentGroupName: getAgentGroupName,
		getAgentID: getAgentID,
		getAgentsAvailabilityCheckUrl: getAgentsAvailabilityCheckUrl,
		getAuthenticatedUser: getAuthenticatedUser,
		getAutomatonDataMap: getAutomatonDataMap,
		getAutomatonDatapass: getAutomatonDatapass,
		getAutomatonSpecData: getAutomatonSpecData,
		getBaseURL: getBaseURL,
		getBrID: getBrID,
		getBrName: getBrName,
		getBrowserMajorVer: _getBrowserMajorVer,
		getBrowserTypeAndVersion: _getBrowserTypeAndVersion,
		getBuRuleAgentGroupID: getBuRuleAgentGroupID,
		getBusinessUnitDisplayName: getBusinessUnitDisplayName,
		getBusinessUnitID: getBusinessUnitID,
		getBusinessUnitName: getBusinessUnitName,
		getCBC: getCBC,
		getChatOwnerBusinessUnitID: getChatOwnerBusinessUnitID,
		getChatRouterVanityUrl: getChatRouterVanityUrl,
		getChatRule: getChatRule,
		getChatSkinFmt: getChatSkinFmt, //called by FontMgr in ci
		getClientPageURL: getClientPageURL,
		getSDKInst: getSDKAPIInstance,
		getCobrowseEnableMinimizeRestore: getCobrowseEnableMinimizeRestore,
		getCustGeoData:_getCustGeoData,
		getCustID: getCustID,
		getDeviceType: _getDeviceType,
		getDisconnectionTimeout: getDisconnectionTimeout,
		getEmbeddedTheme: getEmbeddedTheme,
		getFlashVars: getFlashVars,
		getFPSessionID: getFPSessionID,
		getImagePath: getImagePath,
		asi4: getIncAsID,
		getInitialTimeout: getInitialTimeout,
		getLocalizedMessage: getLocalizedMessage,
		getMediaBaseURL: getMediaBaseURL,
		getPageID: getPageID,
		getPageMarker: getPageMarker,
		getPersistentCustomerID: getPersistentCustomerID,
		getPersistentHeight: getPersistentHeight,
		getPersistentWidth: getPersistentWidth,
		getPersistentXPos: getPersistentXPos,
		getPersistentYPos: getPersistentYPos,
		getPopupCloserWidth: getPopupCloserWidth,
		getQueueMessagingSpec: getQueueMessagingSpec,
		getQueueMessagingSpecId: getQueueMessagingSpecId,
		getSessionID: getSesID,
		getSiteConstants: getSiteConstants,
		getSkin: getSkin,
		getSkinHeight: getSkinHeight,
		getSkinLeft: getSkinLeft,
		getSkinLocation: getSkinLocation,
		getSkinTop: getSkinTop,
		getSkinWidth: getSkinWidth,
		getSurveyAuxParams: getSurveyAuxParams,
		getTitleBarHeight: getTitleBarHeight,
		getV3Data: getV3Data,
		getVAList: getVAList,
		getVanityUrl: getVanityUrl,
		getVarValue: getVarValue,
		getVisitorAttributes: getVisitorAttributes,
		getXFormsDomain: getXFormsDomain,
		hideFramesetChat: hideFramesetChat,
		hidePersistentButton: hidePersistentButton,
		isAdblockEnabled: isAdblockEnabled,
		isAndroid: _isAndroid,
		isAutoFixPrechatSurvey: isAutoFixPrechatSurvey,
		isCEAPIPostChatSurveyMode: isCEAPIPostChatSurveyMode,
		isChatConnected: isChatConnected,
		isChatVisible: isChatVisible,
		isClickStreamSent: isClickStreamSent,
		isCobEngaged: isCobrowseEngaged,
		isCobShared: isSharedControl,
		isEmbeddedThemeValid: isEmbeddedThemeValid,
		isInitializationRequired: isInitializationRequired,
		isIOS: _isIOS,
		isHideJsonTranscriptMessages: _isHideJsonTranscriptMessages,
		isLoggingDisabled: isLoggingDisabled,
		isMobile: _isMobile,
		isMultiChatSupported: isMultiChatSupported,
		isPersistentChat: isPersistentChat,
		isPersistentWindow: isPersistentWindow,
		isPhone: isPhone,
		isPolishNotationEnabled: isPolishNotationEnabled,
		isPortal: isPortal,
		isThankYouEnabled: isThankYouEnabled,
		isV3C2CPersistent: isV3C2CPersistent,
		isV3Continue: isV3Continue,
		JSONParse: FPJSONParse,
		launchNativePostChatSurvey: launchNativePostChatSurvey,
		launchNativeSDK: launchNativeSDK,
		loadKMSlibraries: loadKMSlibraries,
		logAcifError: logAcifError,
		logData: logData,
		logInfo: logInfo,
		logError: logError,
		logErrorToServer: logErrorToServer,
		logInfoToServer: logInfoToServer,
		logWarningToServer: lwt12,
		evaluateLegacySettings: evaluateLegacySettings,
		onAgentDataPass: onAgentDataPass,
		onAgentMsg: onAgentMsg,
		onQueueWaitMsg: onQueueWaitMsg,
		onAssisted: onAssisted,
		onBeforeChatClosed: onBeforeChatClosed,
		onChatLoaded: onChatLoaded,
		onChatMinimize: onChatMinimize,
		onChatroomReady: onChatroomReady,
		onChatShown: onChatShown,
		onCookiesCommitted: onCookiesCommitted,
		onCustomerMsg: onCustomerMsg,
		onEngaged: onEngaged,
		onInteracted: onInteracted,
		onVADataPass: onVADataPass,
		parseXFrameUrl: parseXFrameUrl,
		prefetchURL: prefetchURL,
		postRequestToIframeProxy: postRequestToIframeProxy,
		popOutChat: popOutChat,
		prepareDataAndSendDTEvent: prepareDataAndSendDTEvent,
		preventChatClose: preventChatClose,
		PushToFrameset: PushToFrameset,
		reinitializeChatWithNewId:reinitializeChatWithNewId,
		registerPersistentWindow: registerPersistentWindow,
		registerWDMClient: registerWDMClient,
		requestTranscript: requestTranscript,
		resetConversationManager: resetConversationManager,
		resetInitializationFlag: resetInitializationFlag,
		restartTimer: restartTimer,
		sendAutomatonMessage: _sendAutomatonMessage,
		getFlagSendDataToTSWithoutIframe: getFlagSendDataToTSWithoutIframe,
		sendDTEvent: sendDTEvent,
		sendNetworkBackup: sendNetworkBackup,
		sendRequestToServer: sendRequestToServer,
		sendText: sendText,
		setActiveWindowId: setActiveWindowId,
		setAgentClosedChat: setAgentClosedChat,
		setAgentConfig: setAgentConfig,
		setAsyncChat: setAsyncChat,
		setCABeacon: setCABeacon,
		setChatBanished: setChatBanished,
		setCiFunction: setCiFunction,
		setClickStreamSent: setClickStreamSent,
		setData: setData,
		setDisconnectFlag: setDisconnectFlag,
		setDragable: setDragable,
		setElementPosition: setElementPosition,
		setEventDataForSurvey: setEventDataForSurvey,
		setPersistentButtonDebugActive: setPersistentButtonDebugActive,
		setPersistentWindowActive: setPersistentWindowActive,
		setPopoutChatPosAndDim: setPopoutChatPosAndDim,
		setResizable: setResizable,
		setSurveyAuxParams: setSurveyAuxParams,
		setVarValue: setVarValue,
		setVisible: setVisible,
		setV3Data: setV3Data,
		set3rdPartyCookieFromQueue: set3rdPartyCookieFromQueue,
		setIOSSDKProgress: setIOSSDKProgress,
		setNativeSDKCPStatus: setNativeSDKConversationPlayStatus,
        onC2CEventFromNativeSDK: launchChatByC2CID,
		showAutomaton: showAutomaton,
		showPersistentButton: showPersistentButton,
		showTextInput: showTextInput,
		showThankyou: showThankyou,
		shrinkChat: shrinkChat,
		startChatInterface: startChatInterface,
		startLaunches: startLaunches,
		submitNativePostChatSurvey: submitNativePostChatSurvey,
		updateFrameName: updateFrameName,
		unregisterWDMClient: unregisterWDMClient,
		updateXFrameFromBizRule: updateXFrameFromBizRule,
		verifyToken: verifyToken,
		wasSaleAction: wasSaleAction,
		whenIsPersistent: urtvd3,
		when3rdPartyCookieCommitted: when3rdPartyCookieCommitted,


		/**          CI functions calls        **/

		ciAcceptCobInv: ciAcceptCobInv,
		ciAcceptCobShareInv: ciAcceptCobShareInv,
		ciAcceptVideoInv: ciAcceptVideoInv,
		ciActionBtnCloseChat: ciActionBtnCloseChat,
		ciActionBtnCloseThankyou: ciActionBtnCloseThankyou,
		ciAgentEndsCob: ciAgentEndsCob,
		ciCheckCobrowseMgrAvalibility: ciCheckCobrowseMgrAvalibility,
		ciCloseChat: ciCloseChat,
		ciCobrowseFailHandler: ciCobrowseFailHandler,
		ciCobrowseSuppressedPage: ciCobrowseSuppressedPage,
		ciDeclineCobInv: ciDeclineCobInv,
		ciDeclineCobShareInv: ciDeclineCobShareInv,
		ciDeclineVideoInv: ciDeclineVideoInv,
		ciEngageChat: ciEngageChat,
		ciFocusCobEndBtn: ciFocusCobEndBtn,
		ciGetCobEndButtonID: ciGetCobEndButtonID,
		ciGrowLayer: ciGrowLayer,
		ciHideLayer: ciHideLayer,
		ciIsCircularTabbingEnabled: ciIsCircularTabbingEnabled,
		ciIsMinimized: ciIsMinimized,
		ciMinimize: ciMinimize,
		ciMoveStage: ciMoveStage,
		ciPreparingClosingChat: ciPreparingClosingChat,
		ciRemoveCircularModalWindow: ciRemoveCircularModalWindow,
		ciResizeStage: ciResizeStage,
		ciRestore: ciRestore,
		ciSendCobrowseEnded: ciSendCobrowseEnded,
		ciSendAutomatonDataAsCustomerMessage: ciSendAutomatonDataAsCustomerMessage,
		ciSendMessageQuietly: ciSendMessageQuietly,
		ciSendResultOfBenchmarkTest: ciSendResultOfBenchmarkTest,
		ciSendText: ciSendText,
		ciSetAutomatonDataMapXcd: ciSetAutomatonDataMapXcd,
		ciSetCircularModalWindow: ciSetCircularModalWindow,
		ciSetEngageParameters: ciSetEngageParameters,
		ciSetFocusOnChatInputField: ciSetFocusOnChatInputField,
		ciStopVideo: ciStopVideo,
		ciTransitionPage: ciTransitionPage,
		ciShowLayer: ciShowLayer,
		ciShrinkLayer: ciShrinkLayer,
		getAgentGroupId: getAgentGroupId,

		/** Dummy functions for UI Builder **/
		getIsBuilder: noop,
		getIsSkinLocal: noop,
		noJSHostingInTagserver:noJSHostingInTagserver,
		getClientStaticURL:getClientStaticURL,
		noV3FrameChat:noV3FrameChat,
		getEngageParams:getEngageParams,
		// *************
		//   IMPORTANT
		// *************
		// Add a new methods ABOVE of this comment
		// to see who is the author of the each latest update
		// Let's use alphabetic order for new methods !!!
		noop: noop
		// DO NOT add new lines here!
		// Add new methods ABOVE of the "noop" in ALPHABETIC order!
	}

	function noop() {
	}
}

	/**
	 * Drag/Resize Manager
	 * @class
	 */

function Resize() {
	this.obj = null;
	this.win = window.parent;
	this.doc = window.parent.document;
	this.width = 0;
	this.height = 0;
	this.__init = function(o, oRoot, minX, maxX, minY, maxY, bSwapHorzRef, bSwapVertRef, fXMapper, fYMapper, _win){
		if(typeof o == "undefined" || o==null){
			return;
		}
		Inq.Resize.win = (null == _win) ? this.win : _win ;	/*<% // Allow dragging on any window, however default to client window %>*/
		Inq.Resize.doc = Inq.Resize.win.document ;

		o.box = getParentElByIDTFacade("inqResizeBox");
		doc =  window.parent.document ;
		o.onmousedown	= Inq.Resize.__start;

		o.hmode			= bSwapHorzRef ? false : true ;
		o.vmode			= bSwapVertRef ? false : true ;

		o.root = ((oRoot) && (oRoot != null)) ? oRoot : o ;
		
		/*<% // get the width and height from the root %>*/
		Inq.Resize.width = o.root.clientWidth ;
		Inq.Resize.height= o.root.clientHeight ;

		if (o.hmode  && isNaN(parseInt(o.root.style.left  ))) o.root.style.left   = "0px";
		if (o.vmode  && isNaN(parseInt(o.root.style.top   ))) o.root.style.top    = "0px";
		if (!o.hmode && isNaN(parseInt(o.root.style.right ))) o.root.style.right  = "0px";
		if (!o.vmode && isNaN(parseInt(o.root.style.bottom))) o.root.style.bottom = "0px";

		o.minX	= typeof minX != 'undefined' ? minX : null;
		o.minY	= typeof minY != 'undefined' ? minY : null;
		o.maxX	= typeof maxX != 'undefined' ? maxX : null;
		o.maxY	= typeof maxY != 'undefined' ? maxY : null;
		o.xMapper = fXMapper ? fXMapper : null;
		o.yMapper = fYMapper ? fYMapper : null;

		o.root.onDragStart = function (){};
		o.root.onDragEnd = function (){};
		o.root.onDrag = function (){};
	};

	this.__start = function(e){
		var o = Inq.Resize.obj = this;
		e = Inq.Resize.fixE(e);
		var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
		var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
		
		o.root.onDragStart(x, y);
		if (o.box != null)
		{
			o.box.style.top   = o.root.style.top ;
			o.box.style.left  = o.root.style.left;
			o.box.style.width = o.root.style.width ;
			o.box.style.height = o.root.style.height ;
			o.box.style.border = "thin dotted rgb(32,32,32)" ;
			o.box.style.display = "" ;
			o.style.top = (parseInt(o.root.style.top)+parseInt(o.root.style.height)-16)+"px";
			o.style.left= (parseInt(o.root.style.left)+parseInt(o.root.style.width)-16)+"px";
		}

		o.lastMouseX	= e.clientX;
		o.lastMouseY	= e.clientY;

		if (o.hmode) {
			if (o.minX != null)	o.minMouseX	= e.clientX - x + o.minX;
			if (o.maxX != null)	o.maxMouseX	= o.minMouseX + o.maxX - o.minX;
		} else {
			if (o.minX != null) o.maxMouseX = -o.minX + e.clientX + x;
			if (o.maxX != null) o.minMouseX = -o.maxX + e.clientX + x;
		}

		if (o.vmode) {
			if (o.minY != null)	o.minMouseY	= e.clientY - y + o.minY;
			if (o.maxY != null)	o.maxMouseY	= o.minMouseY + o.maxY - o.minY;
		} else {
			if (o.minY != null) o.maxMouseY = -o.minY + e.clientY + y;
			if (o.maxY != null) o.minMouseY = -o.maxY + e.clientY + y;
		}

		Inq.Resize.doc.onmousemove	= Inq.Resize.resize;
		Inq.Resize.doc.onmouseup	= Inq.Resize.end;

		var newWidth = parseInt(Inq.Resize.obj.style.left) + 16 ;
		var newHeight = parseInt(Inq.Resize.obj.style.top) + 16 ;
		var oDiv = getParentPageElById("inqTitleBar", Inq.Resize.doc) ;
		newWidth = newWidth - 24 ;
		oDiv.style.width = newWidth + "px" ;
		


		return false;
	};

	this.resize = function(e){
		e = Inq.Resize.fixE(e);
		var o = Inq.Resize.obj;

		var ey	= e.clientY;
		var ex	= e.clientX;
		var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
		var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
		var nx, ny;

		if (o.minX != null) ex = o.hmode ? Math.max(ex, o.minMouseX) : Math.min(ex, o.maxMouseX);
		if (o.maxX != null) ex = o.hmode ? Math.min(ex, o.maxMouseX) : Math.max(ex, o.minMouseX);
		if (o.minY != null) ey = o.vmode ? Math.max(ey, o.minMouseY) : Math.min(ey, o.maxMouseY);
		if (o.maxY != null) ey = o.vmode ? Math.min(ey, o.maxMouseY) : Math.max(ey, o.minMouseY);

		nx = x + ((ex - o.lastMouseX) * (o.hmode ? 1 : -1));
		ny = y + ((ey - o.lastMouseY) * (o.vmode ? 1 : -1));

		if (o.xMapper)		nx = o.xMapper(y);
		else if (o.yMapper)	ny = o.yMapper(x);

		nx = ex - o.lastMouseX ;
		ny = ey - o.lastMouseY ;
		var _top = parseInt(Inq.Resize.obj.style["top"]) ;
		var _left = parseInt(Inq.Resize.obj.style["left"]) ;
		Inq.Resize.obj.style["left"] = (_left+nx) + "px";
		Inq.Resize.obj.style["top"] = (_top+ny) + "px";
		
		Inq.Resize.obj.style[o.hmode ? "left" : "right"] = (nx + _left) + "px";
		Inq.Resize.obj.style[o.vmode ? "top" : "bottom"] = ny + _top + "px";

		Inq.Resize.obj.lastMouseX	= ex;
		Inq.Resize.obj.lastMouseY	= ey;

		Inq.Resize.obj.root.onDrag(nx, ny);
	
		/*<%-- If we have a resizing box resize it --%>*/
		if (Inq.Resize.obj.box)
		{
			var height = ny + _top - parseInt(Inq.Resize.obj.box.style.top)+16;
			var width  = nx + _left - parseInt(Inq.Resize.obj.box.style.left)+16;
			if (width >= 16 && height >= 16){			
				Inq.Resize.obj.box.style.width = width + "px";
				Inq.Resize.obj.box.style.height = height + "px";
			}		
 		}		
		return false;
	};

	this.end = function(){
		Inq.Resize.doc.onmousemove = null;
		Inq.Resize.doc.onmouseup   = null;
		
		var newWidth = parseInt(Inq.Resize.obj.style.left) - parseInt(Inq.Resize.obj.root.style.left) + 16 ;
		var newHeight = parseInt(Inq.Resize.obj.style.top) - parseInt(Inq.Resize.obj.root.style.top) + 16 ;
		  		
		if (Inq.Resize.obj.box)	{
			Inq.Resize.obj.box.style.display = "none" ;
		}
		

		Inq.Resize.obj.root.onDragEnd(	parseInt(Inq.Resize.obj.root.style[Inq.Resize.obj.hmode ? "left" : "right"]),
										parseInt(Inq.Resize.obj.root.style[Inq.Resize.obj.vmode ? "top" : "bottom"]));
		if (newWidth < 16 || newHeight < 16){
			newWidth = parseInt(Inq.Resize.obj.root.style.width);
			newHeight = parseInt(Inq.Resize.obj.root.style.height);			
		}
		Application.ResizeStage(newWidth,newHeight);
		Inq.Resize.obj = null;
	};

	this.fixE = function(e){
		if (typeof e == 'undefined') 
		{
			e = Inq.Resize.win.event;
		}
		if (typeof e.layerX == 'undefined') e.layerX = e.offsetX;
		if (typeof e.layerY == 'undefined') e.layerY = e.offsetY;
		return e;
	}
}

function Drag() {
	this.obj = null;
	this.win = window.parent;
	this.doc = window.parent.document;
	

	this.__init = function(o, oRoot, minX, maxX, minY, maxY, bSwapHorzRef, bSwapVertRef, fXMapper, fYMapper, _win){
		Inq.Drag.win = (null == _win) ? this.win : _win ;	/*<% // Allow dragging on any window, however default to client window %>*/
		Inq.Drag.doc = Inq.Drag.win.document ;
		if(typeof o == "undefined" || o==null){
            return;
        }
        o.onmousedown	= Inq.Drag.__start;

		o.hmode			= bSwapHorzRef ? false : true ;
		o.vmode			= bSwapVertRef ? false : true ;

		o.root = oRoot && oRoot != null ? oRoot : o ;

		if (o.hmode  && isNaN(parseInt(o.root.style.left  ))) o.root.style.left   = "0px";
		if (o.vmode  && isNaN(parseInt(o.root.style.top   ))) o.root.style.top    = "0px";
		if (!o.hmode && isNaN(parseInt(o.root.style.right ))) o.root.style.right  = "0px";
		if (!o.vmode && isNaN(parseInt(o.root.style.bottom))) o.root.style.bottom = "0px";

		o.minX	= typeof minX != 'undefined' ? minX : null;
		o.minY	= typeof minY != 'undefined' ? minY : null;
		o.maxX	= typeof maxX != 'undefined' ? maxX : null;
		o.maxY	= typeof maxY != 'undefined' ? maxY : null;

		o.xMapper = fXMapper ? fXMapper : null;
		o.yMapper = fYMapper ? fYMapper : null;
		o.corner = getParentElByIDTFacade("inqDivResizeCorner");

		o.root.onDragStart = function (){};
		o.root.onDragEnd = function (){};
		o.root.onDrag = function (){};
	};
	
	this.__start = function(e){
		var o = Inq.Drag.obj = this;
		e = Inq.Drag.fixE(e);
		var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
		var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
		o.root.onDragStart(x, y);
		if (o.corner) o.corner.style.display="none";

		o.lastMouseX	= e.clientX;
		o.lastMouseY	= e.clientY;

		if (o.hmode) {
			if (o.minX != null)	o.minMouseX	= e.clientX - x + o.minX;
			if (o.maxX != null)	o.maxMouseX	= o.minMouseX + o.maxX - o.minX;
		} else {
			if (o.minX != null) o.maxMouseX = -o.minX + e.clientX + x;
			if (o.maxX != null) o.minMouseX = -o.maxX + e.clientX + x;
		}

		if (o.vmode) {
			if (o.minY != null)	o.minMouseY	= e.clientY - y + o.minY;
			if (o.maxY != null)	o.maxMouseY	= o.minMouseY + o.maxY - o.minY;
		} else {
			if (o.minY != null) o.maxMouseY = -o.minY + e.clientY + y;
			if (o.maxY != null) o.minMouseY = -o.maxY + e.clientY + y;
		}

		Inq.Drag.doc.onmousemove	= Inq.Drag.drag;
		Inq.Drag.doc.onmouseup		= Inq.Drag.end;

		return false;
	};
	
	this.drag = function(e) {
		e = Inq.Drag.fixE(e);
		var o = Inq.Drag.obj;

		var ey	= e.clientY;
		var ex	= e.clientX;
		var y = parseInt(o.vmode ? o.root.style.top  : o.root.style.bottom);
		var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right );
		var nx, ny;

		if (o.minX != null) ex = o.hmode ? Math.max(ex, o.minMouseX) : Math.min(ex, o.maxMouseX);
		if (o.maxX != null) ex = o.hmode ? Math.min(ex, o.maxMouseX) : Math.max(ex, o.minMouseX);
		if (o.minY != null) ey = o.vmode ? Math.max(ey, o.minMouseY) : Math.min(ey, o.maxMouseY);
		if (o.maxY != null) ey = o.vmode ? Math.min(ey, o.maxMouseY) : Math.max(ey, o.minMouseY);

		nx = x + ((ex - o.lastMouseX) * (o.hmode ? 1 : -1));
		ny = y + ((ey - o.lastMouseY) * (o.vmode ? 1 : -1));

		if (o.xMapper)
			nx = o.xMapper(y);
		else if (o.yMapper)
			ny = o.yMapper(x);

		Inq.Drag.obj.style[o.hmode ? "left" : "right"] = nx + "px";
		Inq.Drag.obj.style[o.vmode ? "top" : "bottom"] = ny + "px";
		Inq.Drag.obj.root.style[o.hmode ? "left" : "right"] = nx + "px";
		Inq.Drag.obj.root.style[o.vmode ? "top" : "bottom"] = ny + "px";
		Inq.Drag.obj.lastMouseX	= ex;
		Inq.Drag.obj.lastMouseY	= ey;

		Inq.Drag.obj.root.onDrag(nx, ny);
		return false;
	};
	
	this.end = function() {
		Inq.Drag.doc.onmousemove = null;
		Inq.Drag.doc.onmouseup   = null;
		var newLeft = parseInt(Inq.Drag.obj.root.style["left"]);
		var newTop  = parseInt(Inq.Drag.obj.root.style["top"]);						
		Inq.Drag.obj.root.onDragEnd(parseInt(Inq.Drag.obj.root.style[Inq.Drag.obj.hmode ? "left" : "right"]),
									parseInt(Inq.Drag.obj.root.style[Inq.Drag.obj.vmode ? "top" : "bottom"]));
		Inq.Drag.obj = null;
		if (Application)
			Application.MoveStage(newLeft,newTop);			
	};
	
	this.fixE = function(e)	{
		if (typeof e == 'undefined') e = Inq.Drag.win.event;
		if (typeof e.layerX == 'undefined') e.layerX = e.offsetX;
		if (typeof e.layerY == 'undefined') e.layerY = e.offsetY;
		return e;
	};
}

	function SM19(surveyDataMap){
		var NATIVE_SURVEY_EVENT = "LoadPostChatSurvey";
		this.nativePostChatSurveyCall = null;
		/** @type {boolean} */
		this.isAsyncSurveyCalled = false;
		/** @type {Object} asyncSurveyData
		 * @property {string} asyncSurveyData.engagementID
		 * @property {string} asyncSurveyData.agentGroupID
		 * @property {string} asyncSurveyData.businessUnitID
		 * @property {string} asyncSurveyData.customerID
		 * @property {string} asyncSurveyData.siteID
		 * @property {string} asyncSurveyData.surveyID
		 * @property {string} asyncSurveyData.agentID
		 * @property {string} asyncSurveyData.conversationID
		 */
		this.asyncSurveyData = {};
		this._observable();
		this.defaultWindowSpec = "statusbar=0, scrollbars=1, resizable=1, toolbar=0, menubar=0, copyhistory=0";
		this.poppedWindows = {};
		/**
		 * Contains data that passed by system at chat.exit message.
		 * Data:
		 * <ul>
		 *     <li>conversationResolved {boolean}</li>
		 * </ul>
		 * @type {object}
		 */
		this.eventData = null;
		function getAltSurveyURL(data, evt){
			try{
				var brName = BRM.rb41(CHM.getLastChat().brID).getName();
			}catch(err){
				brName = "NO BR Name Available";
			}
			data["BRName"] = brName;
			data["agentID"] = CHM.getAgentID() ? CHM.getAgentID() : CHM.getLastAgentID();
			data["agentGroupID"] = CHM.getAgentGroupID(evt);

			return ROM.composeURL(data.altURL, data);
		}
		function composeURL(url, data){
			return ROM.composeURL(url, data);
		}

		this.getSurveySpec = function(specID){
			if(inu1(specID)){
				throw new Error("Survey spec is null or undefined.");
			}
			return surveyDataMap[specID];
		};

		/**
		 * Pops out a window with given window specs, window name, URI resource info and url param data.
		 * @param {String} webResourceID The ID of the web resource to use as content for the window to display. Required.
		 * If null or undefined, will return with no action. (log error)
		 * @param {String} winName the name of the window to use in creating or referring. Required. If null or undefined,
		 * no action will be taken and an error will be logged to console.
		 * @param {Object=} data Optional param for the placement of data onto the URL as parameters.
		 * @param {String=} winSpecDataStr Optional string param that may contain name-value pairs that specify the
		 * size/location etc of the window. @see http://www.w3schools.com/jsref/met_win_open.asp under "specs" for complete
		 * of supported specs here.
		 */
		this.popwindow = function(webResourceID, winName, data, winSpecDataStr){
			var webResource = resources[webResourceID];

			if(!!webResource){
				if(!!winName){
					if(webResource.method=="POST"){
						try {
							var lwin = this.poppedWindows[winName] = win.open("", winName, winSpecDataStr);
							var div = lwin.document.createElement("div");
							var formName = "TCSurveyWin"+(SM19.IDX++);
							var formStr = "<form id='"+formName+"' name='"+formName+"' action='"+webResource.url+"' method='POST' target='"+winName+"'>\n";
							for(var name in data){
								if(typeof data[name]=="function") continue;
								formStr += ("\t<input type='hidden' id='"+name+"' name='"+name+"' value='"+data[name]+"'>\n");
							}
							formStr += "</form>";
							div.style.cssText="position:absolute;top:0px;left:0px;width:1px;height:1px;";
							div.innerHTML = formStr;
							lwin.document.body.appendChild(div);
							div.firstChild.submit();
						} catch (e) {
							log(e);
						}
						lwin.document.removeChild(div);
					}else{
						this.poppedWindows[winName] = win.open(
							ROM.composeURL(webResource.url, data),
							winName,
							!!winSpecDataStr?winSpecDataStr:this.defaultWindowSpec
						);
					}
				} else {
					log("Popout Window Error: winName is required but not provided.");
				}
			}else{
				log("Popout Window Error: Web resource not found for popout window for resource ID = "+webResourceID);
			}
		};

		/**
		 * Fetches the surveyID from the altURL for a given survey url.
		 * @param {String} surveyURL surveySpecID from which to parse the altURL to get the surveyID
		 * @param {Number} [defaultID] this default is returned on any error or when a surveyID cannot be parsed from url
		 * @returns {Number} surveyID from the provided URL. Returns defaultID if the url is not parsable.
		 */
		this.parseSurveyIdFromURL = function(surveyURL, defaultID){
			try {
				// we parse the surveyID from the url... assuming it's keysurvey format like the following:
				// https://app.keysurvey.com/f/1025822/bec1/?LQID=1&
				if (surveyURL) {
					var found = surveyURL.match(/http.*\/(\d+)\/[a-fA-F0-9]+\/.*/);
					if (found && found.length > 1) {
						return parseInt(found[1]);
					}
				}
			}catch (err){
				log("Survey spec lookup error: Survey URL '"+surveyURL+"' parse failure. err="+err);
			}
			return defaultID;
		};

		/**
		 * Sets survey config and fires event to load native post chat survey
		 *
		 * @param {string} url
		 */
		this.launchNativePostChatSurvey = function (url) {
			this.asyncSurveyData = getParamsFromURL(url);

			if (!isEmptyObject(this.asyncSurveyData)) {
				this.isAsyncSurveyCalled = true;
				this.nativePostChatSurveyCall = {
					data: {
						"surveyId": this.asyncSurveyData["surveyID"]
					},
					rule: CHM.getChat().getRule()
				};
				this.fireNativeSurveyLaunchEvent();
			} else {
				let12(
					"Cannot display native post chat survey due to incorrect survey config: " + url,
					true
				);
			}
		};

		this.fireNativeSurveyLaunchEvent = function() {
			if (this.richPostChatSurveyCall && window.messagingApp) {
				this.setSurveyShown(1);
				window.messagingApp.showPostChatSurvey(this.richPostChatSurveyCall.data.surveyId, this.richPostChatSurveyCall.data)
			} else if (this.nativePostChatSurveyCall) {
				var data = this.nativePostChatSurveyCall.data;
				fireCustomEvent(NATIVE_SURVEY_EVENT, data, this.nativePostChatSurveyCall.rule);
				this.nativePostChatSurveyCall = null;
				this.setSurveyShown(1);
				if (isPostChatSurveyLogsEnabled()) {
					lmt12(
						"Native post chat survey was shown. Survey id " + data.surveyId,
						LOG_LEVELS.INFO,
						null,
						true
					);
				}
			} else {
				if (isPostChatSurveyLogsEnabled()) {
					lwt12(
						"Post chat survey won't be shown, "
						+ "because survey data is absent."
					);
				}
			}
		};

		/**
		 * Method invocation will reset evtData. evtData should be reset after firing all BRs. For preventing closing chat window or firing different rules.
		 */
		this.onChatLaunched = function () {
			this.setEventDataForSurvey(null);
		};

		/**
		 * Shows the survey for a given specID, rule and allows for selective overrides.
		 * @param surveySpecID
		 * @param rule
		 * @param brSurveySpecOverride
		 * @param preSurveyDataPass
		 * @param windowFeatures override
		 * @param [surveyUrlOverride] surveyURL override
		 * @param surveyReporting
		 * @param nativePostChat
		 * @param evt
		 */
		this.showSurvey = function(surveySpecID, rule, brSurveySpecOverride, preSurveyDataPass, windowFeatures, surveyUrlOverride, surveyReporting, nativePostChat, evt, richPostChat){
			if (isPostChatSurveyLogsEnabled()) {
				lmt12(
					"showSurvey was called.",
					LOG_LEVELS.INFO,
					null,
					true
				);
			}
			this.isAsyncSurveyCalled = false;
			var windowSpec = ", " + (windowFeatures || this.defaultWindowSpec) + ",";
			var chat = CHM.getChat();
            var chatID = chat ? chat.getChatID() : CHM.getLastChatID();
			var lastChat = CHM.getLastChat();
			var brID = chat ? chat.getRuleId() : lastChat ? lastChat.brID : "";
			var ruleEvt = rule.evt || evt;
			var openSurveyCnt = 0;

			if (nativePostChat || richPostChat) {
				if (chat && (!chat.isAsyncChat() || chat.isAgentClosedChat())) {
					FP.preventChatClose(true);
				}
				if (isNonAsyncChatOrValidAsyncSurvey(chat, this.eventData)) {
					buildFormData(evt, rule);
					if (richPostChat) {
						buildAdditionalData();
						this.richPostChatSurveyCall = {
							data: preSurveyDataPass,
							rule: rule
						};
					} else {
						this.nativePostChatSurveyCall = {
							data: preSurveyDataPass,
							rule: rule
						};
					}
					preSurveyDataPass.surveyId = surveySpecID;

					var resName = "tcSrv_" + getSiteID();
					var callback = function showSurveyRequestCookieCallback(context) {
						var currentChat = CHM.getChat();
						var cObj = parseCookieData(CM._getCookies(context.data))["tcSrv"];
						if (cObj && !cObj["_surv"]) {
							if (currentChat && currentChat.isAgentClosedChat()) {
								this.fireNativeSurveyLaunchEvent();
							} else {
								if (isPostChatSurveyLogsEnabled()) {
									lwt12(
										"Native Survey Launched event "
										+ "won't be fired in SM19#showSurvey, "
										+ "because chat wasn't closed by agent"
									);
								}
							}
						} else {
							if (isPostChatSurveyLogsEnabled()) {
								lwt12(
									"Chat will be closed without showing post chat survey, "
									+ "because by data in cookies it was already shown."
								);
							}
							// Close chat
							CHM.closeChat();
						}
					}.bind(this);

					CM.requestCookie(callback, resName);
				} else {
					if (isPostChatSurveyLogsEnabled()) {
						lwt12(
							"Async chat will be closed, "
							+ "because conversation wasn't resolved by agent."
						);
					}
					// Async cases.
					// Should close chat Window for cases when we shouldn't open survey and agent closed chat. (We prevented chat closing before.)
					// Shouldn't close chat Window if chat closed by customer and we didn't open TYI.
					if (chat.isAgentClosedChat()) {
						CHM.closeChat();
					}
				}
			} else {

				var data = this.getSurveySpec(surveySpecID);
				if (surveyUrlOverride) {
					windowURL = surveyUrlOverride;
				}

				if (data){
					MI8.mixAbsorber(data);
					if(brSurveySpecOverride) {
						data.absorb(brSurveySpecOverride); // merge DB values with rules values (rules values overriding)
					}

					var surveyURL = surveyUrlOverride || data.altURL;
					if (!surveyURL) {
						let12("Survey processing error: altURL parameter isn't set.", true);
						return;
					}
					try {
						if(inu1(chatID) || chatID == "0") {
							throw ("ChatID is null or undefined.");
						}

						if (surveyReporting) {
							// For survey reporting, we want to post default data into the survey request.
							// survey reporting will supplement the data to be posted into the survey
							// window by the business rule tag.
							var surveyID = this.parseSurveyIdFromURL(surveyURL, surveySpecID);
							var automatonID = "SAT_"+surveyID;
							var surveyName = data.name ? data.name : automatonID;
							buildFormData(evt, rule);
							var automatonStartedData = {
								_domain: "automaton",
								evt: "started",
								automatonID: automatonID,
								automatonStartedBy: ("BR," + (CHM.getChat() ? CHM.getChat().getRuleId() : ((evt && evt.rule) ? evt.rule.id : rule.getID()).toString())),
								automatonName: surveyName,
								startedIn: "div",
								automatonType: "satisfactionSurvey",
								businessUnitID: CHM.getBusinessUnitID(),
								chatID: chatID,
								customerID: Inq.getCustID(),
								initialCustomerID: CONVM.getInitialCustomerID(),
								conversationID: CONVM.getConversationID(),
								incAssignmentID: asi4(),
								sessionID: getSessionID(),
								siteID: getSiteID(),
								pageID: CHM.getLaunchPageId(),
								businessRuleID: brID,
								deviceType: getDeviceType(),
								operatingSystemType: getOSType(),
								browserType: getClientBrowserType(),
								browserVersion: cbtv1(),
								agentGroupID: CHM.getAgentGroupID(ruleEvt),
								visitorAttributes: VAM.getCopyAsArray(true).join(";"),
								brAttributes: firstExisting('ra1t', CHM.getChat(), rule),
								agentID: CHM.getAgentID() ? CHM.getAgentID() : CHM.getLastAgentID(),
								availableAgentAttributes: CHM.getChatOrLastChatAgentAttributesString(),
								countryCode: FP.getCustGeoData() ? FP.getCustGeoData().country_code : "",
								regionCode: FP.getCustGeoData() ? FP.getCustGeoData().region_code : ""
							};
							logAutomatonStartedEvent(automatonStartedData);
							var w = 635; //default
							var h = 650;
							var x = data.x ? data.x : 0;
							var y = data.y ? data.y : 0;
							var uiWebView = isAndroidWebView() || isIOSWebView();

							if (data && !inu1(data.w)) {
								w = data.w;
							}
							if (data && !inu1(data.h)) {
								h = data.h;
							}
							try {
								//IE throws Permission Denied error if we are trying to modify not blank window
								if (uiWebView) {
									SVYM.surveyWindow = window.parent;
								} else {
									SVYM.surveyWindow = win.open("", getRandomTitle(), windowFeatures ? windowFeatures
										: ("left=" + x + ",top=" + y + ",width=" + w + ",height=" + h + ",scrollbars=yes,resizable=yes"));
								}
							} catch (e) {
								let12("Can't launch survey window :" + e, true);
							}
						} else {
							var logData = null;
							if (!!lastChat) {
								logData = {
									_domain: "chat",
									evt: "surveyPresented",
									siteID: Inq.getSiteID(),
									businessUnitID: rule.getBusinessUnitID(),
									chatID: lastChat.id,
									customerID: Inq.getCustID(),
									sessionID: getSessionID(),
									incAssignmentID: asi4(),
									stage: "post-chat",
									surveyID: surveySpecID
								};
								if (lastChat.svyPrms) {
									MI8.mixAbsorber(logData);
									logData.absorb(lastChat.svyPrms);
								}
								ROM.send(urls.logDataURL, logData);

							}
							data["customerID"] = logData.customerID;
							data["businessUnitID"] = logData.businessUnitID;
							data["busUnitID"] = logData.businessUnitID;
							data["sessionID"] = logData.sessionID;
							data["stage"] = logData.stage;
							data["incAssignmentID"] = logData.incAssignmentID;
							data["siteID"] = logData.siteID;
							data["surveyContent"] = "";
							data["ClientID"] = logData.siteID;
							data["clientID"] = logData.siteID;
							data["chatID"] = logData.chatID;
							data["override"] = 1;
							data["custID"] = data.customerID;

							if (lastChat.svyPrms) {
								MI8.mixAbsorber(data);
								data.absorb(lastChat.svyPrms);
							}
							var windowURL = surveyUrlOverride ? surveyUrlOverride : (data.altURL.length > 0) ? getAltSurveyURL(data, ruleEvt) : ROM.composeURL(surveyURL, data)
							this.surveyWindow = win.open(
								windowURL,
								'SurveyWindow' + getRandomTitle(),
								('top=' + (data.y ? data.y : 0) + ', left=' + (data.x ? data.x : 0) + windowSpec + ' width=' + (data.w ? data.w : 0) + ', height=' + (data.h ? data.h : 0))
							);
						}
					} catch (e) {
						lwt12("Survey processing error: " + e);
					}
				} else {
					let12(
						"Survey Error: no survey spec found. surveySpecID=" + surveySpecID,
						true
					);
				}
			}

			/**
             * getRandomTitle: Created for bug RTDEV-16779 because when we do a
             * parent.self.open("target", "title", "features"), if the title  has
             * a period in it, then it errors out in IE. Therefore, this method was
             * created to remove the period.
             * @description: This method returns number but without the period
             * @returns string
			 */
			function getRandomTitle() {
				var s = ""+Math.random();
				if(s.indexOf(".")!=-1){
					s = s.substring(s.indexOf(".")+1,s.length);
				}
				return s;
			}

            function logAutomatonStartedEvent (loggingData) {
                var url = urls.baseURL + "/survey/surveyReport";
                //log automaton.started event and only after that open popup with survey
                ROM.post(url, loggingData, null, true, submitFormToSurveyWindow);
                if (isPersistentWindow()) {
                    FP.preventChatClose(true);
                }
            }

            function submitFormToSurveyWindow() {
                openSurveyCnt++;
                //In FF there is special readyState "uninitialized" for blank window
                if (!inu1(SVYM.surveyWindow) && SVYM.surveyWindow.document &&
                    (SVYM.surveyWindow.document.readyState === "complete" || SVYM.surveyWindow.document.readyState === "uninitialized")) {
                    surveyURL = prepareURLForPostRequest(surveyURL);
					if (uiWebView) {
						surveyURL = surveyURL + "?gbURL=" + window.parent.location.href.replace("#", "_");
					}
                    var survForm = SVYM.surveyWindow.document.createElement("form");
                    survForm.name = "surveyForm";
                    survForm.id = "inqSurveyForm";
                    survForm.action = surveyURL;
                    survForm.method = "POST";
                    survForm.style.display = "none";

                    for (var k in preSurveyDataPass) {
                        if (typeof preSurveyDataPass[k] === "function"
                            || typeof preSurveyDataPass[k] === "object"
                            || k == "height"
                            || k == "width") {
                            continue;
                        }
                        if (k == "agentAttr") {
                            getAAforKeySurvey(preSurveyDataPass[k], SVYM.surveyWindow)
                        } else {
                            addInput(k, preSurveyDataPass[k], SVYM.surveyWindow);
                        }
                    }
                    if (!SVYM.surveyWindow.document.body) {
                        /* Workaround for IE8 (compatibility mode and quirks mode) */
						var surveyWindow = SVYM.surveyWindow;
						setTimeout(function() {
							surveyWindow.document.body.appendChild(survForm);
							surveyWindow = null;
                            survForm.submit();
                        }, 1);
                    } else {
                        SVYM.surveyWindow.document.body.appendChild(survForm);
                        survForm.submit();
                    }

					// clean reference to survey window to enable possibility create an other survey window (important for FF)
					SVYM.surveyWindow = null;

                    log("Survey URL: " + surveyURL);
                    if (isPersistentWindow()) {
                        FP.closeChatInterface();
                        FP.closeChat();
                        window.parent.close();
                    }
                } else {
                    if (openSurveyCnt > 100) {
                        openSurveyCnt = 0;
						let12(
							"Survey window was not shown,"
							+ " possibly bad connection or popup blocker works.",
							true
						);
                        return;
                    }
                    setTimeout(submitFormToSurveyWindow, 100);
                }

                function addInput(name, value, sWin) {
                    var input = sWin.document.createElement("input");
                    input.type = "hidden";
                    input.name = name;
                    input.value = value;
                    survForm.appendChild(input);
                }

                function getAAforKeySurvey(aa, sWin) {
                    var aaObj = MI8.JSON.parse(aa);
                    for (var i in aaObj) {
                        if (aaObj.hasOwnProperty(i)) {
                            for (var j in aaObj[i]) {
                                if (aaObj[i].hasOwnProperty(j)) {
                                    addInput(i, ((aaObj[i])[j]).replace(/\s+/g, ''), sWin);
                                }
                            }
                        }
                    }
                }
            }

			/**
			 * Returns true for non async chats.
			 * For launching async survey need to follow next conditions:
			 * {object} chat is not null, if chat is null, we return true to prevent behavior changes,
			 * chat is Async({boolean} chat.isAsyncChat()),
			 * {object} eventData is not null,
			 * {boolean} eventData.conversationResolved is true, Async survey launches if conversation was resolved as agent,
			 * @param {Chat} chat
			 * @returns {boolean}
			 * @param {Chat} chat
			 * @param {object} eventData stores params for launching survey.
			 * @returns {boolean}
			 */
			function isNonAsyncChatOrValidAsyncSurvey(chat, eventData) {
				return !chat || !chat.isAsyncChat() || (eventData && eventData.conversationResolved);
			}

			function prepareURLForPostRequest(url) {
				/* Since we have a prepared url for GET request we need to prepare it for POST */
				return secureHTTP(url
					.replace(/\?[^\/]*$/, "") // First replacing removes all parameters which there are in the url string.
					.replace("keysurvey.com", "keysurvey.com/votingmodule/s180")); // Second replacing corrects the url for POST request to KyeSurvey provider.
			}

			function buildFormData (evt, rule) {
				var ruleByID =  BRM.rb41(brID);
				// Now for the form data...
				var formDataAddition = {
					chatID: chatID,
					customerID: Inq.getCustID(),
					agentID: CHM.getAgentID() ? CHM.getAgentID() : CHM.getLastAgentID(),
					custID: Inq.getCustID(),
					initialCustomerID: CONVM.getInitialCustomerID(),
					conversationID: CONVM.getConversationID(),
					incAssignmentID: asi4(),
					sessionID: getSessionID(),
					visitorAttributes: VAM.getCopyAsArray(false).join(";"),
					automatonAttributes: "",
					siteID: getSiteID(),
					clientID: getSiteID(),
					pageID: LDM.getPageID(),
					businessUnitID: CHM.getBusinessUnitID(evt, rule),
					businessRuleID: brID,
					busUnitID: CHM.getBusinessUnitID(evt, rule),
					BRName: ruleByID ? encodeURIComponent(ruleByID.getName()) : ""
				};
				var agentGroupId = CHM.getAgentGroupID(ruleEvt);
				if(agentGroupId) {
					formDataAddition.agentGroupID = agentGroupId;
				}
				var badValues = [];
				var coreData = ["siteID", "customerID", "businessUnitID"];
				getDefaultAgentGroupId() && coreData.push("agentGroupID");
				for(var i = 0; i < coreData.length; i++) {
					inu1(formDataAddition[coreData[i]]) && badValues.push(coreData[i]);
				}
				if(badValues.length > 0) {
					lwt12("Some core fields are empty for survey datapass : " + String(badValues));
					return;
				}
				if(preSurveyDataPass){
					for(var key in preSurveyDataPass) {
						inu1(preSurveyDataPass[key]) && !inu1(formDataAddition[key]) && delete preSurveyDataPass[key];
					}
					MI8.mixAbsorber(preSurveyDataPass).absorb(formDataAddition);
				}
				else{
					preSurveyDataPass = formDataAddition;
				}
			}

			function buildAdditionalData() {
				preSurveyDataPass.availableAgentAttributes = CHM.getChatOrLastChatAgentAttributesString();
				preSurveyDataPass.brAttributes = firstExisting('ra1t', CHM.getChat(), rule);
				preSurveyDataPass.countryCode = FP.getCustGeoData() ? FP.getCustGeoData().country_code : "";
				preSurveyDataPass.regionCode = FP.getCustGeoData() ? FP.getCustGeoData().region_code : "";
				preSurveyDataPass.deviceType = getDeviceType();
				preSurveyDataPass.operatingSystemType = getOSType();
				preSurveyDataPass.browserType = getClientBrowserType();
				preSurveyDataPass.browserVersion = cbtv1();
				preSurveyDataPass.preAssigned = isPreassignedChat();
			}
		};

		this.reset = function () {
			this.isAsyncSurveyCalled = false;
			this.nativePostChatSurveyCall = null;
		};

		/**
		 * Need for transferring data from ChatExitMessageHandler.
		 * @param {object} eventData stores params for launching and validation surveys.
		 */
		this.setEventDataForSurvey = function (eventData) {
			this.eventData = eventData;
		}

	}
	MI8.prepare(SM19).im13(MI8.Observable).im13(MI8.XJA3);
	SM19.IDX = 0;
	SM19.prototype.isListener = function (l) {
		return (!!l && (l.onSurveyLaunchEvent || l.fireSurveySubmitted || l.onChatLaunched));
	};

	SM19.prototype.fireSurveyLaunched = function(chatdata, _src){
		var evt = MI8.mixAbsorber({id:++this.evtIdx, evtType:this.TYPES.SLAUNCHED, timestamp:new Date(), src:_src});
		evt.absorb({chatID:chatdata.chatID, ruleID:chatdata.ruleID, customerID:mockCustID});
		var buID = chatdata["buID"] ? chatdata["buID"] : null;
		var agID = chatdata["agID"] ? chatdata["agID"] : null;
		if (!(agID && buID) || parseInt(buID) <= 0 || parseInt(agID) <= 0) {
			var rule = BRM.rb41(chatdata.ruleID);
			if (rule) {
				buID = buID && parseInt(buID) > 0 ? buID : rule.getBusinessUnitID();
				agID = agID && parseInt(agID) > 0 ? agID : rule.getAgentGroupID();
			}
		}
		if (agID && parseInt(agID) > 0) {
			evt.absorb({agentGroupID: agID});
		}
		if (buID && parseInt(buID) > 0) {
			evt.absorb({businessUnitID: buID});
		}
		this._fireEvt(
			function(l, evt){
				if(typeof l.onSurveyLaunchEvent=="function") l.onSurveyLaunchEvent(evt);
			},
			evt
		);
	};

	/**
	 * @deprecated
	 *
	 * @param chatdata
	 * @param _src
	 */
	SM19.prototype.fireSurveySubmitted = function(chatdata, _src){
		// Not used right now
//		var evt = MI8.mixAbsorber({evtType:SM19.TYPES.SSUBMIT, timestamp:new Date(), src:_src});
//		evt.absorb(chatdata);
//		this._fireEvt(
//			function(l, evt){
//				if(typeof l.onSurveySubmitEvent=="function")
//					l.onSurveySubmitEvent(evt);
//			},
//			evt
//		);
	};

	SM19.prototype.setSurveyShown = function(value) {
		var surveyShown = PM.getVar("surveyShown");
		if(!surveyShown) {
			surveyShown = new VER34("surveyShown", 0, resources["surveyShown"], "_surv", function(o){ return parseFloat(o);});
			surveyShown.init();
			surveyShown.z3(value);
			PM.addVar(surveyShown);
		} else {
			surveyShown.z3(value);
		}
	};

	SM19.prototype.getSurveyShown = function() {
		var variable =  new VER34("surveyShown", 0, resources["surveyShown"], "_surv", function(o){ return parseFloat(o);})
		return !!variable.z0();
	};

	SM19.prototype.TYPES = SM19.TYPES = {SLAUNCHED:"SLAUNCHED", SSUBMIT:"SSUBMIT"};

	/**
	 * This method is for CEAPI-Post-Chat-Survey rule action only. The rule's firing condition function ensures this
	 * method is executed under CEAPIPostChatSurveyMode only.
	 * @param rule The "CEAPI-Post-Chat-Survey" rule defined in createCEAPIPostChatSurveyRule.
     */
	SM19.prototype.launchCEAPINativePostChatSurvey = function(rule) {
		// isACIFReady will be set to true when ACIF fires the 'StorageReady' custom event.
		var isACIFReady = PM.getVar("isACIFReady").z0();
		if (!isACIFReady && isACIFLoadedFromBR()) {
			// Wait for ACIF fires the 'StorageReady' custom event, make sure ACIF is ready to listen to IJSF event i.e. "ACIFCanvasReady".
			var cRule = rule;
			window.setTimeout(function() {
				log("Waiting for ACIF Ready when StorageReady custom event is fired.");
				SVYM.launchCEAPINativePostChatSurvey(cRule);
			}, 100);
		} else {
			var npcsData = parent.CEAPI_POST_CHAT_SURVEY_DATA;
			var chatSpec = JSON.parse(npcsData.surveyChatSpecJSON);
			var chatSpecField = "survey_post_chat_standard";
			if (isMobileDevice()) {
				chatSpecField = "survey_post_chat_" + getDeviceType().toLowerCase();
			}
			if (inu1(chatSpec)
				|| inu1(chatSpec[chatSpecField])
				|| !e9(chatSpec[chatSpecField].id, false)
				|| !e9(chatSpec[chatSpecField].chatThemeId, false)
			) {
				var msg = plc1(
					"Unable to launch the post chat survey. Invalid Post-Chat Survey settings configurations.",
					npcsData.engagementID,
					npcsData.customerID,
					null,
					npcsData.siteID,
					"-1"
				);
				let12(msg, false);
			} else {
				var chatSpec = {
					id: chatSpec[chatSpecField].id,
					oId: -1,
					igaa: true,
					ignHOP: true,
					chatTheme: {id: chatSpec[chatSpecField].chatThemeId}
				};
				CHM.launchChatForNativePostChatSurvey(rule.getID(), chatSpec, npcsData);
			}
		}
	};

	SM19.prototype.isConversationResolvedOrEmtpyStatus = function () {
		return inu1(this.eventData) || this.eventData.conversationResolved;
	};

	/**
	 * This method creates a "CEAPI-Post-Chat-Survey" rule for the purpose of launching the ACIF
	 * post chat survey from a CEAPI all. This method should only be called in CEAPI Post Chat Survey Mode.
	 * @param id The rule id.
	 * @return The rule.
	 */
	 SM19.prototype.createCEAPIPostChatSurveyRule = function (id) {
		var npcsData = parent.CEAPI_POST_CHAT_SURVEY_DATA;
		 // Create Rule and mock necessary BusinessRule methods to avoid error. Not create BR to avoid the
		 // conversionFunnel.targeted, conversionFunnel.eligible conversionFunnel.exposureQualified in ETL logs when
		 // we only need the survey automaton ETL logs.
		return Rule.create({
			id: id,
			name: "CEAPI-Post-Chat-Survey",
			tt1: function () {
				return [{id: "onPageLanding"}]
			},
			cc2: function () {
				// Trigger only in CEAPI Post Chat Survey Mode.
				return isCEAPIPostChatSurveyMode();
			},
			getBusinessUnitID: function () {
				return npcsData.businessUnitID;
			},
			getAgentGroupID: function () {
				return npcsData.agentGroupID;
			},
			af3: function (rule) {
				SVYM.launchCEAPINativePostChatSurvey(rule);
			},
			getAutomatonParams: function () {
				return [{automatonID: npcsData.surveyID, context: "ci", location: "center"}];
			},
			active: true
		});
	 };

	/**
	 * The API object will consolidate our customers external use of our framework into a unified API
	 * All customer access should eventually be through this access object.
	 * @param pageID
	 * @param dat
	 * @see LE12#init
	 */
	function reinitChat(pageID, dat){
		if(!isInqInitialized) {
			lmt12("Reject reinitChat request since tcFramewor is initating a chat.", LOG_LEVELS.INFO);
			return;
		}
		try {
			//Added logging to detect possible problems on the client side to get information which function calls reinit function(CustomerAPI) RTDEV-14320.
			try {
				var caller = ((arguments.callee ? arguments.callee.caller : null) + "").substring(0, 100);
			} catch (e) {
				caller = "<unavailable - seems to be a strict mode caller>";
			}
			try {
				lmt12("Reinit Framework: " + plc1() + "Caller: " + caller, LOG_LEVELS.INFO);
			} catch (e) {} // just for sure, that we 100% don't affect existing code
			Inq.overridePageID = undefined;
			win.inqSiteID = pageID;
			var data = ((dat && dat.constructor == String) ? MI8.JSON.parse(dat) : dat);
			if (!CHM.isPersistentWindow()) {
				if (isWebSDK) {
					executeReinitCall(window.v3Lander, pageID, data);
				} else {
					executeReinitCall(window.parent.v3Lander, pageID, data);
				}
			}
		} catch(e) {
			let12("Error on reinitChat call." + cf21(e));
		}
	}

	/**
	 * Executes re-init chat on give v3lander object
	 * @param v3LanderObj
	 * @param pageID
	 * @param data
	 */
	function executeReinitCall(v3LanderObj, pageID, data) {
		var isAnotherPage = !v3LanderObj.page || (v3LanderObj.page && v3LanderObj.page.id !== pageID);
		if (v3Lander.isRplMode && isAnotherPage) {
			v3LanderObj.reInitChatData = {pageID: pageID, data: data};
			//call in scope of parent document
			v3LanderObj.resolvePage();
		} else {
			reinitChatV3Callback(pageID, data);
		}
	}

	function reinitChatV3Callback(pageID, data) {
		try {
			// stop all cobrowse event handlers
			/* added additional '&& Inq.CBC.reset' check, to prevent 'Object doesn't support property or method 'reset''
			 which was found in production logs, see RTDEV-14619 */
			if (Inq.CBC && Inq.CBC.reset) {
				Inq.CBC.reset();
			}
			/* If we are passing in data, we want to set it globally so data pass rules may pick it up */
			if (data) {
				if (data['pass']) {
					win.inqData = data['pass']; //BR30 uses "pass" as data pass reference...
				}
				else if (data['data']) {
					win.inqData = data['data']; //BR20 uses "data" as data pass reference.
				}
			}
			if (data && data.sale) {
				var s = data.sale;
				var w = win;
				w.inqSalesProducts = s.products;
				w.inqSalesPrices = s.prices;
				w.inqSalesQuantities = s.quantities;
				w.inqTestOrder = s.test;
				w.inqClientOrderNum = s.ordernum;
				w.inqClientTimeStamp = s.timestamp;
				w.inqCustomerName = s.customerName;
				w.inqOtherInfo = s.otherInfo;
			}

			/*
			 RTDEV-15619 : DirecTV page is calling reinitChat many times and each call is causing Memory Leak.
			 */
			if (pageID && pageID > 0) {
				Inq.overridePageID = pageID;
			}
			updateSessionData(function () {
					resetManagers(pageID);
				}
			);
		}catch(e){
			let12("Error on reinitChatV3Callback call." + cf21(e));
			v3Lander.reInitChatData = null;
		}
	}

	/**
	 * Updates session data if chat doesn't displayed on page.
	 * @param {function} callbackFunc
	 */
	function updateSessionData(callbackFunc) {
		if (CHM.isInlineChatInProgress()) {
			callbackFunc();
		} else {
			CM.requestSessionData(callbackFunc);
		}
	}

	/**
	 * Resets C2CM, LDM and BRM managers. Fires rules with new page marker.
	 * @param {number=} pageID - page id
	 */
	function resetManagers(pageID) {
		C2CM.reset();
		LDM.init(true);
		BRM.reset();
		BRM.resetForReinit();
		BRM.init(true);
		BRM.start();
		// _resolvePage() may be invoked from LDM.init() and need not be invoked again if the page is resolved already. This improves the performance - RTDEV-28899
		if (!pageID && LDM.getPageID() === -1) {
			LDM._resolvePage();
		}
		Inq.PM.resetTmpVars();     // Reset temVars.
		Inq.unblockService("ALL");  // This will reset all suppressed services
		LDM.start();
		if (Inq.CBC) {
			Inq.CBC.resetHtmlFilter();
		}
	}

	/**
	 * If the tcFramework was reloaded we have to disable monitoring mutations for previous tcFramework
	 *
	 * @deprecated since RTDEV-15957
	 */
	function resetObserver() {
		if (isWebSDK) {
			return;
		}

		if (doc.body.getAttribute('data-inq-observer') == '1') {
			win.Inq.observer.disconnect();
			doc.body.setAttribute('data-inq-observer', '0');
		}
	}

	function launchChatNowByPageID(ruleID){
		// find chat rule in BR object
		var rule = BRM.rb41(ruleID);
		if(rule != null) {
			EVM.fireManualInvocationEvent(rule);
		}
	}

	function launchChatNow(ruleName){
		// find chat rule in BR object
		var rule = BRM.getRuleByName(ruleName);
		if(rule != null) {
			EVM.fireManualInvocationEvent(rule);
		}
	}

	function setChatSuppressedForSession() {
		Inq.tryue("ALL", 0); // -1 forever, 0 session, >0 other duration
	}

	function blockChat( scope ){
		switch( scope ){
			case "page":
				break;
			case "session":
				Inq.tryue("ALL", 0); // -1 forever, 0 session, >0 other duration
				break;
			default:
				break;
		}
	}

	function getSaleID(){
		var saleID = -1;
		try {
			var saleIdVar = PM.getVar("saleID");
			if (!!saleIdVar) {
				var sid = saleIdVar.z0();
				saleID = inu1(sid) ? -1 : sid;
			}
		}catch(err){
			saleID = -1;
		}
		return saleID;
	}

	function getChatID(){
		var chatID = -1;
		try{
			if( !!CHM.getChatID() )
				chatID = CHM.getChatID();
		}catch(err){
			chatID = -1;
		}
		return chatID;
	}

	function showClickToCallHtml(index, html){
		C2CM.getC2C(index).showClickToCallHtml(html);
	}

	/**
	 * Returns data from the data managers for the IJSF.
	 * @public
	 * @return {Object} map of data objects keyed by object ID
	 * @see exposeCustomerApi
	 */
	function getData(){
		var dataMap = getMgrData(mgrList);
		//deprecated
		//to get cdnUrl use Inq.API.get('cdnURL')
		//should be removed in future.
		dataMap["cdnURL"] = urls.cdnURL;
		return dataMap;
	}

	/**
	 * Returns CDN url.
	 * @private
	 * @return {string} CDN url
	 * @see APIGetter
	 */
	function getCDNUrl() {
		return urls.cdnURL;
	}

	/**
	 * Returns engagementID.
	 * @private
	 * @return {string} engagementID
	 * @see APIGetter
	 */
	function getEngagementId() {
		return CHM.getChatID();
	}

	/**
	 * Returns value of requested property.
	 * See
	 * @link https://jira.touchcommerce.com/browse/RTDEV-20451
	 * @param {string} requested property
	 * @return {string|boolean}
	 * @see exposeCustomerApi
	 */
	function APIGetter(tokenId) {

		switch (tokenId) {
			case "cdnUrl":
				return getCDNUrl();
				break;
			case "engagementId":
				return getEngagementId();
				break;
			case "staticClientURL":
				return site.clientStaticUrl;
				break;
			case "noJSHostingEnabled":
				return site.noJSHosting;
				break;
			case "conversationId":
				return CONVM.getConversationID();
			default:
				if (tokenId) {
					var err = new Error("Unknown property " + tokenId + " requested");
				} else {
					var err = new Error("Parameter required");
				}
				throw(err);
		}

	}

	/**
	 * provides API data to external caller. Helper
	 * @private
	 * @param list {Array} Array of objects that possibly support the DataExporter interface.
	 * @see getData
	 * @return {Object} map of data objects keyed by object ID
	 */
	function getMgrData(list){
		var retval = {};
		for(var idx=0; idx<list.length; idx++){
			var mgr = list[idx];
			if( !!mgr.getData && typeof mgr.getData == "function"){
				retval[mgr.getID()] = mgr.getData(); // get standard data
			}
		}
		return retval;
	}


	/**
	 * API call to close current chat
	 */
	function closeChat() {
		if(window.inqFrame) {
			try {
				if (typeof window.inqFrame.closeChat === "function") {
					window.inqFrame.closeChat();
				}
			} catch (e) { /* Ignore Error in TC code */ }
		}
	}

	/**
	 * Sends automaton message to AI and/or CI
	 * @param {String} msgType - the message type. values are "system" or "datapass"
	 * @param {String} message - the message to be sent.
	 * there can be two more parameters which are cssClass and context.
	 *        Case 1: 1 optional parameter
	 *                This parameter can be cssClass or context.  If the String value is either "agentInterface"
	 *                or "customerInterface", then it is a context parameter.  Otherwise it is considered cssClass.
	 *        Case 2: 2 or more parameters
	 *                We only consider the first two parameters.  In this case the first optional parameter will be
	 *                cssClass (to be consistent with RTDEV-17612) and the second will be context.  The value of the context
	 *                parameter must be either "agentInterface" or "customerInterface", case sensitive.
	 *                If misspelled, the message will not be sent and an error will be logged.
	 */
	function sendAutomatonMessage(msgType, message) {
		var misspelledContext = false;
		var cssClass = null;
		var context = null;
		if (arguments.length > 2) {
			switch(arguments.length) {
				case 3:
					if (arguments[2] === "agentInterface" || arguments[2] === "customerInterface") {
						context = arguments[2];
					} else {
						cssClass = arguments[2];
					}
					break;
				case 4:
				default: // 4 or more parameters.  We are only care the first 4th parameters.
					cssClass = arguments[2];
					context = arguments[3];
					if (context !== "agentInterface" && context !== "customerInterface") {
						lmt12(plc1("No automaton message will be sent because of misspelled context=" + context + ". Expecting 'agentInterface' or 'customerInterface' "));
						misspelledContext = true;
					}
					break;
			}
		}
		if (!misspelledContext) {
			FP.sendAutomatonMessage(msgType, message, cssClass, context);
		}
	}

	/**
	 * For publishing API with the publish-js-api-function action tag
	 * @param apiString an identifier to be added as a function to customer page.
	 * @param varid name of variable to be returned in API function
	 * @param ruleID specify id of rule
	 * @param _win specify window object if null win.parent will be by default
	 * An example of such an identifier is "InqSaleMgr.getSaleID". This API would have to be invoked as
	 * InqSaleMgr.getSaleID() in a customer page.
	 * If apiString is not a composite identifier (no point separators) and customer page already possesses such object,
	 * it will be overwritten. If apiString is a composite identifier and customer page already possesses such object,
	 * this object will be supplemented. This is done to enable publishing several objects w/o overwriting previously published ones.
	 */
	function publishAPI(apiString, varid, ruleID, _win) {
        var winObj = isWebSDK ? FrameBridge : (_win || window.top);
		if (!apiString || apiString.constructor !== String || !winObj) {
            lmt12(plc1("Cannot publish API function, it is null or incorrect String " + apiString + " or window object is null or undefined"));
			return false;
		}
        try {
            var osa = String(apiString).split(".");
            var fcn = function () {
				var varRef = PM.getVar(varid, BRM.rb41(ruleID));
                return varRef ? varRef.z0() : null;
            };
            for (var idx = 0; idx < osa.length; idx++) {
                var token = osa[idx];
                if (!token) continue;
                if (idx === (osa.length - 1)) {
                    // a leaf object with the same name will be overwritten
                    winObj[token] = fcn;
                } else if (inu1(winObj[token]) || typeof winObj[token] !== "object") {
                    // if non-leaf object already e9, we will add to it
                    winObj[token] = {};
                }
                winObj = winObj[token];
            }
        } catch (e) {
            lmt12(plc1("Cannot publish API function " + apiString + ", error occurred during processing " + e.message));
            return false;
        }

		return true;
	}

	function stop_CBC() {
		var cbc = FP.getCBC();
		if (cbc) {
			cbc.stop();
		} else {
			let12("CBC is not defined on FP.getCBC().stop call.", true);
		}
	}

	function toggleMenuBoxForCobBanner_CBC() {
		var cbc = FP.getCBC();
		if (cbc) {
			cbc.toggleMenuBoxForCobBanner();
		} else {
			let12("CBC is not defined on FP.getCBC().toggleMenuBoxForCobBanner call", true);
		}
	}

	function toggleTermsAndConditionDivForCobBanner_CBC() {
		var cbc = FP.getCBC();
		if (cbc) {
			cbc.toggleTermsAndConditionDivForCobBanner();
		} else {
			let12("CBC is not defined on FP.getCBC().toggleTermsAndConditionDivForCobBanner call", true);
		}
	}

	function getTermsAndConditions_CBC(flag) {
		var cbc = FP.getCBC();
		if (cbc) {
			cbc.termsAndConditions(flag);
		} else {
			let12("CBC is not defined on FP.getCBC().termsAndConditions call", true);
		}
	}

    function sendText() {
		FP.ciSendText();
	}

	function declineCobShareInv() {
		FP.ciDeclineCobShareInv();
	}

	function declineCobInv() {
		FP.ciDeclineCobInv();
	}

	/**
	 * Provides CI function to resize the chat interface and display the chat in full screen mode.
	 * @throws {Error} Application should be initialized
	 * @return {boolean}
	 */
	function expandChat() {
		return FP.expandChat();
	}

	/**
	 * Provides CI function to resize chat interface when software keyboard is displayed.
	 * @throws {Error} Application should be initialized
	 * @return {boolean}
	 */
	function shrinkChat() {
		return FP.shrinkChat();
	}

	/**
	 * Publishes public API calls for Inq. Ideally this would be the only place to publish such functions but
	 * LandingFramework.js breaks encapsulation many times over.
	 */
	function exposeCustomerApi() {
		var win = isWebSDK ? window.FrameBridge: window.parent;
		if(inu1(win.Inq)) {
			win.Inq = {};
			win.Inq.SaleMgr= {};
		}
		if (inu1(win.Inq.CBC) && site.enableCobrowse) {
			win.Inq.CBC = {};
		}

		if (inu1(win.Inq.API)){
			win.Inq.API = {};
		}
		win.Inq.launchChatNowByPageID = launchChatNowByPageID;
		win.Inq.launchChatNow         = launchChatNow;
		win.Inq.setChatSupressedForSession  = setChatSuppressedForSession;
		win.Inq.setChatSuppressedForSession = setChatSuppressedForSession;
		win.Inq.blockChat  = blockChat;
		win.Inq.reinitChat = reinitChat;
		win.Inq.reinitChatV3Callback = reinitChatV3Callback;
		win.Inq.reinit     = reinitChat;
		win.Inq.SaleMgr = {getSaleID: getSaleID, getChatID: getChatID};
		win.Inq.showClickToCallHtml = showClickToCallHtml;
		win.Inq.fireCustomEvent = fireCustomEvent;
		win.Inq.getData = getData;
		win.Inq.sendAutomatonMessage = sendAutomatonMessage;
		win.Inq.observer = domObserver;
		win.Inq.closeChat = closeChat;
		win.Inq.DMgr = {
			switchForModule: DMgr.switchForModule
		};
		// RTDEV-15590 - Publish the following CBC APIs to be used by cobrowse script instead of inqFrame.Inq which
		// be privatized in the future.
		if(site.enableCobrowse) {
			win.Inq.CBC.stop = stop_CBC;
			win.Inq.CBC.toggleMenuBoxForCobBanner = toggleMenuBoxForCobBanner_CBC;
			win.Inq.CBC.toggleTermsAndConditionDivForCobBanner = toggleTermsAndConditionDivForCobBanner_CBC;
			win.Inq.CBC.termsAndConditions = getTermsAndConditions_CBC;
			win.Inq.CBC.ciDeclineCobShareInv = declineCobShareInv; // RTDEV-20073
			win.Inq.CBC.ciDeclineCobInv = declineCobInv;
		}
		win.Inq.SDK = FP.getSDKInst();
		win.Inq.ciSendText = sendText; // RTDEV-16993 - publish Inq.ciSendText function
		win.Inq.isInqInitialized = isInitialized;
		win.Inq.API.get = APIGetter;
		win.Inq.API.CI = {};
		win.Inq.API.CI.expandChat = expandChat;
		win.Inq.API.CI.shrinkChat = shrinkChat;
	}

function CG(includeIds, includeCGIds, includeURLFunction, excludeIds, excludeCGIds, excludeURLFunction, businessUnits) {
    /* lookup table... fast lookup */
    var _lut = {};
    var _includeIds = includeIds ? includeIds : [];
    var _includeCGIds = includeCGIds ? includeCGIds : [];
    var _includeURLFunction = includeURLFunction;


    var _excludeIds =  excludeIds ? excludeIds : [];
    var _excludeIdQuick = {};
    var _excludeURLFunction = excludeURLFunction;
    var _excludeCGIds =  excludeCGIds ? excludeCGIds : [];
    this.length = _includeIds.length;

    for (var idx = 0; idx < _includeIds.length; idx++) {
        _lut[_includeIds[idx]] = _includeIds[idx]; /* populate lookup table */
    }

    for (var i = 0; i < _excludeIds.length; i++) {
        _excludeIdQuick[_excludeIds[i]] = _excludeIds[i]; /* populate lookup table */
    }

    var buIDs = businessUnits;
    /**
     * check: is current CG contain (pgId + url)
     * @param pgID page id
     * @param url page url
     * @param contentGroups array of cg (to check include/ exclude CG ids)
     * @return true if current CG contains (pgId + url)
     */
   this.contains = function(pgID, url, contentGroups) {
        /* check excluded ids */
        if (typeof _excludeIdQuick[pgID]=='number') {
            return false;
        }

        /* check excluded groups */
        if (this.isInCGList(_excludeCGIds, pgID, url, contentGroups)) {
            return false;
        }

        /* check excluded URLs */
        if (url && _excludeURLFunction && _excludeURLFunction(url)) {
            return false;
        }

        /* check included ids */
        if (typeof _lut[pgID]=='number') { /* fast lookup O(log n) for JS hashes (instead of iterating through list) */
            return true;
        }
        /* check included group ids */
        if (this.isInCGList(_includeCGIds, pgID, url, contentGroups)) {
            return true;
        }
        /* check included url; */
        return url && _includeURLFunction && _includeURLFunction(url);
    };

    /**
     * check is cgList contain  (pgID, url)
     * @param cgList list of CG
     * @param pgID page id
     * @param url page url
     * @param contentGroups all CG
     * @return true if (pgId + url) are in cgList 
     */
    this.isInCGList = function(cgList, pgID, url, contentGroups) {
        for (var i = 0; i < cgList.length; i ++) {
            var cg = contentGroups[cgList[i]];
            if (!cg) {
                continue;
            }
            if (cg.contains(pgID, url, contentGroups)) {
                return true;
            }
        }
        return false;

    };

    this.getBusinessUnits = function(){
        return buIDs ? buIDs : null;
    };
}

/**
 * factory for CG object
 * @static
 * @param d {Array} representing the constructor for CG
 * @returns {CG}
 */
CG.c = function(d){
	return new CG(d[0],d[1],d[2],d[3],d[4],d[5],d[6]);
};

	function CRMT(callback){
		this.absorb(callback);
	}
	MI8.prepare(CRMT).im13(MI8.XJA3).im13(MI8.RC54).im13(MI8.JSON);

	CRMT.create = function(callback){
		return new CRMT(callback);
	};

	CRMT.prototype.onRemoteCallback = function(dstr){
		var data = typeof dstr == "string" ? this.parse(dstr) : dstr;
		this.doCallbackActions(data);
	}

	/**
	 * Class is a wrapper for the launching of services and data pass as an encapsulation.
	 * @class 
	 * @param d data consisting of {
	 * @param {Object} rule rule for the launch context.
	 * @param {String} serviceType service string identifier
	 * @param {function} onAgentAssigned optional agent
	 */
	function SL1(d){
		this.absorb(d);
		this.data = d; // we keep this around to use as an anonymous listener if needed
	}
	MI8.prepare(SL1).im13(MI8.XJA3);
	/**
	 * Factory method.
	 */
	SL1.c = function(data){
		return new SL1(data);
	};
	/**
	 * Method that kick starts the service launch via chat manager.
	 */
	SL1.prototype.request = function(){
		if(this.data.onAgentAssigned)
			EVM.addListener(this.data); // use as anonymous listener to send data as necessary

		if (this.flashvarFcn) {
			CHM.registerFlashvarFcn(this.flashvarFcn);
		}

		// INVEST-346 "All Clients are recieining Agent 0 again on Agent Conversion report for sales"
		// show-conversive may specify agent that should be attributed for sale
		if (this.data.agtid) this.chatSpec.aid = this.data.agtid;
		if (this.fabPlugin) {
			this.chatSpec.pn = this.fabPlugin;
		}
		/* This is a very edge case where a persistant chat window is being triggered
		 * and mean while another rule triggers to launch a proactive chat, in this case it is beter
		 * to close the peristant window and move aahead with proactive chat
		 */
		if (CHM.popoutWindow != null && !CHM.isChatInProgress()) {
		    // if persistent window is ready then return
		    if (CHM.persistentWindow) {
		        return;
            }
		    // if persistent window is not ready close the popup and continue
			CHM.popoutWindow.close();
		}
		this.launchChat();
	};

	/**
	 * Launches chat and updates cookies before request chat.
	 * If chat is in progress then resets chat requests queue
	 */
	SL1.prototype.launchChat = function () {
		CM.requestSessionData(function () {
				if (CHM.isChatInProgress()) {
					log("Chat already in progress... rule chat request ignored." + (this.rule ? " Rule=" + this.rule.toString() : ""));
					C2CM.showDisabledIcon();
					CHM.resetChatRequestsQueue(this.rule);
				} else {
					var chatLaunchSource = "SL1#launchChat";
					CHM.removeChatInstance(chatLaunchSource);
					CHM.request(this.rule, this.chatType, this.chatSpec, "", null, null, this.useNative, this.extChatJS, chatLaunchSource);
				}
			}.bind(this)
		);
	};

	function DFV(i, f, v, initial){
		this.id = i;
		this.f = f;
		this.v = v;
        this.initial = initial;
	}
	DFV.c = function(i,f,v, initial){
		return new DFV(i,f,v, initial);
	};
	
	DFV.prototype.toString = function(dflt){
		var result = dflt;
		try{
			if (isWebSDK) {
				result = this.f();
			} else {
				result = s7("(" + this.f.toString() + ")()", {});
			}
		}catch(err){
			log("DFV ["+this.id+"] execution failed:" + err);
		}
		var template = this.v;
		for(var name in result){
			var s = result[name];
			template = template.replace("${"+name+"}", s);
		}
		return template;
	};

/**
 * ...
 * @author fpinn@touchcommerce.com
 */

window.XFormsLoader = function(){
	/**
	 * The prefix "_$" used to indicate that this fields need parse as JSON object
	 * Use constant names same as in Java code
	 */
	var INITIATOR = "_$initiator";
	var LOCATION = "_$location";
	var PERSISTENT_CUSTOMER_ID = "_persistCustId";
	var INITIAL_CUSTOMER_ID = "_initialCustId";
	var CONVERSATION_ID = "_conversationId";
	/**
	 * Defines XForm lifetime, during this period XForm will be restored in correct state after navigation
	 * Equals to Resin default session time (30 minutes)
	 * @type {number} Session duration in milliseconds
	 */
	var SESSION_DURATION = 30*60*1000;

	var _JSON = MI8.JSON;

	/**
	 * Convert object to string in JSON format
	 */
	function stringify(obj) {
		return _JSON.stringify(obj);
	}

	/**
	 * Formats JSON string to JS type
	 * @param {string} str
	 * @return {any}
	 */
	function parse(str) {
		return _JSON.parse(str);
	}

	/**
	 * Logs to console. If Inq.log is available, use it to honor our javascript logging settings.
	 * Otherwise, log directly to console.
	 * @param text text to log
	 */
	function log(text){
		if (Inq && Inq.log) {
			Inq.log("XF: " + text);
		} else if (window.console) {
			window.console.log("XF: " + text);
		}
	}

	/**
	 * Convenience method to log errors.
	 * @param {Error} e error to log
	 * @returns {Function} function for convenient logging of extra values
	 */
	function logError(e){
		log("Error: " + e.message);
		if (e.origin) {
			log("   at " + e.origin);
		} else if (logError.caller != null) {
			log("   at " + logError.caller.toString().split("{")[0]);
		}
		return function(value) {
			log("   trace:[" + value + "]")
		};
	}

	var XFormsLoader = function(){
		/** @type {XMLHttpRequestFacade} */
		this._xhr = null;
		/** @type {String} automaton ID or name */
		this._dtid = "";
		/** @type {String} source URL */
		this._source = "";
		/** @type {HTMLElement} */
		this._xframe = null;
		var headerData = {};
		/** @type {Number} */
		this.index = XFormsLoader.instances.length ;
		XFormsLoader.instances.push(this);		/* Save this instance in array to ensure scoping and to ensure that instance is not removed by Garbage Collector before we are finished */

		/**
		 * Build query string for request from the headerData structure
		 * as additional URL parameters (should be appended to URL with at least one parameter in its query string).
		 *
		 * @param data headerData sctucture
		 * @returns query string
		 */
		function getQuery(data) {
			var query = "";
			try {
				for (var key in data) {
					query += "&" + key + "=" + encodeURIComponent(data[key]);
				}
			} catch (e) {
				logError(e);
			}
			return query;
		}

		/**
		 * Create first URL parameter for Loadbalancer use
		 * (we use the same parameter as in RTDEV-8734).
		 *
		 * @returns {string} load balancer sticky parameter
		 */
		function getLBStickyAsFirstParameter() {
			return "?customerID=" + Inq.getCustID();
		}

		/**
		 * Creates new IFrame for XForm
		 * @param div container div where iframe is created
		 * @param url URL where div will be submitted later
		 * @param businessUnitID channel Id if update is required
		 * @param scrolling optional, controlling scrolbars for IFrame, default value is "no"
		 * @param data
		 * @param overrideRule
		 * @param initiator
		 * @param location
		 * @param initOnLoad initOnLoad optional, indicates whether the automaton is started during initialization chat skin, default value is "false"
		 * @param {('GET'|'POST')} method HTTP method to send data to XForms Server, GET is default
		 * @return newly created iframe
		 */
		this.createXFrame = function(div, url, businessUnitID, scrolling, data, overrideRule, initiator, location, initOnLoad, method) {
			var chat = CHM.getChat();
			var rule = overrideRule ? overrideRule : (chat ? chat.getRule() : null);

			headerData = {
				// url is required for post to know where to go
				url: url,
				siteID: Inq.getSiteID(),

				// data required for xFormExtensions to operate properly
				workerPath: "window.com.inq.flash.client.control.XFrameWorker",
				clientHtml: getHostedFileUrl(),

				// data for xforms
				_chatID: CHM.getChatID() ? CHM.getChatID() : "",
				_agentID: (CHM.getAgentID()) ? CHM.getAgentID() : "",
				_businessUnitID: getBusinessUnitId(businessUnitID),
				_siteID: Inq.getSiteID(),
				_customerID: Inq.getCustID(),
				_sessionID: FP.getSessionID(),
				_incAssignmentID: FP.asi4(),
				_clientPageURL: FP.getClientPageURL(),
				_pageMarker: LDM.getPageMarker(),
				_pageID: initOnLoad ? CHM.getLaunchPageId() : LDM.getPageID(),
				_language: rule ? rule.getLanguage() : Inq.getDefaultLanguage(),
				_visitorAttributes: VAM.getCopyAsArray(true).join(";"),
				_brAttributes: rule ? rule.ra1t() : "",
				_browserType: getClientBrowserType(),
				_browserVersion : cbtv1(),
				_operatingSystemType : getOSType(),
				_deviceType : getDeviceType(),
				_qt: CHM.q6t() ? CHM.q6t() : "",
				_externalCustomerIDs: VAM.getExternalCustomerIdVisitorAttributesAsString(),
				_countryCode: FP.getCustGeoData().country_code,
				_regionCode: FP.getCustGeoData().region_code
			};

			if (chat && chat.getAutomatonSpecData()) {
				try {
					headerData._automatonDataMap = stringify(chat.getAutomatonSpecData());
				} catch (e) {
					logError(e)("automatonDataMap is malformed for rule " + rule.getID() + " siteID=" + Inq.getSiteID() + " customerID=" + Inq.getCustID());
				}
			} else {
				var automatonDataMap = PM.getVar("automatonDataMap");
				if (automatonDataMap) {
					var value = automatonDataMap.z0();
					if (value) {
						headerData._automatonDataMap = prepareAutomatonDataMap(value);
					}
				}
			}

			var brId = "";

			if (rule) {
				headerData._brName = rule.getName();
				headerData._brId = brId = rule.getID();
			}

			headerData[INITIATOR] = stringify(initiator ? initiator : {type: "br", id: brId});
			headerData[LOCATION] = location ? stringify(location) : "";

			var agID = getAgentGroupId(location, rule, chat);
			if (agID) {
				headerData._agentGroupID = agID;
			}

			var persistentCustomerID = FP.getPersistentCustomerID();
			if (persistentCustomerID) {
				headerData[PERSISTENT_CUSTOMER_ID] = persistentCustomerID;
			}

			var initialCustomerID = CONVM.getInitialCustomerID();
			if (initialCustomerID) {
				headerData[INITIAL_CUSTOMER_ID] = initialCustomerID;
			}
			var conversationID = CONVM.getConversationID();
			if (conversationID) {
				headerData[CONVERSATION_ID] = conversationID;
			}

			for (var field in data) {
				if (!headerData[field]) { // do not populate if we have never value
					headerData[field] = data[field];
				}
			}

			var nameIFrame = encodeURIComponent(MI8.JSON.stringify(headerData));
			if (!scrolling) scrolling = "no";
			div.innerHTML = '<IFRAME width="100%" height="100%" class="inqChatFoo" frameborder="0" scrolling="' + scrolling + '" ' +
				'name="' + nameIFrame + '" ></IFRAME>';

			this._xframe = div.getElementsByTagName("IFRAME")[0];

			if (checkForOutdatedAutomaton(chat, location, data.dtid)) {
				return this._xframe;
			}

			this._xframe.headerData = headerData;

			if (url) {
				this._source = url;
				this._dtid = data.dtid;
				if (!!method && method == "POST") {
					ROM.post(url, headerData);
				} else {
					this.loadForm(url);
				}
			}
			return this._xframe;
		};

		/**
		 * Prepares passed data to valid JSON object or replaces
		 * with the empty string and sends error to the server
		 *
		 * @param {*} value
		 * @return {string}
		 */
		function prepareAutomatonDataMap(value) {
			if (typeof(value) !== "string") {
				value = stringify(value);
				lwt12(
					"The 'automatonDataMap' contains incorrect value type: "
					+ value + ". Converted to JSON format."
				);
			}

			return isAutomatonDataMapValid(value) ? value : "";
		}

		/**
		 * Validates 'automatonDataMap' value and send error to server if it is needed
		 * @param {string} value
		 * @return {boolean}
		 */
		function isAutomatonDataMapValid(value) {
			var obj;

			try {
				obj = parse(value);
			} catch (e) {
				let12(
					"The 'automatonDataMap' value is not correct JSON string: "
					+ value
					+ ". "
					+ cf21(e)
				);
				return false;
			}

			if (typeof(obj) === 'object' && obj !== null && !Array.isArray(obj)) {
				return true;
			} else {
				let12(
					"The 'automatonDataMap' value is not an Object: " + value + ". ",
					true
				);
				return false;
			}
		}

		/**
		 * Skip automaton loading if session has expired.
		 * State is stored on server during 30 minutes (default resin session).
		 * See RTDEV-13085
		 * @param {Object} chat chat object
		 * @param {Object} location location of automaton div or chat
		 * @param {String} dtid automaton ID or name
		 * @return {boolean} Returns true if need to stop automaton loading
		 */
		function checkForOutdatedAutomaton(chat, location, dtid) {
			var skipLoad = false;
			if (chat && location && location.type != "div") {
				var automatons = CHM.getCiAutomatons();
				var now = new Date().getTime();
				if (automatons[location.id] && automatons[location.id].dt == dtid && automatons[location.id].time + SESSION_DURATION < now) {
					log("This automaton: " + dtid + " was already initialized at this chat session, possibly cache expired or this chat is old");
					skipLoad = true;
				} else {
					//"time" is a timestamp of automaton initialization after the navigation, "dt" - automaton ID
					automatons[location.id] = {time: now, dt: dtid};
					CHM.setCiAutomatons(automatons);
				}
			}
			return skipLoad;
		}

		/**
		 * Get agent group id
		 * if automaton start in div then get agent group id from BR that show automaton.
		 * if automaton start in chat:
		 *   if agent assigned then get agent group id of current agent
		 *   if agent don't assigned then get agent group id of current chat (initial set by BR)

		 * @param location where start automaton
		 * @param rule rule that start automaton
		 * @param chat chat in that context start automaton
		 * @returns {string} agent group id or null
		 */
		function getAgentGroupId(location, rule, chat) {
			if (chat && location && location.type == "chat") {
				var chatAgID = chat.getChatAgentGroupID();
				if (chatAgID) {
					return chatAgID;
				} else {
					return chat.getAgentGroupID();
				}
			} else {
				return rule ? rule.getAgentGroupID() : null;
			}
		}

		/**
		 * Returns businessUnitId to be passed to XF server
		 * If there is assigned chat with agent then returns buID of owner
		 * Otherwise set overridden buID value
		 * Otherwise set buID from rule chat was started by
		 * And last resort is defaultBuID
		 * @param businessUnitIdOverride
		 * @return {Number} businessUnitId value
		 */
		function getBusinessUnitId(businessUnitIdOverride) {
			var chat = CHM.getChat();
			var buID;
			if (chat && chat.getChatBusinessUnitID() != -1) {
				buID = chat.getChatBusinessUnitID();
			} else {
				buID = businessUnitIdOverride ? businessUnitIdOverride : FP.getBusinessUnitID();
			}

			return buID;
		}

		/**
		 * Start xform loading.
		 * Automaton request pushed to queue and start request of JSESSIONID, after get JSESSIONID we send request to automaton.
		 * While we wait for JSESSIONID response we can have some also requests, they will be put to queue and will send after get JSESSIONID.
		 *
		 * @param automatonRequestUrl url to XForms server
		 */
		this.loadForm = function(automatonRequestUrl) {
			XFormsLoader.requestQueue.push(this);

			if (!XFormsLoader.isGetSessionIdInProgress) {	/* if jsessionid loading is not in progress then start it */
				XFormsLoader.getJavaSessionId(automatonRequestUrl, 1);
			}
		};

		/**
		 * Get URL to request JSESSIONID.
		 */
		XFormsLoader.getSessionIdUrl = function (automatonRequestUrl) {
			/* break the URL into parts, so we can extract the protocol and domain */
			var parts = automatonRequestUrl.split("/");
			/* Index for the protocol is 0, format is protocol://domain/... */
			var protocol = parts[0];
			/* Index for the domain is 2, format is protocol://domain/... */
			var domain = parts[2];
			/* the /jsid/getSession controller returns the java session id */
			return  protocol + "//" + domain + "/" + parts[3] + "/jsid/getSessionId" + getLBStickyAsFirstParameter();
		};

		/**
		 * Asks server for JSESSIONID, if we have one, it validates the id
		 *		Upon completion the JSESSIONID is persisted if in IJSF
		 *		Then the xform is loaded.
		 * @param automatonRequestUrl automaton servlet URL (needed to determine JSESSIONID servert URL)
		 * @param attemptNumber number of attempt to get JSESSIONID
		 * @return nothing
		 * @see obtainedSessionId
		 */
		XFormsLoader.getJavaSessionId = function (automatonRequestUrl, attemptNumber) {
			try {
				if (window.top == window.parent && window == window.top.inqFrame) {		/* Ensure that we are in the IJSF */
					var sessionId = XFormsLoader.initJsid();
					XMLHttpRequestFacade.jsessionid = (!!sessionId) ? sessionId : null;
					var xhr = new XMLHttpRequestFacade();
					var urlGetSessionId = XFormsLoader.getSessionIdUrl(automatonRequestUrl);
					xhr.open("GET", urlGetSessionId, true);		/* register the URL for retrieving the java session id */
					xhr.onreadystatechange  = function() {		/* register handler for retrieving the response from the server */
						if (xhr.readyState == XMLHttpRequestFacade.DONE) {		/* Check to see if we are completed */
							/* Check response code */
							if (xhr.status == 200) {
								/* process the java session id */
								XFormsLoader.obtainedSessionId(xhr.response);

								/* clear progress flag */
								XFormsLoader.isGetSessionIdInProgress = false;
							} else if (xhr.status == 404) {
								/* A 404 return code indicates that the request completed successfully,
								 * but that the server doesn't recognize the getSessionId endpoint.
								 * This happens when the form we're trying to load is NOT hosted on the
								 * XForms server. (As for the Paymetric integration, see RTDEV-8041.)
								 *
								 * This is a quick, TEMPORARY fix to keep us on schedule until a
								 * better solution can be developed.
								 */
								let12(
									"XFormsLoader.getJavaSessionId: Can't get JSESSIONID. " +
									"attempts=[" + attemptNumber + "] status=[" + xhr.status + "] response=[" + xhr.response + "]",
									true
								);
								XFormsLoader.isGetSessionIdInProgress = false;
								XFormsLoader.continueLoadingForms();
							} else if (xhr.status == 0 && attemptNumber < XFormsLoader.MAX_ATTEMPTS_COUNT) {
								/* network issue, retry get JSESSIONID and continue automaton loading after 1sec */
								/* (the flag isGetSessionIdInProgress don't reset) */
								setTimeout(
									function () {
										XFormsLoader.getJavaSessionId(automatonRequestUrl, attemptNumber + 1);
									},
									1000
								);
							} else {
								/* bad response code or a retry attempts have been exhausted */
								/* we don't have reason to continue automaton loading */
								/* clear progress flag */
								XFormsLoader.isGetSessionIdInProgress = false;

								/* log response code to TS */
								let12(
									"XFormsLoader.getJavaSessionId: Can't get JSESSIONID. " +
									"attempts=[" + attemptNumber + "] status=[" + xhr.status + "] response=[" + xhr.response + "]",
									true
								);
							}
							xhr.onreadystatechange = null;						/* Turn off the checking of ready state change */
							xhr = null;
						}
					};
					XFormsLoader.isGetSessionIdInProgress = true;				/* set progress flag */
					xhr.send();
				} else {
					/* We are not in the IJSF, we are in the XFORMS frame, so we already have the JSID in the XMLHttpRequest.jsessionid */
					XFormsLoader.continueLoadingForms();
				}
			} catch (e) {
				logError(e)("getJavaSessionId");
			}
		};

		/**
		 * Handles server response with session id. Persists JSESSIONID in IJSF and loads xform.
		 * This method is published because of the way loader calls it.
		 * @see getJavaSessionId - the caller
		 * @see loadForm - loads the form after we have the java session id
		 */
		XFormsLoader.obtainedSessionId = function (jSessionId) {
			if (jSessionId.length > 0) { /* If we have a session id, then we must register it and persist it */
				/* Register the jsid, Tell the extended XHR that we have a session id for it to use */
				XMLHttpRequestFacade.jsessionid = jSessionId;
				XFormsLoader.persistJsid(jSessionId); /* Persist the id */
			}
			XFormsLoader.continueLoadingForms(); /* Load the form */
		};

		/**
		 * Send all requests from queue to continue forms loading
		 */
		XFormsLoader.continueLoadingForms = function () {
			for (var i = 0; i < XFormsLoader.requestQueue.length; i++) {
				XFormsLoader.requestQueue[i].continueLoadingForm();
			}
			XFormsLoader.requestQueue = [];
		};

		/**
		 * continueLoadingForm: private
		 * load form via AJAX request
		 *		The form is read via AJAX and written into the document
		 *		Once the page is read, it is applied to the document via obtainedSourceHtml
		 * @return url with query string
		 * @see obtainedSourceHtml
		 */
		this.continueLoadingForm = function() {
			this._xhr = new XMLHttpRequestFacade();

			var XFormsLoaderInst = this;
			this._xhr.onreadystatechange = function() {		/* When the AJAX call changes state, analyse it */
				var xhr = this;								/* Get the AJAX structure (xhr) */
				if (xhr.readyState == XMLHttpRequestFacade.DONE) {	/* Check to see if we are completed */
					XFormsLoaderInst.obtainedSourceHtml(xhr.response);
					XFormsLoaderInst = null;
				}
			};
			var url = this._source + getLBStickyAsFirstParameter() + getQuery(headerData);
			this._xframe["href"] = url;			/* Add the full url with query string so that the Xform Iframe can retrieve it */
			this._xhr.open("GET", url, true);	/* Tell xhr the name of the url to retrieve */
			this._xhr.send();					/* And send it to the server */
			return false ;
		};

		/** fixDocumentRewriteBug - Fixes WebKit's peculiarity - it does not reset global variables when re-writing document.
		 *  Also fixes problem in IE, where when the document is rewritten, the domain is restored.
		 *  With sub-domains this becomes a problem because the xform cannot communicate with the IJSF or the CI (same origin policy)
		 *  To fix this we inject a document.domain setting in a script tag into the new document and this fixes the domain.
		 * @param html - string containing HTML to be modified and counterIncrement
		 * @param win - the xform iframe's content window
		 * @param {string} [locationHost=window.location.host] location.host which will be used
		 * @param {string} [documentDomain=document.domain] documentDomain - domain which will be used
		 * @return corrected html string
		 */
		function fixDocumentRewriteBug(html, win, locationHost, documentDomain) {
			/* The DOCUMENT_REWRITE_BUG global variable is necessary for detection of the WebKit's peculiarity. */
			try {
				win.DOCUMENT_REWRITE_BUG = true;
			} catch(e){
				logActionErr(e, this);
			}
			locationHost = locationHost || window.location.host;
			documentDomain = documentDomain || document.domain;

			html = html.replace('</head>', '<script type="text/javascript">if (typeof DOCUMENT_REWRITE_BUG != "undefined") {top.inqFrame.Inq.FlashPeer.formsLoader.resetGlobalVars(window);}</script></head>');
			var host = locationHost.replace(/:\d+$/, "");
			if (host != documentDomain) {
				html = html.replace(/(<\s*body\b[^>]*>)/gi, '\n$1\n<script type="text/javascript">try{document.domain=\"' + documentDomain + '";}catch(er){}</script>\n');
			}
			return html;
		}
		/** The above function fixDocumentRewriteBug is a function in scope to this object only and is not accessible to the unit tests
		 * We add the following to make this function accessible from the instance.
		 * BTW: this function was made as a function in the scope, so when onsubmit is caught in an anonymous function, we can access it, it would be in scope.
		 */
		this.fixDocumentRewriteBug = fixDocumentRewriteBug;	/* Make fixDocumentRewriteBug accessible via the object (needed for unit testing only */

		/** obtainedSourceHtml - We arrive here when we have the HTML received from the ORBEON forms server
		 *  The data is received via a XHR (XML Http Request) as a forms request and we put it into our blank document
		 *  The blank document is actually the client hosted file.
		 *		This is necessary in IE if we want to have an HTTPS request,
		 *		If we try using "://" or "about:blank" we get an awful message about mixing http/https
		 *
		 *  Once the file is loaded, it is s7 to write the HTML.
		 */
		this.obtainedSourceHtml = function(response) {
			this._html = normalizeHtml(response, this._source);
			/** assignDomain
			 *  This code gets injected into the IFRAME via the Javascript Pseudo-Protocol using a SCRIPT tag and fixes the domain.
			 *  If this looks familiar, this is the code that Vani Maddali vmaddali@touchcommerce.com had added for the inqChatLaunch
			 *  The code is proven and has been working for several years.
			 *  She stated:
			 *     This method is to check if we are in the same domain as client page domain.
			 *     If not we are trying to assign the right domain.
			 *  You can see the original code via the link below
			 *  @see assignDomain line 104 at http://stash.touchcommerce.com/projects/RT/repos/rt/browse/rulesgen/src/main/web/WEB-INF/rulesengine/inqChatLaunch.jsp?at=refs%2Fheads%2Fbranch-here#104
			 */
			var assignDomain = function(){
				try {
					var domainName = document.domain;
					var temp = domainName.split('.');
					var tempwindow;
					for (var i=0; i < temp.length; i++){
						try{
							tempwindow = window.parent;
							if (document.domain == tempwindow.document.domain){
								break;
							} else {
								temp.shift();
								document.domain = temp.join('.');
							}
						}
						catch(ee){
							temp.shift();
							document.domain = temp.join('.');
						}
					}
				} catch(e) {}
			};

			if (!this._xframe.src) {
				/* Set the source so it injects the correct document domain that matches the inqFrame window */

				/* This tests to see if the IFRAME is in a state that allows writing to the document
				 * We do this by accessing the contentDocument.
				 * If it failes we set <code>haveDocAccess</code> to false.
				 *
				 * If haveDocAccess is false, then we need to inject code to fix the domain issue
				 * The issue is that the iframe this frame have different domains.  The function "assignDomain" fixes this problem
				 */
				var haveDocAccess = true;
				try {var x = this._xframe.contentDocument;}
				catch (e){haveDocAccess = false;}

				if (!haveDocAccess) {
					/* fix up the function so it can be injected, remove extra white space and fix single quotes */
					var assignDomainFunctionAsString = assignDomain.toString(); 					/* Convert the fixDomain routine into a string version of the function */
					assignDomainFunctionAsString = assignDomainFunctionAsString
						.split("\n").join("")		/* Clean out the tabs and linefeeds */
						.split("\t").join("")
						.split("\r").join("")
						.split("\\'").join("'")		/* We do not know if the single quotes are escaped or not, */
						.split("'").join("\\'");   	/* escape quote the single quotes, this is needed because the javascript below uses the single quote */
					/* Inject self executing anonymous function */
					var selfExecutingFunction = "(" + assignDomainFunctionAsString + ";})();";
					var source = "javascript:'<!-- DOCTYPE html --><html><body><script type=\"text/javascript\" charset=\"utf-8\">"+selfExecutingFunction+"</script></body></html>'";
					this._xframe.src = source;
				}
			}

			/* Test to see the ready state.
			   This also will detect the domain mismatch error when the "document" is retrieved
			 */
			var needToWaitForLoad = true;
			try {
				/* On IE8 through IE9, the following line may throw if there is a domain mismatch */
				var doc = (this._xframe.contentDocument)?this._xframe.contentDocument:this._xframe.contentWindow.document;
				if (doc.readyState == "complete" || doc.readyState == "loaded"){
					needToWaitForLoad = false;
				}
			} catch (e) {
				/* If we are here, then we most likely received a security error */
				needToWaitForLoad = true;
			}

			if (needToWaitForLoad) {
				var xframe = this._xframe;
				var myThis = this;
				this._xframe.onload = function () {
					xframe.onload = null;
					myThis.writeObtainedHtml();
				};
				/* As we know by now, onload does not work in IE6 and IE7, we must check the status change*/
				this._xframe.onreadystatechange = function () {
					/* reference the IFRAME via the xframe inscope variable */
					if (xframe.readyState == "complete" || xframe.readyState == "loaded") {
						xframe.onreadystatechange = null;
						myThis.writeObtainedHtml();
					}
				};
			} else {
				this.writeObtainedHtml();
			}
		};

		/** writeObtainedHtml -
		 *	1)	Stop listeners,
		 *	2)	Get document
		 *	3)	Write the form
		 * @return nothing
		 * @see obtainedSourceHtml - caller
		 */
		this.writeObtainedHtml = function() {
			/* Reset the handlers */
			this._xframe.onreadystatechange = null;
			/* Stop listening to state change, we have what we want */
			this._xframe.onload = null;
			/* Don't need onload either */
			this._html = fixDocumentRewriteBug(this._html, this._xframe.contentWindow);
			if (this._xframe.contentDocument) {
				writeForm(this._xframe.contentDocument, this._html);
			} else if (this._xframe.contentWindow) {
				writeForm(this._xframe.contentWindow.document, this._html);
			} else {
				logError({origin: "writeObtainedHtml", message: "Target document not found"});
			}
		};

		/**
		 * Writes the form into the document
		 * @param doc to write
		 * @param html
		 * @see writeObtainedHtml
		 */
		function writeForm(doc, html){
			doc.open();
			doc.write(html);
			doc.close();


			/* Now all our work is complete, we may destroy this instance */
			XFormsLoader.instances[this.index] = null;			/* Remove reference to this instance, Garbage Collector will remove */
			// TODO this is likely to cause problems as index of the following items is not updated
			XFormsLoader.instances.splice(this.index, 1);		/* remove item from array via splice */
		}

		/**
		 * Converts all urls into absolute form. This is necessary because we are NOT in the same domain as the document
		 * We are actually in the domain of the host client
		 * TODO in cbc.js we already have a similar convertToAbsoluteUrl and that one is covered with tests!
		 *
		 * @param html - string containing html
		 * @param source url for the html
		 * @return fixed html string
		 */
		function normalizeHtml(html, source) {
			var srcParts = source.split("/");
			var proto = srcParts[0];
			var domain = srcParts[2];
			srcParts.pop();
			var path = srcParts.join("/");

			var x  = new RegExp('(href|src|action)=\"((inq://|http://|https://|//|/|#){0,1}[^\"]*)\"', 'gi');
			var matches = html.match(x);
			/* The array elements for the above regular expression is as follows
			 * match item 0 -  the string in it's entirety
			 * match item 1 -  the ATTRIBUTE name, obtained from the pattern above (href|src|action)
			 * match item 2 -  this is the URL, obtained from the pattern ((javascript:|http://|https://|//|/){0,1}[^\"]*)
			 * match item 3 -  the PROTOCOL from the url, obtained from the pattern (javascript:|http://|https://|//|/)
			 * So the regexp has three match points as follows:
			 * (ATTRIBUTE)=((PROTOCOL)URL)
			 * Item 1 is the ATTRIBUTE
			 * Item 2 is the entire URL including the PROTOCOL
			 * Item 3 is the PROTOCOL only
			 */
			if (matches != null) {
				for (var ix=0; ix<matches.length;ix++) {
					try {
						var fix = matches[ix];
						x  = new RegExp('(href|src|action)=\"((inq://|javascript:|http://|https://|//|/|#){0,1}([a-zA-Z0-9._-]+)([^\"]*)\")','gi');
						var parts = x.exec(fix);
						if (parts != null) {
							var url;
							switch((parts[3]).toLowerCase()) {								// check match item #3, the PROTOCOL
								case "inq://":
									if (parts.length > 4) {
										switch(parts[4]) {
											case "agentsAvailabilityCheckURL":	url = Inq.urls.agentsAvailabilityCheckURL; break;
											case "baseURL":						url = Inq.urls.baseURL; break;
											case "chatRouterVanityDomain":		url = Inq.FlashPeer.getChatRouterVanityUrl(); break;
											case "pageUnloadURL":				url = Inq.urls.pageUnloadURL; break;
											case "cobrowseURL":					url = Inq.urls.cobrowseURL; break;
											case "getSiteTzOffsetURL":			url = Inq.urls.getSiteTzOffsetURL; break;
											case "initFrameworkURL":			url = Inq.urls.initFrameworkURL; break;
											case "logDataURL":					url = Inq.urls.logDataURL; break;
											case "logJsPostURL":				url = Inq.urls.logJsPostURL; break;
											case "loggingURL":					url = Inq.urls.loggingURL; break;
											case "mediaBaseURL":				url = Inq.urls.mediaBaseURL; break;
											case "mediaRootURL":				url = Inq.urls.mediaRootURL; break;
											case "mediaSiteURL":				url = Inq.urls.mediaSiteURL; break;
											case "requestC2CImageURL":			url = Inq.urls.requestC2CImageURL; break;
											case "requestChatLaunchURL":		url = Inq.urls.requestChatLaunchURL; break;
											case "siteHostedFileURL":			url = Inq.urls.siteHostedFileURL; break;
											case "skinURL":						url = Inq.urls.skinURL; break;
											case "vanityURL":					url = urls.vanityURL; break;
											case "addActiveWindowIdURL":		url = Inq.urls.addActiveWindowIdURL; break;
											case "xFormsDomain":				/* url = Inq.urls.xFormsDomain; break; fall through */
											default:							url = Inq.urls.xFormsDomain; break
										}
										url += parts[5];
									};
									break;
								case "http://":
								case "https://":
								case "javascript:":
								case "#": url = parts[2]; break;							// The protocol is defined, set url to the entire URL (match item #2)
								case "//": url = proto + parts[2]; break;					// There is no protocol, add the protocol to the URL (match item #2)
								case "/": url = proto + "//" + domain + parts[2];break;		// There is no protocol or domain, add it to the URL (match item #2)
								default: url = path + "/" + parts[2]; break;
							}
							url = parts[1]+'=\"' + url + '\"';
							if (url != fix){
								html = html.replace(fix, url);
							}
						}
					}
					catch (e) {
						/* continue */
					}
				}
			}
			return html;
		}

		this.fixFormSubmit = function(xwin, headerData) {

			function collectFormData(form) {
				var data = [];
				for (var i = 0; i < form.length; i++) {
					var child = form[i];
					if (child.nodeName == "INPUT" || child.nodeName == "BUTTON") {
						if (child.name) {
							data.push(encodeURIComponent(child.name) + "=" + encodeURIComponent(child.value));
						}
					}
				}
				return data.join("&");
			}

			/**
			 * This function is bound to a form and this = form
			 */
			function overrideSubmit() {
				var method = this.method.toUpperCase();
				var url = (headerData.srcurl) ? headerData.srcurl + "&cbust=" + Math.floor(Math.random() * 1000011) : this.action;
				var data = collectFormData(this);
				var callback = function() { // Call a function when the state changes.
					if (this.readyState == XMLHttpRequestFacade.DONE && this.status == 200) {
						this.onreadystatechange = null;
						var html = normalizeHtml(this.responseText, url);
						html = fixDocumentRewriteBug(html, xwin);
						writeForm(xwin.document, html);
					}
				};

				var xdr = new XMLHttpRequestFacade();

				if (method == "POST") {
					xdr.open(method, url, true);
					// Send the proper header information along with the request
					xdr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
					// TODO fix error messages for unsafe headers in chrome
					xdr.setRequestHeader("Content-Length", data.length);
					xdr.setRequestHeader("Connection", "keep-alive");
					xdr.onreadystatechange = callback;
					xdr.send(data);
				} else {
					xdr.open(method, url += "?" + data, true);
					xdr.onreadystatechange = callback;
					xdr.send();
				}
				return true;
			}

			var forms = xwin.document.getElementsByTagName("FORM");
			for (var i = 0; i < forms.length; i++) {
				forms[i].submit = overrideSubmit;
			}
		};

	};

	/**
	 * Static stuff
	 */
	XFormsLoader.instances = [];
	XFormsLoader.JSESSIONID = "ji";
	XFormsLoader.requestQueue = [];
	XFormsLoader.isGetSessionIdInProgress = false;			// used to make only one request of JSESSIONID in one time
	XFormsLoader.MAX_ATTEMPTS_COUNT = 3;

	/**
	 * Deletes global variables from a window scope.
	 * Necessary to overcome WebKit's peculiarity - it does not reset global variables when re-writing document. Other browsers do it.
	 */
	XFormsLoader.resetGlobalVars = function (win) {
		"use strict"; // in case we use "delete" operator here, it works differently in strict mode (throws an exception instead of returning "false")

		/** Returns window without custom properties. */
		function getCleanWindow(ijsfWin) {
			var cleanIFrame = ijsfWin.document.getElementById("cleanIFrame");
			if (!cleanIFrame) {
				cleanIFrame = ijsfWin.Inq.createHiddenIFrame("cleanIFrame");
				ijsfWin.document.body.appendChild(cleanIFrame);
			}
			var win = cleanIFrame.contentWindow;
			if (typeof win == "undefined" || win == null) {
				logError({message: "Failed to get clean window object"});
			}
			return win;
		}

		log("Resetting global variables to overcome WebKit's peculiarity");
		var cleanWindow = getCleanWindow(window);

		// Restore original XMLHttpRequest instance to avoid clobbering when reinitializing facade after cleanup
		if (win.XMLHttpRequestOriginal) {
			win.XMLHttpRequest = win.XMLHttpRequestOriginal;
			win.XMLHttpRequestOriginal = undefined;
		}

		for (var property in win) {
			if (win.hasOwnProperty(property) && typeof cleanWindow[property] == "undefined") { // is it a custom window property?
				try {
					// We set custom window's properties to undefined and
					// ensure that our code use [typeof window.foo != "undefined"] instead of  ["foo" in window] syntax,
					// because "delete window[property]" works only for specific window's properties.
					// For example, it cannot delete YAHOO variable, which prevents xformsPageLoadedServer() from running in Chrome 20 & 21.
					// Here is the article describing how "delete" operator works: http://perfectionkills.com/understanding-delete/
					win[property] = undefined;
				} catch (ex) {
					log("WARN: cannot delete global variable '" + property + "'");
				}
			}
		}
		if (typeof YAHOO != 'undefined') {
			logError({message: "Failed to delete the YAHOO global variable."});
		}
	};

	/**
	 * Get JSESSIONID from session cookies or create empty variable.
	 *
	 * @returns JSESSIONID or empty.
	 */
	XFormsLoader.initJsid = function () {
		var jsidVar = PM.getVar(XFormsLoader.JSESSIONID);
		if (!jsidVar) {
			jsidVar = (new VER34(XFormsLoader.JSESSIONID, "", resources["session"]));
			jsidVar.init();
			jsidVar.z0();
			PM.addVar(jsidVar);
		}
		return jsidVar.z0();
	};

	/**
	 * Persist JSESSIONID to session cookies.
	 *
	 * @param jsid JSESSIONID to persist
	 */
	XFormsLoader.persistJsid = function (jsid) {
		PM.getVar(XFormsLoader.JSESSIONID).z3(jsid);
	};


	XFormsLoader.showInClientDiv = function (divId, rule, ruleBusinessUnitId, url, items, method) {
		var divEl = getParentPageElById(divId, doc);
		if (inu1(divEl)) {
			log("Error: DIV with id \"" + divId + "\" not found.");
		} else {
			var buID = ruleBusinessUnitId ? ruleBusinessUnitId : rule.getBusinessUnitID();
			var urlData = FP.parseXFrameUrl(url);
			if (typeof urlData.params == 'object') {
				MI8.prepare(urlData.params).im13(MI8.XJA3);
				urlData.params = MI8.unmix(urlData.params.absorb(items));
			}
			var ldr = new XFormsLoader();
			method = method ? method : null;
			ldr.createXFrame(divEl, urlData.url, buID, "no", urlData.params, rule, {type: "br", id: rule.getID()}, {type: "div", id: divId}, false, method);

		}

	}

	return XFormsLoader;

}();

	/**
	 * Cobrowse manager for framework.
	 * @class
	 * @constructor
	 * @borrows FM2#init as #init
	 * @see FM2
	 */
	function CBMR(id, config){
		this._frameworkModule(id);
        this._config = config;
	}
	
	MI8.prepare(CBMR).im13(MI8.FM2);
	
	/**
	 *  load - private function that loads the jQuery and the CBC (Co-Browse Client) javascript files
	 *		At completion of both loads then:
	 *		1) we initialize the cobrowse client
	 *		2) we set the cobrowse flag, stating that we are now using cobrowse
	 *		3) we then fire the optional handler (that was passed as an argument
	 * @param handler - function to be called after loading and initialization
	 */
	CBMR.prototype.load = function(handler) {
		if ((CBMR.isSupported() || this._config.enableCobrowseOnMobile) && !isWebSDK) {
			var maskingConfig = this._config.cobrowseMaskingConfig;
			var isEmbeddedResource = this._config.isEmbeddedResource;

			this.loadjQuery(
				site.noJSHosting ? site.clientStaticUrl : urls.mediaRootURL,
				(site.noJSHosting ? "" : "/flash") + "/jquery-3.5.0.js",
				(site.noJSHosting ? "" : "/flash") + "/jquery-3.5.0.min.js",
				function(greeting) {
					loadScript(
						site.noJSHosting ? site.clientStaticUrl : urls.vanityURL,
						(site.noJSHosting ? "" : "/tagserver") + "/cbc.js?codeVersion=" + encodeURIComponent(v3Lander.codeVersion),
						(site.noJSHosting ? "" : "/tagserver") + "/cbc-min.js?codeVersion=" + encodeURIComponent(v3Lander.codeVersion),
						function(greeting) {
							try {
								if (window["cobrowse"]) {
									window.cobrowse.initialize(maskingConfig, isEmbeddedResource, isIE(), CHM.isPersistentWindow());
								}
								CHM.setCobrowseFlag(true);
							} catch (e) {
								log("Cobrowse Initialization failed: " + e);
							}
							try {
								if (handler) {handler();}
							} catch (e) {
								log("Cobrowse load on demand failed: " + e);
							}
						}, handler
					);
				}, handler
			);
		}
	};

	CBMR.prototype.loadjQuery = function(server, urlClean, urlObfuscated, initFunction, parameters) {
		if(typeof jQuery === "undefined"){
			loadScript(server, urlClean, urlObfuscated, initFunction, parameters);
		} else {
			initFunction(parameters);
		}
	}
	
	/**
	 *  init - public function that that loads the cobrowse client system, if and only if:
	 *		1) we have enabled cobrowse on prior page visit
	 *		2) we have cobrowse enabled for this site
	 */
	CBMR.prototype.init = function() {
	/* In the near future, we will load the cobrowse code base on demand,
	 * At that time we will check to see if we have cobrowsed at init time as such
		if (CHM.getCobrowseFlag()){
			this.load();
		}
	 */
		this.load();
	};

	/**
	 *  runOnDemand - public function that that loads the cobrowse client system, if and only if it has not been loaded before
	 *		Its purpose is to load on demain.
	 *		When we accept any cobrowse invitation, we call this function
	 *	@see FlashPeer
	 *	@param handler - the method to be called on sucessful load and initialization of the cobrowse code base
	 */
	CBMR.prototype.runOnDemand = function(handler) {
		if (typeof (window.cobrowse) != "undefined"){
			handler();
		}
		else {
			this.load(handler);
		}
	};
		
    /**
        CBMR.isSupported
        return true if cobrowse is supported.
     */
    CBMR.isSupported = function() {
        var _isSupported = false;

        if ("Standard" === getDeviceType()) {
            _isSupported = true;
        }

        return _isSupported;
    };

	CBMR.prototype.start = function(){
		//place holder not used (defined by FM2).
	};
	
	CBMR.prototype.reset = function(){
		//place holder not used (defined by FM2).
    };

    /**
     *  getData - public function that that returns the state of the cobrowse session.
     *		It can be accessed using Inq.getData().CBM.cobrowseSession;
     *	@see RTDEV-16949 for more details
     *  @returns an object with a key 'cobrowseSession' and a boolean value that
     *  indicates if the cobrowse session is on or off.
     */
	CBMR.prototype.getData = function(){
		return {
			cobrowseSession: FP.isCobEngaged()
		};
	};

	CBMR.prototype.onChatMinimize = function() {
		if (Inq.CBC && Inq.CBC.isCobrowseEngaged()) {
			Inq.CBC.applyScrollTo();
		}
	};

function AutomatonDT() {
}

    /**
     * add automaton's fields to data model
     * @param {String} div automaton's div
     * @param {Object} dataToSend data model
     * @return {Array} names of selected checkboxes;
     */
    AutomatonDT.prototype.addDTEventFields = function (div, dataToSend) {
        var children = div.getElementsByTagName('input');
        var selectedCheckboxNames = [];
        for (var i = 0; i < children.length; i++) {
            var elem = children[i];
            if (elem.type == "checkbox") {
                dataToSend[elem.name] = "" + elem.checked;
                if (elem.checked) {
                    // save name of selected checkbox
                    selectedCheckboxNames[selectedCheckboxNames.length] = elem.name;
                }
            }
            else {
                dataToSend[elem.name] = "" + elem.value;
            }
        }
        return selectedCheckboxNames;
    };

    /**
    * Get answer text of clicked element (<a> or button)
    * @param button clicked element
    * @param div automaton's div
    */
    AutomatonDT.prototype.getAnswerText = function(button, div) {
        if (inu1(button)) {
            return null;
        }
        /* If we have an anchore, then get the innerHTML as the answer text
         * button.text does not exist for the link <A> on IE
         * innerHTML does on all targetted browsers.
         */                   
        if (button.nodeName == "A") {     
            return button.innerHTML;
        }
        if (!inu1(button.text)) {        
            return button.text;
        }

        if (!inu1(button.type)) {
            // button <input type='button'/>
            if (button.type == 'button') {
                // build answer like:
                // Submit ('Qwerty keyboard' 'email client' selected)
                // where:
                // Submit - button's name
                // 'Qwerty keyboard' 'email client' names of checked checkboxes
                var out = '';
                var children = div.getElementsByTagName('input');
                for (var i = 0; i < children.length; i++) {
                    var elem = children[i];
                    if (elem.type == "checkbox") {
                        if (elem.checked) {
                            if (out.length > 0) {
                                out +=" ";
                            }
                            out += "'" + elem.value + "'";
                        }
                    }
                }
                if (out.length == 0) {
                    out = "Nothing";
                }
                return  button.name + ' (' + out + ' selected)';
            }
        }
        return null;
    };
    /**
     * Send chat.automaton_response msg
     * @param eventName event name
     * @param button component with called this fuction
     * @param data parameters from chat.automaton_request msg
     */
    AutomatonDT.prototype.sendDTEvent = function (eventName, button, data) {
        try {
            /* define automaton's div */
            var div = document.getElementById(data.divId);

            var dataToSend = null;
            /* define automaton's data model */
            try {
                dataToSend = data.model;
            }
            catch (e) {
                log("sendDTEvent can't read data model " + e);
            }
            if (inu1(dataToSend)) {
                dataToSend = {};
            }
            /* read data only from parent component */
            var dataNode = button.parentNode;
            var selectedCheckboxNames = this.addDTEventFields(dataNode, dataToSend);

            // save element's name, it will be bold
            if (button) {
                data.selectedLinkName = button.name;
            }
            data.selectedCheckboxNames = selectedCheckboxNames;

            data.model = MI8.JSON.stringify(dataToSend);

            var answerText = this.getAnswerText(button, div);
            if (answerText) {   
                data.answerText = answerText;
            }

            FP.sendDTEvent(eventName, data);
        }
        catch(e) {
            log("sendDTEvent error " + e);
        }
        return false;
    };

/**
	 * Visitor Attributes Manager
	 * @class
	 * @constructor
	 * @name VAMgr
	 * @param {Object} id.
	 * @param {Object} data containing the programm and business visitor attributes.
	 * @borrows XJA3#absorb as #absorb
	 * @borrows FM2#init as #init
	 * @borrows FM2#start as #start
	 * @borrows FM2#reset as #reset
	 * @see XJA3
	 * @see FM2
	 */
function VAMgr(id, data){
	this._frameworkModule(id);
	this.absorb(data); /* Includes all instantiated visitor attributes */
	this._varTable = {};
	this._bActionable = true; // used for incrementality control
	this.currentVisitorAttributes = {};
	this.banned = {};
	this.hashed = {};
	this.storedValues = new MapVariable("VA",new Array(),resources.state);
	this.allowDynamic = true;
	this.crc32map = {};
	this.requestQueue = [];

	/**
     * We need this function to store in cookies only hash codes of banned Visitor Attributes.
     * Reasons of this minimization are limitation on cookie size 4K and fact that
     * we send cookies in each request.
     * F.E.: VA.crc32("Noteworthy Content Groups") is y85vk4
     * P.S.: Since with a 32 bit hash value there are only about 4 billion possible hashes,
     * then if you throw enough strings in, then you will eventually find two that have the same hash value.
     * The probability that any two strings will have the same hash value is 1:4,294,967,296 (about 1 in four billion).
     * With a larger number of strings, the probability rises. Checking collisions on 300,000 unique string called from some random dump
     * of a dictionary gives about seven collisions.
     * @param {String} str String for which we calculate CRC32
     * @return string with CRC32 hash code
     * @type String
     */
	this.crc32 = function( str ) {
		if (!this.crc32map[str]) {
			var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
			var crc = -1;
			var x = 0;
			var y = 0;
			for (var i = 0, iTop = str.length; i < iTop; i++) {
				y = ( crc ^ str.charCodeAt( i ) ) & 0xFF;
				x = "0x" + table.substr( y * 9, 8 );
				crc = ( crc >>> 8 ) ^ x;
			}
			crc = crc ^ (-1);
			if (crc < 0)
			{
				crc = 0xFFFFFFFF + crc + 1;
			}
			this.crc32map[str] = "a" + ((crc).toString(36));
		}
		return this.crc32map[str];
	};

	this.test = function(visitorAttributes) {
		var result = false;
		for (var a in visitorAttributes) {
			if (this.currentVisitorAttributes[a]) {
				result = true;
				if (visitorAttributes[a].values) {
					if (this.currentVisitorAttributes[a].values) {
						for (var valueChecking in visitorAttributes[a].values) {
							if (!this.currentVisitorAttributes[a].values[valueChecking]) {
								return false;
							}
						}
					} else {
						result = false;
					}
				}
			}
		}
		return result;
	};

	this.checkBanDuration = function(attributeName) {
		var attr;
		var expiry;
		if ((attr = this.businessVisitorAttributes[attributeName]) || (attr = this.programVisitorAttributes[attributeName])) {
			var b = this.banned[this.crc32(attributeName)];
			if (b) {
				var currentTime = new Date().getTime();
				expiry = parseInt(b.d,36)*1000;
				if (!inu1(b.d) && (expiry > 0) && (expiry < currentTime)) {
					delete this.banned[this.crc32(attributeName)];
					attr.banAll = false;
				} else {
					for (var bannedValue in b) {
						if (bannedValue != 'd') {
							expiry = parseInt(b[bannedValue].d,36)*1000;
							if ((expiry > 0) && (expiry < currentTime)) {
								delete b[bannedValue];
							}
						}
					}
				}
			}
		}
	};

	/**
     * We add visitorAttributes to currentVisitorAttributes if attribute name and value exist in PVA or BVA
     * and are not banned. For attributes with mutuallyExclusive = true we should have only one value.
     * For allowDynamic mode we can have values not mentioned in PVA or BVA.
     * So the way we store visitor attributes depends on allowDynamic flag, e.g.
     * {"j1rid2":["1kwdjcl"],"y85vk4":[]} for allowDynamic = false and
     * {"j1rid2":["ANY VALUE"],"y85vk4":[]} for allowDynamic = true.
     * We cannot minimize dynamic values by hash because we don't have them in PVA or BVA.
     * @see #save
     * @param {Object} visitorAttributes associative array
     * @return void
     */
	this.add = function(visitorAttributes) {
		for (var a in visitorAttributes) {
			if(typeof visitorAttributes[a]=="function") continue;
			var attr;
			var val = null;
			if ((attr = this.businessVisitorAttributes[a]) || (attr = this.programVisitorAttributes[a])) {
				this.checkBanDuration(a);
				if (!attr.banAll) {

					for (var valueAdding in visitorAttributes[a].values) {
						if (typeof visitorAttributes[a].values[valueAdding] == "function") {
							continue;
						}

						if (((attr.values[valueAdding] && !this.allowDynamic) || this.allowDynamic) &&
								!(this.banned[this.crc32(a)] &&  this.banned[this.crc32(a)][this.crc32(valueAdding)])
						) {
							var valuesNumber = Object.keys(visitorAttributes[a].values).length;
							if (this.currentVisitorAttributes[a]
								&& this.currentVisitorAttributes[a].values
								&& this.currentVisitorAttributes[a].values[valueAdding]
								&& !(valuesNumber > 1 && attr.mutuallyExclusive)
							) {
								/*
									Same value shouldn't be sent to server again.
									In case when we have few values and mutuallyExclusive flag
									only last value will be stored in currentVisitorAttributes
									so all values should be sent to server,
									because on client side there isn't enough information
									about previous state of VA.
								*/
								continue;
							}

							if (!this.currentVisitorAttributes[a] || attr.mutuallyExclusive) {
								this.currentVisitorAttributes[a] = {};
                                if (attr.writeToCookie) {
                                    this.hashed[this.crc32(a)] = [];
                                }
								this.currentVisitorAttributes[a].values = {};
							}
							this.currentVisitorAttributes[a].values[valueAdding] = true;
							var maxLength = attr.maxLength;
							if (maxLength && valueAdding.length > maxLength) {
								var msg = "Visitor attribute value is too long! visitorAttribute: " + a + ", size: " + valueAdding.length + " ";
								lmt12(plc1(msg), LOG_LEVELS.WARN);
							}
							if (this.allowDynamic) {
								val = valueAdding;
							} else {
								val = this.crc32(valueAdding);

							}

							if (attr.writeToCookie) {
								var hash = this.crc32(a);
                                // repeated addition protection
                                if (!this.hashed[hash].contains(val)) {
                                    this.hashed[hash].append([val]);
                                }
							}
						}
					}
				}
			}
			if (!!val) {
				this.logData("visitorAttributeAdded", a, this.getAttributeValues(a, visitorAttributes));
			}
		}
		if (isPersistentWindow()) {
			// Any added visitor attributes in persistent window should be added in hash of VAM of main window
			openerCall("addVisitorAttributes", [visitorAttributes], false);
		}
	};

	this.remove = function(visitorAttributes, fromRemoveAll) {
        var removedAttrs = [];
		for (var attribute in visitorAttributes) {
			var hashedAttribute = this.crc32(attribute);
			if (typeof visitorAttributes[attribute] === "function" || this.isMutuallyExclusiveAttribute(attribute))
				continue;
			if (this.currentVisitorAttributes[attribute]) {
				var hasNoValues = true;
				for (var valueRemoving in visitorAttributes[attribute].values) {
					if (typeof visitorAttributes[attribute].values[valueRemoving] === "function")
						continue;
					hasNoValues = false;
					removedAttrs.push(valueRemoving);
					if (this.currentVisitorAttributes[attribute].values[valueRemoving]) {
						delete this.currentVisitorAttributes[attribute].values[valueRemoving];

						// Remove the Hashed Attributes if present
						if(this.hashed[hashedAttribute]){
							var valueToRemove = this.allowDynamic ? valueRemoving : this.crc32(valueRemoving);
							var index = this.hashed[hashedAttribute].indexOf(valueToRemove);
							this.hashed[hashedAttribute].remove(index);
						}

                        if(Object.keys(this.currentVisitorAttributes[attribute].values).length === 0) {
                            delete this.currentVisitorAttributes[attribute];
                            delete this.hashed[hashedAttribute];
                        }
					}
				}
				if (hasNoValues || fromRemoveAll) {
                    removedAttrs = this.getAttributeValues(attribute, this.currentVisitorAttributes);
					delete this.currentVisitorAttributes[attribute];
					delete this.hashed[hashedAttribute];
				}
				this.logData("visitorAttributeRemoved", attribute, removedAttrs);
			}
		}
		if (isPersistentWindow()) {
			// Any removed visitor attributes in persistent window should be removed from hash of VAM of main window
			openerCall("removeVisitorAttributes", [visitorAttributes, fromRemoveAll], false);
		}
	};

	this.removeAll = function() {
		this.remove(this.currentVisitorAttributes, true);
	};

	/**
     * We store banned attributes as associative arrays of names and values hashes.
     * For each name and value we also store banning duration.
     * -1 means forever, others digits means time in seconds since midnight 1 January 1970 in 36 base number.
     * F.E.: {"j1rid2":{"d":-1,"1kwdjcl":{"d":-1}},"y85vk4":{"d":n6yt}}
     * @see #crc32
     * @param {Object} visitorAttributes associative array
     * @param {long} duration of banning action
     * @return void
     */
	this.ban = function(visitorAttributes, duration) {
		var sendlog = false;
		if (duration > 0) {
			duration = Math.ceil((new Date().getTime() + duration)/1000).toString(36);
		}
		for (var a in visitorAttributes) {
			if(typeof visitorAttributes[a]=="function" || this.isMutuallyExclusiveAttribute(a)) continue;
			var attr;
			var crc = this.crc32(a);
			if ((attr = this.businessVisitorAttributes[a]) || (attr = this.programVisitorAttributes[a])) {
				var banAll = true;
				if (visitorAttributes[a].values) {
					for (var valueBanning in visitorAttributes[a].values) {
						if(typeof visitorAttributes[a].values[valueBanning]=="function") 
							continue;
						banAll = false;
						if (this.allowDynamic || attr.values[valueBanning]) {
							if (this.currentVisitorAttributes[a] && this.currentVisitorAttributes[a].values && this.currentVisitorAttributes[a].values[valueBanning]) {
								delete this.currentVisitorAttributes[a].values[valueBanning];
								if (this.allowDynamic) {
									delete this.hashed[this.crc32(a)][valueBanning];
								} else {
									delete this.hashed[this.crc32(a)][this.crc32(valueBanning)];
								}
							}
							
							if(!this.banned[crc]) {
								this.banned[crc] = {};
							}
							// if any one attribute is not already banned then log it
							sendlog = true; 
							this.banned[crc][this.crc32(valueBanning)] = {
								"d":duration
							};
						}
					}
				}
				if (banAll) {
					sendlog = true;
					attr.banAll = true;
					delete this.currentVisitorAttributes[a];
					delete this.hashed[this.crc32(a)];
					this.banned[this.crc32(a)] = {
						"d":duration
					};
				}
			}
			if(sendlog)
				this.logData("visitorAttributeBanned",a,this.getAttributeValues(a,visitorAttributes));
		}
		if (isPersistentWindow()) {
			// Any banned visitor attributes in persistent window should be added in ban in VAM of main window
			openerCall("banVisitorAttributes", [visitorAttributes, duration], false);
		}
	};

	/**
     * We delete unbanned attributes from associative arrays of names and values hashes.
     * @see #ban
     * @param {Object} visitorAttributes associative array
     * @return void
     */
	this.unban = function(visitorAttributes) {
		for (var a in visitorAttributes) {
			if(typeof visitorAttributes[a]=="function" || this.isMutuallyExclusiveAttribute(a)) continue;
			var attr;
			if ((attr = this.businessVisitorAttributes[a]) || (attr = this.programVisitorAttributes[a])) {
				var unbanAll = true;
				if (visitorAttributes[a].values && this.banned[this.crc32(a)]) {
					for (var valueBanning in visitorAttributes[a].values) {
						if(typeof visitorAttributes[a].values[valueBanning]=="function") 
							continue;
						delete this.banned[this.crc32(a)][this.crc32(valueBanning)];
						unbanAll = false;
					}
				}
                if (!unbanAll) {
                    unbanAll = true; 
                    for (var bannedValue in this.banned[this.crc32(a)]) {
                        if (bannedValue != "d") {
                            unbanAll = false; 
                            break;
                        }
                    }
                }
				if (unbanAll) {
					attr.banAll = false;
					delete this.banned[this.crc32(a)];
				}
			}
			this.logData("visitorAttributeUnbanned",a,this.getAttributeValues(a,visitorAttributes));
		}
		if (isPersistentWindow()) {
			// Any removed from ban visitor attributes in persistent window should be removed from ban in VAM of main window
			openerCall("unbanVisitorAttributes", [visitorAttributes], false);
		}
	};

	this.initBanned = function(visitorAttributes) {
		for(var a in visitorAttributes) {
			var attr = visitorAttributes[a];
			var crc = this.crc32(a);
			if(this.banned[crc]) {
				var banAll = true;
				for(var tmp in this.banned[crc]) {
					if (tmp != "d") {
						banAll = false;
						break;
					}
				}
				if (banAll) {
					attr.banAll = true;
				}
			}
		}
	};

	this.initHashed = function(visitorAttributes) {
		for(var a in visitorAttributes) {
			var attr = visitorAttributes[a];
			var crc = this.crc32(a);
			if(this.hashed[crc]) {
				this.currentVisitorAttributes[a] = {};
				this.currentVisitorAttributes[a].values = {};
				if (this.hashed[crc].length) {
					if (this.allowDynamic) {
						for(var i = 0; i < this.hashed[crc].length; i++) {
							valueAdding = this.hashed[crc][i];
							this.currentVisitorAttributes[a].values[valueAdding] = true;
						}
					} else {
						for (var valueAdding in attr.values) {
							if (this.hashed[crc][this.crc32(valueAdding)]) {
								this.currentVisitorAttributes[a].values[valueAdding] = true;
							}
						}
					}
				}
			}
		}
	};

	this.init = function() {
	};

	/**
     * We using this function to get attribute values from some source.
     * It is needed for logging and in 'each' function.
     * @param {String} a Visitor Attribute name
     * @param {Object=} source Visitor Attributes
     * @return Array
     * @return Array with Visitor Attribute  values from source
     * @type Array
     */
	this.getAttributeValues = function(a , source) {
		var values = [];
		if (source == null) {
			source = this.currentVisitorAttributes;
		}
		if (source[a]) {
			for(var value in source[a].values)  {
				values[values.length] = value;
			}
		}
		return values;
	};

	/**
	 * Returns visitor attribute names marked with external customer ID flag
	 * Names are URL-Encoded
	 * @see RTDEV-13664
	 * @returns {String} URL-encoded attribute names separated with comma
	 */
	this.getExternalCustomerIdVisitorAttributesAsString = function() {
		var visitorAttrs = this.businessVisitorAttributes;
		var result = "";
		for (var attr in visitorAttrs) {
			if(visitorAttrs[attr].externalCustomerID) {
				result += result ? "," + encodeURIComponent(attr) : encodeURIComponent(attr);
			}
		}
		return result;
	}

	/**
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * @return Object with functions 'keys','values','each','clear,'set','get'
     * @type Object
     */
	this.getCopyAsMap = function(){
		var copy ={
			currentVisitorAttributes : this.currentVisitorAttributes,
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing keys method.
     */
			keys : function() {
				var keys = [];
				for(var a in this.currentVisitorAttributes) {
					keys[keys.length] = a;
				}
				return keys;
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing values method.
     */
			values : function() {
				var values = [];
				for(var a in this.currentVisitorAttributes) {
					values[values.length] = this.get(a);
				}
				return values;
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing each method.
     */
			each : function(func) {
				if (typeof func == "function") {
					for(var a in this.currentVisitorAttributes) {
						func(a,this.get(a),this);
					}
				}
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing clear method.
     */
			clear : function() {
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing set method.
     */
			set : function() {
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing get method.
     */
			get : function(key) {
				var values = [];
				var cVatt = this.currentVisitorAttributes[key];
				if(!!cVatt && !!cVatt.values){
					for(var value in cVatt.values)  {
						values[values.length] = value;
					}
				}
				return values;
			},
			/*
     * We need this function to render current-visitor-attributes as ancecstor of abstract-map tag.
     * So, we implementing unset method.
     */
			unset : function() {
			}
		};
		return copy;
	};

	this.start = function() {
	};

	this.reset = function() {
	};

	this.load = function() {
		if(this.storedValues.z0() == null) {
			this.storedValues.init();
		} else {
			this.banned = this.storedValues.z0().get("ban");
			if(this.banned) {
					this.initBanned(this.businessVisitorAttributes);
					this.initBanned(this.programVisitorAttributes);
			} else {
				this.banned = {};
			}
			this.hashed = this.storedValues.z0().get("hash");
			if(this.hashed) {
				this.initHashed(this.businessVisitorAttributes);
				this.initHashed(this.programVisitorAttributes);
			} else {
				this.hashed = {};
			}
		}
	};

	this.save = function() {
		this.storedValues.set("hash",this.hashed);
		this.storedValues.set("ban",this.banned);
	};

	this.agrtyer = function() {
		this.load();
	};

	this.getPersistentId = function() {
		return this.getID();
	};

	/**
     * Returns copy of VAs as array "name=value(s)" pairs.
     * For multivalued VAs values are separated by commas.
     * Every name and value(s) of returned array may optionally be URL encoded, this may be usefull if returned value
     * will further be passed as part of URL.
     * @param {boolean=} urlEncodingRequired if true, return value will be URL encoded.
     */
	this.getCopyAsArray = function(urlEncodingRequired) {
		var tmp = new Array();
		for(var attribute in this.currentVisitorAttributes) {
            var values = this.getAttributeValues(attribute);
            var keyValues = new Array(values.length);
            var attr = urlEncodingRequired ? encodeURIComponent(attribute) : attribute;
            for(var i = 0; i < values.length; i++) {
                var val = urlEncodingRequired ? encodeURIComponent(values[i]) : values[i];
                keyValues[i] = attr + ',' + val;
            }
			tmp[tmp.length] = keyValues.length > 0 ? keyValues.join(';') : (attr + ",");
		}
		return tmp;
	};

	/**
	 * Send request to TS to log ETL event. Requests are synchronized and saved in 'requestQueue' object.
	 * Ordering is necessary to keep actual 'currentAtts' parameter - values of current visitor attributes,
	 * because RTM contains value of 'currentAtts' attribute only from last ETL log.
	 * @param event
	 * @param attribute
	 * @param values
	 */
	this.logData = function(event, attribute, values) {
		var encodedValues = new Array(values.length);
		if (values.length > 0) {
			for (var i = 0; i < values.length; i++) {
				encodedValues[i] = encodeURIComponent(attribute) + "," + encodeURIComponent(values[i]);
			}
		} else {
			encodedValues.push(encodeURIComponent(attribute) + ",");
		}
		var data = {
			_domain: "customer",
			evt: event,
			siteID: Inq.siteID,
			incAssignmentID: asi4(),
			sessionID: getSessionID(),
			customerID: Inq.getCustID(),
			chatID: CHM.getLastChatID(),
			atts: encodedValues.join(";"),
			currentAtts: (this.getCopyAsArray(true).join(";"))
		};
		this.putRequestInQueue(urls.logDataURL, data);
	};

	this.testBanned = function(visitorAttribute) {
		var result = false;
		for (var a in visitorAttribute) {
			this.checkBanDuration(a);
			var attr = visitorAttribute[a];
			var crc = this.crc32(a);
			if(this.banned[crc]) {
				var banAll = true;
				for(var tmp in this.banned[crc]) {
					if (tmp != "d") {
						banAll = false;
						break;
					}
				}
				if (banAll) {
					result = true;
				} else {
					for (var valueBanning in attr.values) {
						if (this.banned[crc][this.crc32(valueBanning)]) {
							result = true;
							break;
						}
					}
				}
			}
		}
		return result;
	};

	this.toString=function(){
		return !!this.getCopyAsArray()?this.getCopyAsArray().toString():"";
	};

    this.isMutuallyExclusiveAttribute = function(attr){
        return attr == "mutuallyExclusive";
    };

	this.onRemoteCallback = function() {
		this.requestQueue.shift();
		if (this.requestQueue.length > 0) {
			var request = this.requestQueue[0];
			this.callRemote(request.url, request.data);
		} else {
			this.save();
		}
	};

	this.putRequestInQueue = function(url, data) {
		this.requestQueue.push({url: url, data: data});
		if (this.requestQueue.length == 1) {
			this.callRemote(url, data);
		}
	};
}

MI8.prepare(VAMgr).im13(MI8.Persistable).im13(MI8.FM2).im13(MI8.XJA3).im13(MI8.Observable).im13(MI8.Persistable).im13(MI8.RC54);

function WatchDogMgr(){
    this.clients = [];
    this._className="WatchDogMgr";
}

/**
 * registerClient add new client to WatchDogManager for health check
 * @param clientID          string for identification of client
 * @param checkInterval     check interval in msec
 * @param isAliveCallback   callback function for health check (@see WDMClient.hx for prototype)
 * @param resetStateCallback callback function for reset client if not alive (@see WDMClient.hx)
 * @return void
 */
WatchDogMgr.prototype.registerClient = function(clientID, checkInterval, isAliveCallback, resetStateCallback) {
    this.unregisterClient(clientID);

    var client = new Object();
    client.id = clientID;
    client.checkInterval = checkInterval;
    client.isAlive = isAliveCallback;
    client.resetState = resetStateCallback;
    var me = this;
    client.timer = window.setInterval(function() {
        me.onProcessClient(client);
    }, checkInterval);

    this.clients.push(client);
}

/**
 * unregisterClient remove client from WatchDogManager
 * @param clientID          string for identification of client
 * @return void
 */
WatchDogMgr.prototype.unregisterClient = function (clientID) {
    for (var i = 0; i < this.clients.length; i++) {
         if (this.clients[i].id == clientID) {
             window.clearInterval(this.clients[i].timer);
             this.clients.splice(i, 1);
             return;
         }
    }
}

/**
 * onProcessClient calling from interval timer for check client health
 * @param client for check
 * @return void
 */
WatchDogMgr.prototype.onProcessClient = function(client) {
    try {
        if (client.isAlive) {
            if (!client.isAlive() && client.resetState) {
                Inq.FlashPeer.logInfo("Client " + client.id + " is not alive. Try to reset state");
                client.resetState();
            }
        }
    } catch (e) {
        Inq.FlashPeer.logError("Error WatchDogMgr.onProcessClient " + e);
    }
}

/**
 * Static field instance of the singleton WatchDogMgr
 */
WatchDogMgr.WDM = null;

/**
 * Create an instance of the WatchDogMgr. This singleton creation
 * pattern should ALWAYS be used by other objects instead of creating
 * a PM with its constructor.
 * @return a singleton instance of X4334rtf
 */
WatchDogMgr.getInstance = function() {
    if (WatchDogMgr.WDM == null) {
        WatchDogMgr.WDM = new WatchDogMgr();
    }
    return WatchDogMgr.WDM;
};

	/**
	 * Destination monitor - this is a service to monitor the actions on the page
	 * such as click on the anchor and refreshing page by pressing the button "F5".
	 * This is needed to monitor the navigation of customer to other page
	 * from current page by scanning the attribute "href" on the anchor.
	 */
	function DME2() {
		this.KEY_F5 = 116;
		this.initialized = false;
		this.target = null;
	}

	/**
	 * Initialization of monitor. Starts the tracking of actions.
	 * Adding a listeners only on the parent window,
	 * because the opening of the link without target="_blank" attribute in the chat window
	 * leads to the reloading of the chat frame.
	 *
	 * We can't use listener for "click" event
	 * because according to specification "UI Events (formerly DOM Level 3 Events)":
	 *      C.1.1 Activation event order
	 *          If the DOMActivate event is supported by the user agent,
	 *          then the events MUST be dispatched in a set order relative to each other:
	 *          (with only pertinent events listed):
	 *              1. click
	 *              2. DOMActivate - default action, if supported by the user agent; synthesized; isTrusted="true"
	 *              3. All other default actions, including the activation behavior
	 *          If the focused element is activated by a key event,
	 *          then the following shows the typical sequence of events (with only pertinent events listed):
	 *              1. keydown - MUST be a key which can activate the element, such as the 'Enter' or ' ' key,
	 *                           or the element is not activated
	 *              2. click - default action; synthesized; isTrusted="true"
	 *              3. DOMActivate - default action, if supported by the user agent; synthesized; isTrusted="true"
	 *              4. All other default actions, including the activation behavior
	 *
	 * This description means that in our case (when DOMActivate this is unloading page)
	 * "onbeforeunload" event is invoked immidiately after click,
	 * and "onmessage" event is invoked after "onbeforeunload".
	 *
	 * Therefore we should use workaround to track other events which can leads to navigation on other URL, for example
	 * for "click" we have a following default action {@link http://www.w3.org/TR/DOM-Level-3-Events/#event-types-list}:
	 *      - for targets with an associated activation behavior, executes the activation behavior;
	 *      - for focusable targets, gives the element focus.
	 *
	 * Thus we can use "focusin" event to track the URL of the focused anchor.
	 * A page can be navigated to this URL.
	 * IMPORTANT:
	 *      Unfortunately, we can NOT be sure that the page has navigated to this URL and was not restarted
	 *      or the user is not returned back to the previous page.
	 * Also we can use "focusout" event to track the loss of focus from the anchor.
	 *
	 * But we can't use events "focus" and "blur" because these events is not bubbles,
	 * to add only one listener on the top wrapper element - document.
	 *
	 * Also we try to track keyboard events to catch a pressing of the F5 button that leads to the refresh of the page,
	 * but this hack works not in all browsers.
	 */
	DME2.prototype.init = function() {
		if (isPersistentWindow()) {
			// is not needed to track actions in the persistent chat window
			return;
		}

		attachListener(doc, "keydown", this._keydownHandler, false);

		/* "focusin" event, but not supported in Firefox, therefore is used "focus" event with capture,
		 * but in IE8- there is no capture stage, but there is "focusin" event,
		 * therefore we use other way of listening in FF
		 */
		if (isFF()) {
			attachListener(doc, "focus", this._focusinMonitor, true);
		} else {
			attachListener(doc, "focusin", this._focusinMonitor, false);
		}

		/* "focusout" event, but not supported in Firefox, therefore is used "blur" event with capture,
		 * but in IE8- there is no capture stage, but there is "focusout" event,
		 * therefore we use other way of listening in FF
		 */
		if (isFF()) {
			attachListener(doc, "blur", this._focusoutMonitor, true);
		} else {
			attachListener(doc, "focusout", this._focusoutMonitor, false);
		}

		if (isSafari()) {
			/* Safari do not set the focus on clicked anchor element.
			 * @see RTDEV-11292
			 * @see WebKit Bug 26856 - AnchorElement, ButtonElement, InputButton and Document should fire focus event when it is clicked.
			 * @see Chromium Issue 388666: Focus anchor (A) elements on mousedown - Fixed, but only on Chromium branch.
			 *
			 * Therefore we should use workaround through listener on "mousedown".
			 */
			attachListener(doc, "mousedown", this._focusinMonitor, false);
		}

		this.initialized = true;
	};

	/**
	 * A function removes all listeners of the instance of DME2.
	 */
	DME2.prototype.reset = function() {
		if (this.initialized) {
			detachListener(doc, "keydown", this._keydownHandler, false);
			detachListener(doc, "focus", this._focusinMonitor, true);
			detachListener(doc, "focusin", this._focusinMonitor, false);
			detachListener(doc, "blur", this._focusoutMonitor, true);
			detachListener(doc, "focusout", this._focusoutMonitor, false);
			detachListener(doc, "mousedown", this._focusinMonitor, false); // It maybe in Safari
			this.initialized = false;
		}
	};

	/**
	 * Filters the target element and saves its destination URL.
	 * @see this.saveDestinationURL
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.addTarget = function(e) {
		e = e || window.event;
		var target = this.filterTarget(e);
		if (target) {
			this.target = target;
			this.saveDestinationURL(target.href);
		}
	};

	/**
	 * Filters the target element and if its destination URL had been saved,
	 * then clears the value of destination URL in the object of beacon.
	 * @see this.clearDestinationURL
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.removeTarget = function(e) {
		e = e || window.event;
		var target = this.filterTarget(e);
		if (target && this.target == target) {
			this.target = null;
			this.clearDestinationURL();
		}
	};

	/**
	 * Filter of the target element to get only anchor element (tag "A").
	 * Because we want to track only navigation through clicking on the anchor.
	 * Also checks that anchor has not empty attribute "href"
	 * and its attribute "target" is not equal "_blank".
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.filterTarget = function(e) {
		var target = e.target || e.srcElement;
		if (target.tagName
			&& "A" == target.tagName.toUpperCase()
			&& target.href
			&& target.getAttribute("target") != "_blank") {
			return target;
		} else {
			return null;
		}
	};

	/**
	 * This is a service handler of "keydown" event.
	 * A function is used to attach the context of the instance of DME2 to the listener,
	 * because context is lost when listener is attached.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype._keydownHandler = function(e) {
		if (DM) {
			DM.keydownHandler.apply(DM, arguments);
		}
	};

	/**
	 * This is a handler of "keydown" event.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.keydownHandler = function(e) {
		e = e || window.event;
		if (this.KEY_F5 == e.keyCode && !isSafari()) {
			/* Unfortunately this workaround works only in FF and Chrome, and not works in IE11.
			 * It means that in new versions of these browsers this behavior can be changed.
			 * In Safari in OSX and iOS the pressing on F5 not refreshes the page by default.
			 */
			this.clearDestinationURL();
		}
	};

	/**
	 * This is a service handler of "focusin" event.
	 * A function is used to attach the context of the instance of DME2 to the listener,
	 * because context is lost when listener is attached.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype._focusinMonitor = function(e) {
		if (DM) {
			DM.focusinMonitor.apply(DM, arguments);
		}
	};

	/**
	 * This is a handler of "focusin" event.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.focusinMonitor = function(e) {
		this.addTarget(e);
	};

	/**
	 * This is a service handler of "focusout" event.
	 * A function is used to attach the context of the instance of DME2 to the listener,
	 * because context is lost when listener is attached.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype._focusoutMonitor = function(e) {
		if (DM) {
			DM.focusoutMonitor.apply(DM, arguments);
		}
	};

	/**
	 * This is a handler of "focusout" event.
	 *
	 * @param {object} e - event object
	 */
	DME2.prototype.focusoutMonitor = function(e) {
		this.removeTarget(e);
	};

	/**
	 * Save the value of destination URL in the object of beacon ("chat active beacon" in postToServer).
	 *
	 * @param {string} url
	 */
	DME2.prototype.saveDestinationURL = function(url) {
		var chat = CHM.getChat();
		// In this case we expect that persistent chat should not depend on whether or not the opener window is closed
		if (chat
			&& !CHM.isPersistentChat()
			&& chat.isEngaged()) {
			CHM.setCABeacon(CHM.getChat().BEACON_DATA, {
				lastDestinationUrl: url
			});
		}
	};

	/**
	 * Clear the value of destination URL in the object of beacon.
	 * @see this.saveDestinationURL
	 */
	DME2.prototype.clearDestinationURL = function() {
		this.saveDestinationURL("");
	};

/**
 * Service is used for events initiated by automaton to add/remove fields before sending to server.
 *
 * @constructor
 */
function EtlDataBuilder() {
	this.eventMapper = {
		"automaton": {
			"started": this.buildStartedEvent,
			"assisted": this.buildAssistedEvent,
			"contentSentToCustomer": this.buildCommonAutomatonEvent,
			"customerResponded": this.buildCommonAutomatonEvent,
			"ended": this.buildCommonAutomatonEvent,
			"transition": this.buildCommonAutomatonEvent
		},
		"engagement": {
			"requested": this.buildEngagementRequested
		}
	};
}

EtlDataBuilder.prototype.build = function (event, rule) {
	if (this.eventMapper[event._domain] && this.eventMapper[event._domain][event.evt]) {
		return this.eventMapper[event._domain][event.evt].call(this, event, rule);
	} else {
		return this.buildUnknownEvent(event, rule);
	}
};

EtlDataBuilder.prototype.buildStartedEvent = function (event, rule) {
	/** @type {Object} */
	var chatData = {
		siteID: Inq.getSiteID(),
		businessUnitID: CHM.getBusinessUnitID(event, rule),
		agentGroupID: CHM.getAgentGroupID(event, false),
		agentID: CHM.getAgentID(),
		availableAgentAttributes: CHM.getChatOrLastChatAgentAttributesString(),
		customerID: Inq.getCustID(),
		conversationID: CONVM.getConversationID(),
		initialCustomerID: CONVM.getInitialCustomerID(),
		incAssignmentID: asi4(),
		pageID: CHM.getLaunchPageId(),
		sessionID: getSessionID(),
		visitorAttributes: VAM.getCopyAsArray(true).join(";"),
		businessRuleID: CHM.getChat() ? CHM.getChat().getRuleId() : (event.rule ? event.rule.id : rule.getID()),
		brAttributes: firstExisting('ra1t', CHM.getChat(), event && event.rule, rule) || "",
		chatID: CHM.getChatID(),
		deviceType: getDeviceType(),
		operatingSystemType: getOSType(),
		browserType: getClientBrowserType(),
		browserVersion: cbtv1(),
		preAssigned: isPreassignedChat()
	};

	if (SVYM.isAsyncSurveyCalled) {
		chatData.siteID = SVYM.asyncSurveyData.siteID;
		chatData.businessUnitID = SVYM.asyncSurveyData.businessUnitID;
		chatData.agentGroupID = SVYM.asyncSurveyData.agentGroupID;
		chatData.agentID = SVYM.asyncSurveyData.agentID;
		chatData.availableAgentAttributes = "";
		chatData.customerID = SVYM.asyncSurveyData.customerID;
		chatData.conversationID = SVYM.asyncSurveyData.conversationID;
		chatData.initialCustomerID = SVYM.asyncSurveyData.customerID;
		chatData.chatID = SVYM.asyncSurveyData.engagementID;
	}

	return MI8.mixAbsorber(MI8.unmixMutatable(MI8.mixMutatable()
			.set("_domain", event._domain)
			.set("evt", event.evt)
			.set("siteID", chatData.siteID)
			.set("businessUnitID", chatData.businessUnitID)
			.set("agentGroupID", chatData.agentGroupID)
			.set("agentID", chatData.agentID)
			.set("availableAgentAttributes", chatData.availableAgentAttributes)
			.set("customerID", chatData.customerID)
			.set("conversationID", chatData.conversationID)
			.set("initialCustomerID", chatData.initialCustomerID)
			.set("incAssignmentID", chatData.incAssignmentID)
			.set("pageID", chatData.pageID)
			.set("sessionID", chatData.sessionID)
			.set("visitorAttributes", chatData.visitorAttributes)
			.set("businessRuleID", chatData.businessRuleID)
			.set("brAttributes", chatData.brAttributes)
			.set("chatID", chatData.chatID)
			.set("deviceType", chatData.deviceType)
			.set("operatingSystemType", chatData.operatingSystemType)
			.set("browserType", chatData.browserType)
			.set("browserVersion", chatData.browserVersion)
		 	.set("preAssigned", chatData.preAssigned))
	).absorb(MI8.unmixMutatable(MI8.mixMutatable(event)
			.remove("page")
			.remove("data")));
};

EtlDataBuilder.prototype.buildAssistedEvent = function (event, rule) {
	return MI8.mixAbsorber(MI8.unmixMutatable(MI8.mixMutatable()
		.set("_domain", event._domain)
		.set("evt", event.evt)
		.set("siteID", Inq.getSiteID())
		.set("businessUnitID", CHM.getBusinessUnitID(event, rule))
		.set("agentGroupID", CHM.getAgentGroupID(event, false))
		.set("agentID", CHM.getAgentID())
		.set("availableAgentAttributes", CHM.getChatOrLastChatAgentAttributesString())
		.set("customerID", Inq.getCustID())
		.set("conversationID", CONVM.getConversationID())
		.set("initialCustomerID", CONVM.getInitialCustomerID())
		.set("incAssignmentID", asi4())
		.set("pageID", LDM.getPageID())
		.set("sessionID", getSessionID())
		.set("visitorAttributes", VAM.getCopyAsArray(true).join(";"))
		.set("businessRuleID", CHM.getChat() ? CHM.getChat().getRuleId() : (event.rule ? event.rule.id : rule.getID()))
		.set("brAttributes", firstExisting('ra1t', CHM.getChat(), event && event.rule, rule) || "")
		.set("chatID", CHM.getChatID())
		.set("deviceType", getDeviceType())
		.set("operatingSystemType", getOSType())
		.set("browserType", getClientBrowserType())
		.set("browserVersion", cbtv1())
		.set("preAssigned", isPreassignedChat()))
	).absorb(MI8.unmixMutatable(MI8.mixMutatable(event)
		.remove("page")
		.remove("data")));
};

/**
 * Currently, it's used to build the next events:
 * <ul>
 *     <li>contentSentToCustomer</li>
 *     <li>customerResponded</li>
 *     <li>ended</li>
 *     <li>transition</li>
 * </ul>
 */
EtlDataBuilder.prototype.buildCommonAutomatonEvent = function (event, rule) {
	/** @type {Object} */
	var chatData = {
		siteID: Inq.getSiteID(),
		customerID: Inq.getCustID(),
		conversationID: CONVM.getConversationID(),
		initialCustomerID: CONVM.getInitialCustomerID(),
		incAssignmentID: asi4(),
		pageID: LDM.getPageID(),
		sessionID: getSessionID(),
		chatID:  (CHM.getChatID() === "0") ? CHM.getLastChatID() : CHM.getChatID(),
		preAssigned: isPreassignedChat()
	};

	if (SVYM.isAsyncSurveyCalled) {
		chatData.siteID = SVYM.asyncSurveyData.siteID;
		chatData.customerID = SVYM.asyncSurveyData.customerID;
		chatData.conversationID = SVYM.asyncSurveyData.conversationID;
		chatData.initialCustomerID = SVYM.asyncSurveyData.customerID;
		chatData.chatID = SVYM.asyncSurveyData.engagementID;
	}

	return MI8.mixAbsorber(MI8.unmixMutatable(MI8.mixMutatable()
			.set("_domain", event._domain)
			.set("evt", event.evt)
			.set("automatonType", event.type)
			.set("siteID", chatData.siteID)
			.set("customerID", chatData.customerID)
			.set("conversationID", chatData.conversationID)
			.set("initialCustomerID", chatData.initialCustomerID)
			.set("incAssignmentID", chatData.incAssignmentID)
			.set("pageID", chatData.pageID)
			.set("sessionID", chatData.sessionID)
			.set("chatID", chatData.chatID)
            .set("preAssigned", chatData.preAssigned)
		)
	).absorb(MI8.unmixMutatable(MI8.mixMutatable(event)
			.remove("page")
			.remove("data")
			.remove("acifVersion")
			.remove("automatonAttributes")
			.remove("type")
			.remove("automatonType")
		)
	);
};

EtlDataBuilder.prototype.buildEngagementRequested = function (event, rule) {
	return MI8.mixAbsorber(MI8.unmixMutatable(MI8.mixMutatable()
		.set("_domain", event._domain)
		.set("evt", event.evt)
		.set("siteID", Inq.getSiteID())
		.set("businessUnitID", CHM.getBusinessUnitID(event, rule))
		.set("agentGroupID", CHM.getAgentGroupID(event, false))
		.set("agentID", CHM.getAgentID())
		.set("availableAgentAttributes", CHM.getChatOrLastChatAgentAttributesString())
		.set("customerID", Inq.getCustID())
		.set("conversationID", CONVM.getConversationID())
		.set("initialCustomerID", CONVM.getInitialCustomerID())
		.set("incAssignmentID", asi4())
		.set("pageID", CHM.getLaunchPageId())
		.set("sessionID", getSessionID())
		.set("visitorAttributes", VAM.getCopyAsArray(true).join(";"))
		.set("businessRuleID", CHM.getChat() ? CHM.getChat().getRuleId() : (event.rule ? event.rule.id : rule.getID()))
		.set("brAttributes", firstExisting('ra1t', CHM.getChat(), event && event.rule, rule) || "")
		.set("chatID", CHM.getChatID())
		.set("deviceType", getDeviceType())
		.set("operatingSystemType", getOSType())
		.set("browserType", getClientBrowserType())
		.set("browserVersion", cbtv1())
		.set("qt", CHM.q6t())
		.setIfNotEmpty("conversationChannel", CONVM.getConversationChannel())
		)
	).absorb(MI8.unmixMutatable(MI8.mixMutatable(event)
		.remove("page")
		.remove("data")));
};

EtlDataBuilder.prototype.buildUnknownEvent = function (event, rule) {
	return MI8.mixAbsorber(MI8.unmixMutatable(MI8.mixMutatable()
		.set("_domain", event._domain)
		.set("evt", event.evt)
		.set("siteID", Inq.getSiteID())
		.set("businessUnitID", CHM.getBusinessUnitID(event, rule))
		.set("agentGroupID", CHM.getAgentGroupID(event, false))
		.set("agentID", CHM.getAgentID())
		.set("availableAgentAttributes", CHM.getChatOrLastChatAgentAttributesString())
		.set("customerID", Inq.getCustID())
		.set("conversationID", CONVM.getConversationID())
		.set("initialCustomerID", CONVM.getInitialCustomerID())
		.set("incAssignmentID", asi4())
		.set("pageID", LDM.getPageID())
		.set("sessionID", getSessionID())
		.set("visitorAttributes", VAM.getCopyAsArray(true).join(";"))
		.set("businessRuleID", CHM.getChat() ? CHM.getChat().getRuleId() : (event.rule ? event.rule.id : rule.getID()))
		.set("brAttributes", firstExisting('ra1t', CHM.getChat(), event && event.rule, rule) || "")
		.set("chatID", CHM.getChatID())
		.set("deviceType", getDeviceType())
		.set("operatingSystemType", getOSType())
		.set("browserType", getClientBrowserType())
		.set("browserVersion", cbtv1()))
	).absorb(MI8.unmixMutatable(MI8.mixMutatable(event)
		.remove("page")
		.remove("data")));
};

/**
 * PSC1 contains methods to handle the page transition events:
 *      "beforeunload"
 *      "pagehide"
 *      "unload"
 * Also contains methods to handle "back-forward cache" problem in Safari.
 * @constructor
 */
function PSC1() {
	/** @type {boolean} */
	this.initialized = false;
	/** @type {boolean} */
	this.pageIsHidden = false;
	/** @type {?string} */
	this.beaconURL = null;
	/** @type {?string} */
	this.beaconRequestData = null;
}

/**
 * PSC1 initialization.
 * Adds event listeners on page transition events.
 */
PSC1.prototype.init = function() {
	log("PSC initialized.");
	if (this.initialized) {
		return;
	}

	this.initialized = true;

	this.g2t(function() {
		if (!this.pageIsHidden && CHM.isInlineChatInProgress()) {
			this.pageIsHidden = true;
			CHM.closeChatMonitor();
			this.sendBeaconToTS();
			if (this.beaconURL && this.beaconRequestData) {
				sendBeacon(this.beaconURL, this.beaconRequestData);
			}
		}
	}.bind(this));

	attachListener(window, 'pageshow', this.cipri, false);
};

/**
 * Adds unload handlers.
 *
 * We should use handler of UNLOAD event
 * because BEFOREUNLOAD event not firing when iframe removed from the DOM.
 *
 * We also use BEFOREUNLOAD event because in modern WebKit browsers
 * don't necessarily fire UNLOAD event at the moment where the page is hidden.
 * @see: For more detail see tickets RTDEV-8126 and RTDEV-8293 and followings discussion:
 * @see: https://www.webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/
 *
 * And we should use handler of PAGEHIDE event
 * because UNLOAD and BEFOREUNLOAD event is not firing anymore in IOS9.
 * @see: http://jira.touchcommerce.com/browse/RTDEV-10626
 *
 * @param {function} handler - event handler
 * @param {boolean=} useCapture - optional, @see "attachListener" in Utils.js
 */

PSC1.prototype.g2t = function(handler, useCapture) {
	attachListener(window, "unload", handler, useCapture);
	attachListener(window, "beforeunload", handler, useCapture);
	attachListener(window, "pagehide", handler, useCapture);
};

/**
 *	In case of loading page from browser cache,	when user interacts via back/forward buttons
 *	we have to reinit chat to avoid a range of problems like missing Page Markers and missing messages.
 *
 *	event.persisted property shows if the page was loaded from cache.
 *
 * 	Relevant for Safari
 *
 *	@param {PageTransitionEvent} event
 *	@return {void}
 */
PSC1.prototype.cipri = function(event) {
	if (event.persisted) {
		log('reinitChat() was called from PSC1');
		reinitChat();
	}
};

/**
 * Sends beacon with page reloading data to tagserver when chat visible for customer.
 * There no data in body, because "logline" endpoint on TS won't work correct
 * with Content-Type: "text/plain;charset=UTF-8". All needed data will be added to URL.
 */
PSC1.prototype.sendBeaconToTS = function() {
	var logText = plc1("Page was reloaded. " + CHM.getChat());
	var url = urls.loggingURL + "?line=" + encodeURIComponent(logText);

	sendBeacon(url);
};

/**
 * Sets beacon data and url.
 *
 * @param {string} url - beacon url
 * @param {string} action - the action for setting the state of the beacon
 * @param {string} beaconRequestData - customer and engagement ids
 * @see Chat#setCABeacon
 */
PSC1.prototype.setBeaconData = function (url, action,  beaconRequestData) {
	if (action === "DEACTIVATE") {
		this.resetBeaconData();
	} else {
		this.beaconURL = url;
		this.beaconRequestData = beaconRequestData;
	}
};

/**
 * Reset beacon url and data to null.
 */
PSC1.prototype.resetBeaconData = function () {
	this.beaconURL = null;
	this.beaconRequestData = null;
};

/**
 * Manages conversation data.
 * <p> Singleton object for INQ
 * @constructor
 * @borrows Observable#addListener as #addListener
 * @borrows Observable#isListener as #isListener
 */
function TSD4() {
	this._observable();
	this.evtIdx = 0;
	this.lastBusinessUnitId = null;
	this.lastAgentGroupId = null;
	this.initialCustomerID = null;
	this.conversationTokenID = null;
	this.conversationObjectID = null;

	/** Returns conversationID for async engagement
	* @returns {string|undefined} conversationID, undefined if there is no conversationID
	*/
	this.getConversationID = function () {
		return CHM.getChatInterfaceData().cid;
	};

	/**
	 * Returns initial customerID for async engagement
	 * @returns {string|undefined} initial customerID, undefined if there is no initial customerID
	 */
	this.getInitialCustomerID = function () {
		return this.initialCustomerID || CHM.getChatInterfaceData().iccid;
	};
}

MI8.prepare(TSD4).im13(MI8.Observable).im13(MI8.XJA3);

TSD4.prototype.agrtyer = function() {
	this.createConversationVars();
	/*
	 * Conversation ids are used for cross channel filter option
	 * on getTranscripts and ChatRequestMessage calls.
	 */
	this.conversationTokenID = PM.getVar("conversationTokenID")
		? PM.getVar("conversationTokenID").getValueOrDefault() : null;
	this.conversationObjectID = PM.getVar("conversationObjectID")
		? PM.getVar("conversationObjectID").getValueOrDefault() : null;
}

/**
 * Creates variables for storing conversationTokenID (short name cti)
 * and conversationObjectID (short name coi) if token was received from CR
 * in async.unauth.token.info message
 */
TSD4.prototype.createConversationVars = function () {
	if (!PM.getVar("conversationTokenID") && CHM.isAsyncUnauthUser()) {
		var conversationTokenIDVar = new VER34(
			"conversationTokenID",
			null,
			resources["conversationTokens"],
			"cti"
		);

		PM.addVar(conversationTokenIDVar);
	}

	if (!PM.getVar("conversationObjectID") && CHM.isAsyncUnauthUser()) {
		var conversationObjectIDVar = new VER34(
			"conversationObjectID",
			null,
			resources["conversationTokens"],
			"coi"
		);

		PM.addVar(conversationObjectIDVar);
	}
};

TSD4.prototype.getLastAgentGroupID = function () {
	return this.lastAgentGroupId;
};

TSD4.prototype.getLastBusinessUnitID = function () {
	return this.lastBusinessUnitId;
};

/**
 * Return current conversation tokenID
 * @return {string}
 */
TSD4.prototype.getConversationTokenID = function () {
	return this.conversationTokenID;
};

/**
 * Return current conversation objectID
 * @return {string}
 */
TSD4.prototype.getConversationObjectID = function () {
	return this.conversationObjectID;
};

/**
 * Sets conversation tokenID
 *
 * @param {string} conversationTokenID - Conversation tokenID
 * @param {string} conversationObjectID - Conversation objectID
 */
TSD4.prototype.setConversationIDs = function (conversationTokenID, conversationObjectID) {
	if ((this.conversationTokenID !== conversationTokenID
			|| this.conversationObjectID !== conversationObjectID)
		&& PM.getVar("conversationTokenID")
		&& PM.getVar("conversationObjectID")
	) {
		PM.getVar("conversationTokenID").z3(conversationTokenID);
		PM.getVar("conversationObjectID").z3(conversationObjectID);
	}

	this.conversationTokenID = conversationTokenID;
	this.conversationObjectID = conversationObjectID;
};

/**
 * Appends conversation ID's to the given data object
 * @param {Object} targetObject - object to append to
 * @return {boolean} - returns true if appended
 */
TSD4.prototype.appendConversationIDsTo = function (targetObject) {
	if (targetObject !== null && typeof targetObject == 'object') {
		if (this.conversationTokenID && this.conversationObjectID) {
			targetObject.conversationTokenID = this.conversationTokenID;
			targetObject.conversationObjectID = this.conversationObjectID;
		}
	}
};

TSD4.prototype.setLastBusinessUnitAndAgentGroup = function (lastBu, lastAg) {
	this.lastBusinessUnitId = lastBu;
	this.lastAgentGroupId = lastAg;
};

/**
 * Clean up intitialCustomerID, last Business Unit and Agent Group data
 */
TSD4.prototype.reset = function() {
	this.lastAgentGroupId = null;
	this.lastBusinessUnitId = null;
	this.initialCustomerID = null;
};

/**
 * Validate that the given listener object contains valid TSD4 listener definitions
 * @param l {Object} - listener object
 * @return {boolean}
 */
TSD4.prototype.isListener = function(l) {
	return !!(l &&
		(
             l.onAgentAssigned 
          || l.onConversationResolved
          || l.onCustomerAuthenticated
          || l.onVerifyTokenSuccess
          || l.onVerifyTokenError
		)
	);
};

/**
 * Need to set last Business Unit and Agent Group when new owner enters chat
 * @param evt
 */
TSD4.prototype.onAgentAssigned = function (evt) {
	if (evt.businessUnitID && CHM.isAsyncChat()) {
		this.setLastBusinessUnitAndAgentGroup(evt.businessUnitID, evt.agentGroupID);
	}
};

/**
 * Sets initial customer ID of conversation
 * @param {string} customerID
 */
TSD4.prototype.setInitialCustomerID = function (customerID) {
	this.initialCustomerID = customerID;
};

/**
 * Fires event when conversation resolved
 */
TSD4.prototype.fireConversationResolvedEvent = function () {
	var evt = MI8.mixAbsorber({
		id: ++this.evtIdx,
		evtType: this.EVENTS.CONVERSATION_RESOLVED,
		timestamp: new Date()
	});
	evt.absorb({chatID: CHM.getChatID(), customerID: Inq.getCustID(), conversationID: this.getConversationID()});
	this._fireEvt(
		function (aListener, aEvent) {
			if (typeof aListener.onConversationResolved == "function") {
				aListener.onConversationResolved(aEvent);
			}
		},
		evt
	);
};

/**
 * Fires event when a token verification was successful
 * @param event {Object} - response data from verifyToken success event
 */
TSD4.prototype.fireVerifyTokenSuccessEvent = function (event) {
	var evt = MI8.mixAbsorber({
		id: ++this.evtIdx,
		evtType: this.EVENTS.TOKEN_SUCCESS,
		timestamp: new Date(),
		siteID: getSiteID(),
		customerID: Inq.getCustID()
	});
	evt.absorb(event);
	this._fireEvt(
		function (aListener, aEvent) {
			if (typeof aListener.onVerifyTokenSuccess == "function") {
				aListener.onVerifyTokenSuccess(aEvent);
			}
		},
		evt
	);
};

/**
 * Fires event when a token verification has failed.
 * @param event {Object} - response data from verifyToken error event
 */
TSD4.prototype.fireVerifyTokenErrorEvent = function (event) {
	var evt = MI8.mixAbsorber({
		id: ++this.evtIdx,
		evtType: this.EVENTS.TOKEN_ERROR,
		timestamp: new Date(),
		siteID: getSiteID(),
		customerID: Inq.getCustID()
	});
	evt.absorb(event);
	this._fireEvt(
		function (aListener, aEvent) {
			if (typeof aListener.onVerifyTokenError == "function") {
				aListener.onVerifyTokenError(aEvent);
			}
		},
		evt
	);
};

/**
 * Fires event when customer authenticated (chat is converted from sync to async)
 */
TSD4.prototype.fireCustomerAuthenticated = function () {
	var evt = MI8.mixAbsorber({
		id: ++this.evtIdx,
		evtType: this.EVENTS.CUSTOMER_AUTHENTICATED,
		timestamp: new Date()
	});
	evt.absorb({chatID: CHM.getChatID(), customerID: Inq.getCustID(), conversationID: this.getConversationID()});
	this._fireEvt(
		function (l, evt) {
			if (typeof l.onCustomerAuthenticated == "function") {
				l.onCustomerAuthenticated(evt);
			}
		},
		evt
	);
};

/**
 * Returns value for `conversationChannel` parameter to evtData in {@link EtlDataBuilder.buildEngagementRequested}
 * if all conditions allow
 * @return {string|undefined}
 */
TSD4.prototype.getConversationChannel = function () {
	if (CHM.isAsyncChat()) {
		return "WEB";
	} else {
		return undefined;
	}
};

TSD4.prototype.resolveConversation = function () {
	if (this.conversationTokenID && this.conversationObjectID) {
		var data = {
			conversationTokenID: this.conversationTokenID,
			conversationObjectID: this.conversationObjectID
		}
		var resolveConversation = CHM.getChatRouterURL() + urls.resolveConversation;
		var id = generateRequestId("resolveConversation");

		ROM.sendToChatrouter(resolveConversation, data, id);
		this.fireConversationResolvedEvent();
	}
};

/**
 * Conversation manager event types list
 * @type {(Object)}
 * */
TSD4.prototype.EVENTS = {
	CONVERSATION_RESOLVED: "CONVERSATION_RESOLVED",
	CUSTOMER_AUTHENTICATED: "CUSTOMER_AUTHENTICATED",
	TOKEN_SUCCESS: "TOKEN_SUCCESS",
	TOKEN_ERROR: "TOKEN_ERROR"
};


	/*
	 * RTDEV-128. CL 20119. ChatRouter domain is stored in database but we should
	 * store full URL. Because of discrepancies between configuration and
	 * inq_new databases we can't update DB values. To get full CR url it decided
	 * to add HTTPS protocol to vanity domain value.
	 */
	var urls = {
		addActiveWindowIdURL: "/chatrouter/chat/addActiveWindowId",
		agentsAvailabilityCheckURL: secureProtocol(site.vanityDomainName+"/tagserver/launch/agentAvailability"),
		apiServiceURL: secureProtocol(site.apiServiceURL + "/surveyemailalert"),
		authUserURL: secureProtocol(site.vanityDomainName + "/tagserver/tracking/authenticatedUser"),
		baseURL: secureProtocol(site.vanityDomainName + "/tagserver"),
		cdnURL: secureProtocol(site.cdnURL),
		chatRouterVanityDomain: secureProtocol(site.chatRouterVanityDomain),
		cobrowseURL: secureProtocol(site.cobrowseURL),
		conversationTranscriptURL: secureProtocol(site.vanityDomainName + "/tagserver/conversation"),
		exitChatURL: "/chatrouter/chat/exitChat",
		getCustIDURL: secureProtocol(site.vanityDomainName + "/tagserver/init/getCustomerID"),
		getExistingChatDataForReconnectOrNewChatId: secureProtocol(site.vanityDomainName + "/tagserver/launch/getExistingChatDataForReconnectOrNewChatId"),
		getNewChatIdUrl: secureProtocol(site.vanityDomainName + "/tagserver/launch/getNewChatId"),
		getSiteTzOffsetURL: secureProtocol(site.vanityDomainName + "/tagserver/init/getSiteTzOffset"),
		initFrameworkURL: secureProtocol(site.vanityDomainName + "/tagserver/init/initFramework"),
		isPersistentActive: "/chatrouter/chat/isPersistentActive",
		loggingURL: secureProtocol(site.vanityDomainName + "/tagserver/logging/logline"),
		logDataURL: secureProtocol(site.vanityDomainName + "/tagserver/logging/logdata"),
		logDataEvtListURL: secureProtocol(site.vanityDomainName + "/tagserver/logging/logDataEvtList"),
		logJsURL: secureProtocol(site.clusterEnvironment + "tslogging.touchcommerce.com/tagserver/logging/log4js"),
		logJsPostURL: secureProtocol(site.vanityDomainName + "/tagserver/logging/log4js"),
		mediaBaseURL: secureProtocol(site.mediaServer + "/media"),
		mediaLaunchCiURL: secureProtocol(site.mediaServer + "/media/launch/ci"),
		mediaRootURL: secureProtocol(site.mediaServer),
		mediaSiteURL: secureProtocol(site.mediaServer + "/media/sites/" + site.siteID),
		nativePostChatSurveyURL: secureProtocol(site.vanityDomainName + "/tagserver/survey/submitNativePostChatSurvey"),
		one2ManyVanityDomain: secureProtocol(one2ManyChatrouterDomain),
		pageUnloadURL: "/chatrouter/chat/pageUnload",
		persistentComplete: "/chatrouter/chat/persistentComplete",
		resolveConversation: "/chatrouter/resolveConversation",
		resolvePageURL: secureProtocol(site.vanityDomainName + "/tagserver/launch/resolvePage"),
		resolvePageWSURL: secureProtocol(site.resolvePageWSDomain + "/launch/resolvePage"),
		requestC2CImageURL: secureProtocol(site.vanityDomainName + "/tagserver/launch/requestC2CImage"),
		requestChatLaunchURL: secureProtocol(site.vanityDomainName + "/tagserver/launch/requestChatLaunch"),
		requestCustomerStatus: secureProtocol(site.vanityDomainName + "/tagserver/conversation/customerStatus"),
		siteHostedFileDomains: site.hostedFileDomains || "",
		siteHostedFileURL: productionFilter(site.psHosturlList || "", site.productionFilter),
		skinURL: secureProtocol(site.vanityDomainName + "/chatskins/sites/" + site.siteID + "/flash/"),
		vanityURL: secureProtocol(site.vanityDomainName),
		verifyTokenURL: secureProtocol(site.vanityDomainName + "/tagserver/conversation/verifyToken"),
		xFormsDomain: secureProtocol(site.xformsVanityDomain)
	};

	function getCurrentSetting () {
		function getCurrentSettingById (id) {
			if (id) {
				for (var i = 0; i < site.cobrowseSettings.length; i++) {
					if (site.cobrowseSettings[i].id == id) {
						return site.cobrowseSettings[i];
					}
				}
			}
			return null;
		}

		function getCurrentSettingByBusinessUnitId (id) {
			var settingId = site.businessUnitDictionary[id];
			if (settingId) {
				return getCurrentSettingById(settingId);
			}
			return null;
		}

		// return existing setting
		if (site.cobrowseSettings.length == 1) {
			return site.cobrowseSettings[0];
		}

		if (site.agentGroupsActive) {
			// agent group setting
			var agentGroupID = CHM.getAgentGroupID();
			var agentGroupSetting = getCurrentSettingById(agentGroupID);
			if (agentGroupSetting) {
				return agentGroupSetting;
			}
		} else {
			// business unit setting
			var businessUnitID = CHM.getBusinessUnitID({}, true);
			var businessUnitSetting = getCurrentSettingByBusinessUnitId(businessUnitID);
			if (businessUnitSetting) {
				return businessUnitSetting;
			}
		}
		// site setting
		return getCurrentSettingById(siteID)
	}

	/**
	 * Get message by key based on language settings.
	 * @param {string} a message key
	 * @return {string} message
	 */
	function getLocalizedMessage (key, ignoreUndefinedText) {
		var setting = getCurrentSetting();
		if (setting) {
			var messages = setting.messages;
			if (messages) {
				var result = messages[key];
				if (result) {
					return result;
				}
			}
		}
		return ignoreUndefinedText ? null : "undefined message for the key [" + key + "]";
	}

	function getEnableHighlight () {
		return getLocalizedMessage("enableCobrowseHighlight") !== "false";
	}

	/**
	 * RTDEV-15837. Ability to the Agent to minimize and restore a chat
	 */
	function getCobrowseEnableMinimizeRestore () {
		var setting = getCurrentSetting();
		if (setting) {
			var messages = setting.messages;
			if (messages) {
				var result = messages["cobrowseEnableMinimizeRestore"];
				if (result === "true") {
					return true;
				}
			}
		}
		return false;
	}

	if (typeof RENDERINGCONTEXT !== 'undefined') {
		// early loading. Used by businessConstants
		RENDERINGCONTEXT = {
			Date: Date
		}
	}

	var businessConstants = site.businessConstants();
	var constants = MI8.mixAbsorber();
	if (jsSDKEnabled) {
		constants.absorb(JSSDK_RENDERER.RenderAbstractConstants(jsonAPIData["program-data"]["constants"]));
	} else {
		constants.absorb(programRulesConfig("constants"));
	}

	// If any constant in business part has the same name as a constant from program part,
	// the constant from program part will be overridden by this absorb.
	// Validity of such override is checked by corresponding constraints in br30.xsd
	constants.absorb(businessConstants);

	if (typeof RENDERINGCONTEXT !== 'undefined') {
		//Full loading of the rendering context
		RENDERINGCONTEXT = {
			Rule: Rule,
			BusinessRule: BusinessRule,
			LDM: LDM,
			PM: PM,
			FM: FM,
			BRM: BRM,
			VAM: VAM,
			C2CM: C2CM,
			CHM: CHM,
			SVYM: SVYM,
			ROM: ROM,
			CM: CM,
			FP: FP,
			EVM: EVM,
			win: win,
			log: log,
			MI8: MI8,
			e9: e9,
			DFV: DFV,
			getDFV: getDFV,
			gc7: gc7,
			processReceivedExternalDataThrows: processReceivedExternalDataThrows,
			isServiceBlocked: isServiceBlocked,
			d8t: d8t,
			s7: s7,
			safeResult: safeResult,
			SL1: SL1,
			getDefaultValueIfNull: getDefaultValueIfNull,
			URI: URI,
			doc: doc,
			rand: rand,
			inu1: inu1,
			secureProtocol: secureProtocol,
			cf21: cf21,
			pd1d: pd1d,
			let12: let12,
			getSiteID: getSiteID,
			asi4: asi4,
			getSessionID: getSessionID,
			lmt12: lmt12,
			urls: MI8.clonize(urls).clone(),
			WebResource: WebResource,
			JSResource: JSResource,
			CCD: CCD,
			publishAPI: publishAPI,
			getClientBrowserType: getClientBrowserType,
			XFormsLoader: XFormsLoader,
			setPersistCustID: setPersistCustID,
			setAuthUser: setAuthUser,
			setUserObject: setUserObject,
			Date: Date,
			LOG_LEVELS: LOG_LEVELS,
			resources: resources,
			cbtv1: cbtv1,
			getOSType: getOSType,
			EXCBTT: EXCBTT,
			firstExisting: firstExisting,
			isC2PActive: isC2PActive,
			getBlockedServicesList: getBlockedServicesList,
			getDeviceType: getDeviceType,
			getDefaultLanguage: getDefaultLanguage,
			compareVersions: compareVersions,
			CRMT: CRMT,
			Schedule: Schedule,
			getConversationActive: getConversationActive,
			LocalStorageResource: LocalStorageResource,
			isSchMet: isSchMet
		}
	}

	/**
	 * Public function
	 * API: Private function that returns the client window's IFRAME that launched the pop-out chat
	 * @return {Window|null} - the client window's IFRAME that launched the pop-out chat
	 */
	function o1p () {
		var opener = null;
		if (isPersistentWindow()) {
			try {
				if (isWebSDK) {
					opener = (window.opener && FrameBridge.o1p()) ? FrameBridge.o1p() : null;
				} else {
					opener = (window.parent.opener && window.parent.opener.inqFrame)
						? window.parent.opener.inqFrame
						: ((window.opener) ? window.opener : null);
				}
			} catch (e) {
				log("Error getting opener: " + e.message);
			}
		}
		return opener;
	}

	/**
	 * Call the function in the scope of the opener window.
	 * Opener - it is a window that opened the popup window contains a persistent chat.
	 * @param {function} func - called function
	 * @param {Array=} args - list of arguments, if not defined then is empty list
	 * @param {boolean=} async - flag to call function asynchronously
	 * @return {*}
	 */
	function openerCall (func, args, async) {
		var opener = o1p();
		if (!inu1(opener) && opener.Inq && opener.Inq.FlashPeer) {
			if (!opener.Inq.FlashPeer.callFromPersistent("isPersistentWindowRegisteredInOpener")) {
				opener.Inq.FlashPeer.callFromPersistent("registerPersistentWindowInOpener", [parent], false);
			}
			return opener.Inq.FlashPeer.callFromPersistent(func, args, async);
		}
	}

	/**
	 * frameworkCanRun- filter framework that selectively stops the IJSF from running
	 * @param deviceType {string}: See http://stash.touchcommerce.com/projects/RT/repos/rt/browse/br30/src/test/resources/ProgramRules.xml#1687 for definitions
	 * @param _3pcSupported {boolean}: set to true if the third party cookies are supported in the code context, false if 3pc is disabled.
	 * @param _1pcSupported {boolean}: set to true if the first party cookies are supported in the code context, false if cookies are disabled.
	 * @param xdActive {boolean}: set to true if xdMode is set, false if cookies are disabled.
	 */
	var frameworkCanRun = site.frameworkCanRun;

	function isSameOrigin () {
		try {
			if (isPersistentWindow()) {
				if (isWebSDK) {
					if (window.opener.Inq) {
						return true;
					} else {
						return false;
					}
					// this invocation will throw an error if "same origin policy" is violated (http://en.wikipedia.org/wiki/Same_origin_policy)
				} else if (window.parent.opener.Inq) {
					// note: in Chrome there is no exception is thrown and it always returns true, added additional check
					return true;
				} else {
					return false;
				}
			}
		} catch (err) {
			return false;
		}
	}

	function getID () {
		return this._id;
	}

	function getCustID () {
		if (inu1(initData.custID)) {
			return "";
		} else {
			return initData.custID;
		}
	}

	/**
	 * Sets customer id and update data in cookies
	 * @param {string} customerID
	 * @param {boolean} save - should cookies be saved or not
	 */
	function setCustID (customerID, save) {
		if (!inu1(customerID)) {
			logInfoToTagServer(
				"Changing current customerID: " + initData.custID
				+ " to newCustomerID:" + customerID
			);
			initData.custID = customerID;
			if (save) {
				Inq.save();
			}
		}
	}

	/**
	 * @private
	 * @returns {JSONObject} current value of customer's geo data.
	 * Format: {"country_code":"BY", "zip_code":"220007", "region_code":"MN"}
	 */
	function getCustGeoData () {
		return initData["geoData"];
	}

	var userObject = null;

	function getUserObject () {
		return userObject;
	}

	function setUserObject (object) {
		userObject = object;
	}

	/**
	 * @private
	 * @returns {Object} current value of persistent customer id. Stored in session cookie.
	 */
	function getPersistCustID () {
		return persistentCustomerID;
	}

	/**
	 * @private
	 * @returns {?Object} current value of authenticated user. Not stored in cookie.
	 */
	function getAuthUser () {
		return authenticatedUser;
	}

	/**
	 * Flag is set to true when we sent request to get a new customer ID and reset when we get response
	 * @type {boolean}
	 */
	var custIdRegenerationInProgress = false;
	/**
	 * Set to true when we need to launch chat but need to wait for specific event.
	 * For example we need to wait for a new customerID if click on C2C during regeneration to launch async chat
	 * @type {boolean}
	 */
	var needToLaunchChat = false;

	/**
	 *  Set authenticatedUser object that consists from persistentCustomerID object and additional fields
	 *
	 * @param {object=} persistCustID persistentCustomerID object.
	 * Example: "persistentCustomerID":{"email":"aaa@gmail.com"}
	 * @param {object=} simpleObject object with additional parameters for authentication user
	 */
	function setAuthUser (persistCustID, simpleObject) {
		authenticatedUser = {};
		if (simpleObject) {
			authenticatedUser = simpleObject;
		}
		if (persistCustID) {
			authenticatedUser.persistentCustomerID = persistCustID;
		}
		var engagementId = CHM.getChatID();
		if (engagementId !== "0") {
			ROM.sendAuthenticatedUser(authenticatedUser);
		}
	}

	/**
	 *
	 * Set persistent customer id and a flag indicating it is used for server side security
	 * e.g. <set-persistent-customer-id secure-with-cust-token="true">.
	 *
	 * If secureWithCustToken is true then persistentCustomerID won't be save to cookies,
	 * so server will accept requests only if setPersistCustID will be called after page reload
	 * with same persistentCustomerID.
	 *
	 * @private
	 * @param {object} persistCustID
	 * @param {boolean=} isSecureWithCustToken
	 * @param {boolean=} allowEmptyValues if true then allow to set empty values for pcID otherwise keys with empty values will be removed
	 */
	function setPersistCustID (persistCustID, isSecureWithCustToken, allowEmptyValues) {
		var persistDataVar = new VER34("pcID", {}, resources["session"]);
		secureWithCustToken = !!isSecureWithCustToken;
		CHM.setSecureWithCustToken(secureWithCustToken);

		if (!allowEmptyValues) {
			for (var key in persistCustID) {
				//null, undefined, empty string
				if (persistCustID.hasOwnProperty(key) && (inu1(persistCustID[key]) || persistCustID[key] === "")) {
					delete persistCustID[key];
				}
			}
		}

		if (!secureWithCustToken) {
			var pcID = persistDataVar.z0();
			if (!objectEquals(pcID, persistCustID)) {
				CONVM.reset();
				if (!CHM.getChat() || CHM.getChat().isAsyncChat()) {
					renewCustomerId();
				}
			}
			persistentCustomerID = persistCustID;
			Inq.save(); /*@TODO: privatize the save function */
		} else {
			if (!objectEquals(persistentCustomerID, persistCustID)) {
				CONVM.reset();
			}

			if (!isEmptyObject(persistDataVar.z0())) {
				// persistence customer id should be reset in cookies
				// if it exist and secureWithCustToken flag is true
				persistDataVar.z3({});
			}

			persistentCustomerID = persistCustID;
		}
	}

	function renewCustomerId () {
		//TODO Need to clean up code to regenerate customerID after release RTDEV-31977
		var customerRegenerationEnabled = PM.getVar("enableCustomerIDRegenerationFeature");
		if (customerRegenerationEnabled && customerRegenerationEnabled.z0() === true) {
			if (CHM.getChat() && CHM.getChat().isAsyncChat()) {
				log("Closing chat window because persistentCustomerID was changed and customer ID will be re-generated");
				if (CHM.getChat().isVisible()) {
					CHM.closeChat();
					FP.closeChatInterface();
					window["Application"] = null;
				} else {
					CHM.needToCloseOnChatShown = true;
				}
			}
			ROM.post(urls.getCustIDURL, { "siteID": Inq.getSiteID() }, null, null, setCustomerId);
			custIdRegenerationInProgress = true;
		}
	}

	var customerIdRenewRetriesCount = 0;

	/**
	 * Set Customer Id and save it to cookie if obj is expected object
	 * @param {Object} obj comes from getCustIDURL response. Expect object which contains data.custID
	 */
	function setCustomerId (obj) {
		var data = typeof obj === "object" && obj.data ? obj.data : null;
		if (typeof data === "string") {
			try {
				data = JSON.parse(data);
			} catch (e) {
				let12("Cannot parse response from getCustomerID, response" + data, true);
				data = null;
			}
		}
		if (data && !inu1(data.custID)) {
			setCustID(data.custID, true);
			if (isInitialized()) {
				BRM.fireOnResetSession();
			} else {
				BRM.fireResetSessionOnStart = true;
			}
			custIdRegenerationInProgress = false;
			if (needToLaunchChat) {
				CHM.launchDelayedChat();
				needToLaunchChat = false;
			}
			customerIdRenewRetriesCount = 0;
		} else {
			++customerIdRenewRetriesCount;
			//allow to retry three times
			if (customerIdRenewRetriesCount < 3) {
				setTimeout(function () {
					ROM.post(urls.getCustIDURL, { "siteID": Inq.getSiteID() }, null, null, setCustomerId);
				}, 1000);
			} else {
				//block services for session since we were unable to generate new customerID
				blockServices(["ALL"], 0);
				let12("Customer regeneration failed! Services will blocked for session!", true);
				customerIdRenewRetriesCount = 0;
				//reset to not show available C2Cs
				C2CM.reset();
			}
		}
	}

	function getCustIP () {
		return initData.custIP;
	}

	var siteID = site.siteID;

	function getSiteID () {
		return siteID;
	}

	function getChatSkinFormat () {
		if (site.hasOwnProperty("chatSkinFormat")) {
			return site.chatSkinFormat;
		} else {
			return "mxml";
		}
	}

	var fileUploadSize = site.fileTransferSize;
	var fileDeleteSetting = site.fileDeleteSetting;

	// Returns site language, setted in sites table (Portal -> internal page.)
	function getDefaultLanguage () {
		return site.language;
	}

	function getCiObfuscationLevel () {
		return parseInt(site.ciObfuscation);
	}

	function isJsDebugActive () {
		return site.JSDebugMode;
	}

	function isJsLoggingActive () {
		return !JSLoggingDisabled;
	}

	function isLogToServerDisabled () {
		return disableLogToServer;
	}

	function getRootDomainsList () {
		return site.rootDomainsList;
	}

	/**
	 * Returns refreshIframeDelayIncrement from db if exist
	 * @returns {number}
	 */
	function getRefreshIframeDelayIncrement () {
		return site.refreshIframeDelayIncrement;
	}

	/**
	 * Returns maxRefreshIframeDelay from db if exist
	 * @returns {number}
	 */
	function getMaxRefreshIframeDelay () {
		return site.maxRefreshIframeDelay;
	}

	/**
	 * Returns true if need to hide JSON-formatted messages from conversation transcript
	 * @returns {boolean}
	 */
	function isHideJsonTranscriptMessages () {
		return !!site.hideJsonTranscriptMessages;
	}

	/**
	 * Returns true if aliases toggle enabled.
	 * @returns {boolean}
	 */
	function isAliasesNoEvalToggleEnable () {
		return site.aliasesToggle;
	}

	/**
	 * Returns true if polish notation enabled.
	 * @returns {boolean}
	 */
	function isPolishNotationEnabled () {
		return site.usePolishNotation;
	}

	function getDefaultAgentGroupId () {
		return site.defaultAgentGroup;
	}

	/**
	 * Returns clearOutdatedCookies value from db
	 * @returns {Boolean}
	 */
	function getClearOutdatedCookies () {
		return site.clearOutdatedCookies;
	}

	/**
	 * Returns useNativeJson value from db
	 * @returns {Boolean}
	 */
	function useNativeJson () {
		return site.useNativeJson;
	}

	function isCacheSolutionEnabled () {
		return site.cacheSolutionEnabled;
	}

	/**
	 * Getter for postChatSurveyLogsEnabled flag.
	 *
	 * @return {boolean}
	 */
	function isPostChatSurveyLogsEnabled () {
		return site.postChatSurveyLogsEnabled;
	}

	function getFlagSendDataToTSWithoutIframe() {
		return site.sendDataToTSWithoutIframe;
	}

    function getSessionID () {
		var sesVar = PM.getVar("sesID");
		return sesVar ? sesVar.z0() : "";
	}

	function asi4 () {
		var incAssignmentID = PM.getVar("incID");
		return incAssignmentID ? incAssignmentID.z0() : "";
	}

	function getIncGroupID () {
		var inqGroupID = PM.getVar("incGroup");
		return inqGroupID ? inqGroupID.z0() : "";
	}

	// Returns default business unit id specified in <business> tag
	var getDefaultBusinessUnitID = site.getDefaultBusinessUnitID;

	/**
	 *   TC has only 4 fixed devicetypes;
	 *      Unsupported, Tablet, Phone, Standard
	 *      Standard is default device type.
	 */
	var deviceType = "Standard";

	// Sets device type
	function setDeviceType (newDeviceType) {
		deviceType = newDeviceType;
	}

	// Returns device type
	function getDeviceType () {
		return deviceType;
	}

	// Returns true if the argument is same as getDeviceType
	function d8t (type) {
		return type == getDeviceType();
	}

	// Sets device details
	function setDeviceDetails (newDeviceDetails) {
		deviceDetails = newDeviceDetails;
	}

	// Returns device details
	function getDeviceDetails () {
		return deviceDetails;
	}

	/*
	 * Client time lag is the lag in ms between browser and server time.
	 * Negative value e.g. -1000ms means browser clock is fast e.g. 10:00:01 compared to server clock 10:00:00.
	 * clntLag value is calculated after initialization request to server is done and server returned server time.
	 * Calculated value is stored to vital cookie for the lifetime of this customer.
	 */
	function getClientTimeLag () {
		return initData.clntLag;
	}

	// ID of site timezone. It is used in calculations for weekly shcedules.
	var siteTzID = site.timezoneID;

	/*
	 * Returns site time zone offset. The offset is requested from server once per session (less frequent requests
	 * could lead to miscalculations due to DST adjustments).
	 * Calculations can't be performed on client side due to poor support of timezones in JS Date object.
	 */
	function getSiteTZOffset () {
		return initData["siteTzOffset"];
	}

	/*
	 * If no schedules are configured, request to server for TZ offset won't be preformed.
	 * Request is performed once per session, but listening to NewSession event is not an option since
	 * TZ offset is needed earlier than the event is fired. Thus request is performed if offset value
	 * was not available in session cookie on page load.
	 * siteTzOffset - map contains timezones from schedules and current timezoneOffset (with DST offset).
	 * @return false if there's no need to perform request for site TZ offset
	 */
	function isTZRequestRequired () {
		if ((!isEmptyObject(businessSchedules) || 
!isEmptyObject(programSchedules))
			&& inu1(initData["siteTzOffset"])
		){
			return true;
		}
		return false;
	}

	// This is a convenience shorthand method to minimize amount of rendered code.
	function isSchMet (scheduleId) {
		if (schedules[scheduleId]) {
			schedules[scheduleId].tzOffset = initData.scheduleTZs[schedules[scheduleId].timezone];
		}
		return (schedules[scheduleId] && schedules[scheduleId].isScheduleMet(
			new Date(), getClientTimeLag(), getSiteTZOffset()));
	}

	function processCustomerApiRegistry () {
		Inq.overridePageID = (!!win.inqSiteID) ? win.inqSiteID : -1;
		var registry;

		if (isWebSDK) {
			registry = window.InqRegistry;
		} else {
			registry = window.parent.InqRegistry
		}

		// add all customer listeners
		if (registry) {
			var listeners = [];
			if (!inu1(registry.chatListeners)) {
				listeners.append(registry.chatListeners);
			}
			if (!inu1(registry.saleListeners)) {
				listeners.append(registry.saleListeners);
			}
			if (!inu1(registry.incrementalityListeners)) {
				listeners.append(registry.incrementalityListeners);
			}
			if (!inu1(registry.listeners)) {
				listeners.append(registry.listeners);
			}

			// add a flag to each listener so that Observables can limit what they send
			for (var x = 0; x < listeners.length; x++) {
				listeners[x].custApi = true;
			}
			EVM.addListeners(listeners);

			// block services at customer request
			if (!inu1(registry.disableChat) && registry.disableChat == true) {
				tryue(CHM.CHAT_TYPES.POPUP, 0);
			}
			if (!inu1(registry.disableC2C) && registry.disableC2C == true) {
				tryue(CHM.CHAT_TYPES.C2C, 0);
			}
		}
	}

	function saveDeviceDetails (details) {
		if (details != null) {
			var ddVar = PM.getVar("deviceDetailsMap");
			if (ddVar != null) {
				ddVar.clear();
				for (var key in details) {
					if (details.hasOwnProperty(key)) {
						ddVar.set(key, details[key]);
					}
				}
			}
		}
	}

	function initMgrs (mgrList) {
		PM.addVars(programVars);
		PM.addVars(businessVars);
		saveDeviceDetails(deviceDetails);
		var table = BRM.getRuleVarTable();
		for (var ruleID in table) {
			if (!!table[ruleID]) {
				PM.addVars(table[ruleID]);
			}
		}

		// call init on all mgrs
		for (var m in mgrList) {
			try {
				if (mgrList[m].init) {
					mgrList[m].init();
				}
			} catch (e) {
				log(e);
				// just continue looping through all objects that have init methods
			}
		}
	}

	function startMgrs (mgrList) {
		// now start them all up
		for (var m in mgrList) {
			try {
				if (mgrList[m].start) {
					mgrList[m].start();
				}
			} catch (e) {
				log(e);
			}
		}

		CHM.fireFrameworkReadyEvent({
			loadingTime: Date.now() - startedTime
		});
	}

	/**
	 * Deferred starting of managers. Is used to decrease the time of chat drawing in the IE.
	 */
	function deferredStartMgrs () {
		if (gc7(DEFERRED_START_OF_MANAGERS_KEY) && isPersistentChatLaunchingLimited()) {
			startMgrs(mgrList);
		}
	}

	/**
	 * Iterate through the list of Mgr components within the Inq object,
	 * calling their start() methods. The start() method gives every component
	 * an opportunity to generate any events that are necessary
	 */
	function start () {
		if (!this.isFrameworkReady()) {
			return;
		} // start will be called later by a callback
		if (this.started) {
			return;
		}
		this.started = true;

		EVM.addObservables(mgrList);
		EVM.addObservables([EC, CONVM, EH]);
		EVM.addListeners(mgrList);
		EVM.addListeners([EC, CONVM]);
		EVM.addCustomEvents(programCustomEvents);
		EVM.addCustomEvents(businessCustomEvents);
		PM.fireDataReady(); // this must happen before the init/start calls on mgrs
		processCustomerApiRegistry();
		initMgrs(mgrList);

		// This call must be done after initialization of G3R3 to make sure rules triggers are already initialized.
		EVM.addListeners(BRM.getRules());
		if (typeof site.setAuthenticatedUser === "function") {
			site.setAuthenticatedUser();
		}
		if (typeof site.setPersistentCustomerId === "function") {
			site.setPersistentCustomerId();
		}
		if (typeof site.setUserObject === "function") {
			site.setUserObject()
		}
		if (!isEmptyObject(getPersistCustID())) {
			ROM.hasActiveConversations();
		} else {
			// In one particular use case we don't need start all managers right now
			// (see the ticket RTDEV-19357),
			// therefore we will start them later (after drawing of the chat interface).
			// See: deferredStartMgrs
			if (!gc7(DEFERRED_START_OF_MANAGERS_KEY) || !isPersistentChatLaunchingLimited()) {
				startMgrs(mgrList);
			}
		}
	}

	/**
	 * When the inqChatLaunch<siteID>.js is loaded from the html generated by the tagserver /launchNativePostChatSurvey
	 * servlet, the CEAPI_POST_CHAT_SURVEY_DATA object is created and it contains the native post chat survey required IDs, ie.
	 * siteID, engagementID, customerID, businessUnitID, agentGroupID, surveyID, agentID, chatSpecID, chatThemeName.
	 * @return true If parent.CEAPI_POST_CHAT_SURVEY_DATA is defined.
	 */
	function isCEAPIPostChatSurveyMode () {
		return !isWebSDK && !inu1(parent.CEAPI_POST_CHAT_SURVEY_DATA);
	}

	function agrtyer () {
		if (this.dataReady) {
			return;
		}
		this.dataReady = true;

		this.load();
	}

	function load () {
		var vitalVar = new VER34(this.getID(), {}, resources["vital"]);
		var vitalData = vitalVar.z0();
		if (vitalData) {
			initData.absorb(vitalData);
		}

		var persistDataVar = new VER34("pcID", {}, resources["session"]);
		var persistCustID = persistDataVar.z0();
		if (persistCustID && !isEmptyObject(persistCustID)) {
			setPersistCustID(persistCustID);
		}

		var siteTzOffsetVar = new VER34("siteTzOffset", null, resources["session"], "tzOf");
		initData["siteTzOffset"] = siteTzOffsetVar.z0();
	}

	function save () {
		var vitalVar = new VER34(this.getID(), {}, resources["vital"]);
		var persistDataVar = new VER34("pcID", {}, resources["session"]);
		var vitalData = {
			custID: this.getCustID()
		};
		if (getClientTimeLag()) {
			vitalData.clntLag = getClientTimeLag();
		}

		if (!secureWithCustToken) {
			var persistCustID = getPersistCustID();
			if (persistCustID && !isEmptyObject(persistCustID)) {
				persistDataVar.z3(persistCustID);
			}
		}

		vitalVar.z3(vitalData);

		if (!inu1(initData["siteTzOffset"])) {
			var siteTzOffsetVar = new VER34("siteTzOffset", 0, resources["session"], "tzOf");
			siteTzOffsetVar.z3(initData["siteTzOffset"]);
		}
	}

	function isDataReady () {
		return this.dataReady;
	}

	/** Contains the initialization data received from Tagserver
	 * in response on initFramework request
	 * @type {Object}
	 * @see onRemoteCallback function
	 */
	var initData = {
		"scheduleTZs": {}
	};
	MI8.prepare(initData).im13(MI8.XJA3);

	function setFrameworkData (data) {
		initData.absorb(data);

		// see description of getClientTimeLag() function
		if (data.serverTime) {
			initData.clntLag = data.serverTime - (new Date()).getTime();

			/*
			 * non zero lag value is always present due to roundtrip time
			 * of initialization request, insignificant value is discarded
			 * to reduce cookie size
			 */
			if (Math.abs(initData.clntLag) < 1000) {
				initData.clntLag = undefined;
			}
		}

		Inq.save();
	}

	function getDFV (dfvID) {
		return dfvs[dfvID];
	}

	function getInitialDFV () {
		var result = null;
		for (name in dfvs) {
			var dfv = dfvs[name];
			if (dfv.initial) {
				result = dfv;
			}
		}
		return result;
	}

	function isThirdPartyCookiesEnabled () {
		return this.thirdPartyCookiesEnabled;
	}

	function isFrameworkReady () {
		var isReady = true;

		// do we have a valid customerID?
		var id = this.getCustID();
		if (inu1(id) || id == "" || id == "0") {
			isReady = false;
		}
		// check other criteria here
		// set isReady to false if a criteria isn't met
		return isReady;
	}

	/**
	 * Block a chat/call service for a specific duration
	 * @param serviceType one of GR34.CHAT_TYPES
	 * POPUP, POPUP_CALL, C2C, C2CALL, C2WEBRTC
	 * @param duration period in ms or -1 for "forever", 0 for "visit" or "session"
	 */
	function tryue (serviceType, duration) {
		switch (serviceType) {
			case CHM.CHAT_TYPES.POPUP:
			case CHM.CHAT_TYPES.POPUP_CALL:
				CHM.tryue(serviceType, duration);
				break;
			case CHM.CHAT_TYPES.C2C:
			case CHM.CHAT_TYPES.C2CALL:
			case CHM.CHAT_TYPES.C2WEBRTC:
				C2CM.tryue(serviceType, duration);
				break;
			case "ALL":
				CHM.tryue(CHM.CHAT_TYPES.POPUP, duration);
				CHM.tryue(CHM.CHAT_TYPES.POPUP_CALL, duration);
				C2CM.tryue(CHM.CHAT_TYPES.C2C, duration);
				C2CM.tryue(CHM.CHAT_TYPES.C2CALL, duration);
				C2CM.tryue(CHM.CHAT_TYPES.C2WEBRTC, duration);
				break;
			default:
				break;
		}
	}

	function blockServices (services, duration) {
		for (var service in services) {
			tryue(services[service], duration);
		}
	}

	var rule = null;

	function gc7 (constantID, rule) {
		if (rule) {
			return rule.gc7(constantID);
		}
		return constants[constantID];
	}

	function unblockServices (services) {
		for (var service in services) {
			unblockService(services[service]);
		}
	}

	function unblockService (serviceType) {
		switch (serviceType) {
			case CHM.CHAT_TYPES.POPUP:
			case CHM.CHAT_TYPES.POPUP_CALL:
				CHM.unblockService(serviceType);
				break;
			case CHM.CHAT_TYPES.C2C:
			case CHM.CHAT_TYPES.C2CALL:
			case CHM.CHAT_TYPES.C2WEBRTC:
				C2CM.unblockService(serviceType);
				break;
			case "ALL":
				CHM.unblockService(CHM.CHAT_TYPES.POPUP);
				CHM.unblockService(CHM.CHAT_TYPES.POPUP_CALL);
				C2CM.unblockService(CHM.CHAT_TYPES.C2C);
				C2CM.unblockService(CHM.CHAT_TYPES.C2CALL);
				C2CM.unblockService(CHM.CHAT_TYPES.C2WEBRTC);
				break;
			default:
				break;
		}
	}

	function doBusinessRuleActionList (actionId, rule, evt) {
		var action = BusinessRuleActionLists[actionId];
		if (!inu1(action)) {
			action(rule, evt);
		} else {
			log("Can't find BusinessRule Action List " + actionId);
		}
	}

	function doRuleActionList (actionId, rule, evt) {
		var action = RuleActionLists[actionId];
		if (!inu1(action)) {
			action(rule, evt);
		} else {
			log("Can't find Rule Action List " + actionId);
		}
	}

	function isServiceBlocked (serviceType) {
		switch (serviceType) {
			case CHM.CHAT_TYPES.POPUP:
			case CHM.CHAT_TYPES.POPUP_CALL:
				return CHM.isBlocked(serviceType);
			case CHM.CHAT_TYPES.C2C:
			case CHM.CHAT_TYPES.C2CALL:
			case CHM.CHAT_TYPES.C2WEBRTC:
				return C2CM.isBlocked(serviceType);
			case "ANY":
				return CHM.isAnyBlocked() || C2CM.isAnyBlocked();
			default:
				return false;
		}
	}

	function getBlockedServicesList () {
		var result = [];
		if (C2CM.isBlocked(CHM.CHAT_TYPES.C2CALL)) {
			result.push(CHM.CHAT_TYPES.C2CALL);
		}
		if (C2CM.isBlocked(CHM.CHAT_TYPES.C2C)) {
			result.push(CHM.CHAT_TYPES.C2C);
		}
		if (CHM.isBlocked(CHM.CHAT_TYPES.POPUP)) {
			result.push(CHM.CHAT_TYPES.POPUP);
		}
		if (CHM.isBlocked(CHM.CHAT_TYPES.POPUP_CALL)) {
			result.push(CHM.CHAT_TYPES.POPUP_CALL);
		}
		if (C2CM.isBlocked(CHM.CHAT_TYPES.C2WEBRTC)) {
			result.push(CHM.CHAT_TYPES.C2WEBRTC);
		}
		return result;
	}

	function createFloatingDiv (_id, _x, _y, _w, _h) {
		try {
			var obj = document.createElement('div');
			obj.style.position = "absolute";
			obj.style.width = _w ? _w : 0;
			obj.style.height = _h ? _h : 0;
			obj.style.left = _x ? _x + "px" : 0;
			obj.style.top = _y ? _y + "px" : 0;
			obj.style.zIndex = 99;
			obj.style.display = "none";
			obj.style.padding = 0;
			obj.style.margin = 0;
			obj.id = _id;
			document.getElementsByTagName("body")[0].appendChild(obj);
		} catch (E) {
			this.debug("Could not create div element.");
		}
		return document.getElementById(_id);
	}

	function createHiddenIFrame (_id, _x, _y, _w, _h, src) {
		try {
			var obj = document.createElement('iframe');
			obj.style.position = "absolute";
			obj.style.width = _w ? _w : 0;
			obj.style.height = _h ? _h : 0;
			obj.style.left = _x ? _x + "px" : 0;
			obj.style.top = _y ? _y + "px" : 0;
			obj.style.zIndex = 99;
			obj.style.display = "none";
			obj.style.overflow = "hidden";
			obj.style.padding = 0;
			obj.style.margin = 0;
			obj.id = _id;
			obj.name = _id;
			if (src) {
				obj.src = src;
			}
			return obj;
		} catch (E) {
			this.debug("Could not create iFrame element.");
		}
		return null;
	}

	function wasSaleAction () {
		try {
			var par = PM.getVar("saleState", null).z0();
			var con = gc7("SALE_STATE_CONVERTED", null);
			return par == con;
		} catch (e) {}
		return false;
	}

	function executeCustomCommand (params) {
		if (!inu1(params)) {
			try {
				// replace '({' to '{' , '})' to '}'
				params = params.replace(/\({/g, "{").replace(/}\)/g, "}");

				var inParams = MI8.JSON.parse(params);
				var cmdType = inParams.cmdType;
				var cmdParam = inParams.cmdParam;
				switch (cmdType) {
					case 'block-service':
						tryue(cmdParam.serviceType, cmdParam.period);
						break;
					case 'client_function':
						var functionName = inParams.functionName;
						if (isWebSDK) {
							FrameBridge.postFunctionByName(functionName, [cmdParam]);
						} else {
							if (parent[functionName]) {
								(parent[functionName]).apply(parent, [cmdParam]);

							} else if (functionName.indexOf(".") != -1) {
								var t = functionName.split("."), k;
								for (var i = 0; i < t.length; i++) {
									if (typeof k != "undefined") {
										if (typeof k[t[i]] == "function") {
											(k[t[i]]).apply(parent, [cmdParam]);
										} else if (typeof k[t[i]] == "object") {
											k = k[t[i]];
										}
									} else {
										if (typeof parent[t[i]] == "function") {
											(parent[t[i]]).apply(parent, [cmdParam]);
										} else if (typeof parent[t[i]] == "object") {
											k = parent[t[i]];
										}
									}
								}
							}
						}
						break;
					default:
						log("Unknown command " + cmdType + ", parameters : " + cmdParam);
				}
			} catch (ex) {
				log("Error execute command " + params + ", " + ex);
			}
		}
	}

	function initXD () {
		CM.init();
		CM.requestCookie(function (context) {
			/* Forwards the context to IFrameProxyCallback handler with the correct "this" context.
			 * When this handler is invoked, "this" is pointing to the window, not the Inq context.
			 * @see LR45.handleSuccess
			 * We correct that by calling the IFrameProxyCallback via the anonymous function.
			 */
			Inq.IFrameProxyCallback(context.data);
		});
	}

	/**
	 * This method parses XD mode cookie data <name-string> map to <name-object> map
	 * while stripping off the trailing _<siteid> from the names of each cookie object.
	 */
	function parseCookieData (data) {
		var retval = {};

		// Build list of Cookie names
		var cookieRes = [];
		for (var res in resources) {
			try {
				if (typeof resources[res]['getName'] === 'function') {
					cookieRes.push(resources[res].getName());
				}
			} catch (err01) {
				// move on to the next resource
				// no recovery or log needed.
			}
		}

		for (var name in data) {
			var cval = data[name];
			if (!!cval) {
				var cname = name.replace(/_\d+$/, "");
				if (cname == "JSESSIONID" || cname === "inqCA" || cname === "inqLT") {
					retval[cname] = cval;
				} else if (cookieRes.contains(cname, function (oa, ob) {
					return oa === ob;
				})) {
					// parse cookie value if only it is defined in resources.
					try {
						retval[cname] = MI8.JSON.parse(cval);
					} catch (e) {
						// log error and continue looping to parse all other cookies
						var errMsg = "Error[parseCookieData] while parsing cookie: Cookie name=" + cname
							+ ",value=" + cval + cf21(e);
						let12(errMsg);
					}
				}
			}
		}
		return retval;
	}

	var _3pcSupported = true;

	/**
	 * A callback from our initialization controller.
	 * This is invoked twice in XD mode as we need to:
	 *   1) call once to check if 3P Cookies are supported on the browser AND if so
	 *   2) get the customerID and ip address
	 * In NonXD mode we make only one call to our controller: to get the custID and browserIP.
	 * @param {Object} initDataFromTS - JSON object
	 */
	function onRemoteCallback (initDataFromTS) {
		var _xd = (this.xd && (CM).cookies[COOKIE_PC_NAME]!="2" && !(CM47.xdPsHelper.enabled || CM47.chatSessionHelper.isEnabled) );

		if (!!initDataFromTS['devicetype']) {
			setDeviceType(initDataFromTS['devicetype']);
		}

		if (!!initDataFromTS['deviceDetails']) {
			setDeviceDetails(initDataFromTS["deviceDetails"]);
		}

		/** @type {string} */
		var inqID = this.getID();
		/** @type {Object} */
		var inqDataForLogs = initDataFromTS[inqID] || {};

		if (!frameworkCanRun(getDeviceType(), _3pcSupported, true, _xd)) {
			if (document.cookie.indexOf("_inqNR=0") < 0) { // only log once
				lmt12(plc1("Framework load aborted due to business rules settings: deviceType="
					+ getDeviceType() + ";3pc=" + _3pcSupported + ";userAgent=" + navigator.userAgent, null, inqDataForLogs["custID"],
					inqDataForLogs["custIP"], inqDataForLogs["siteID"]), LOG_LEVELS.INFO);
				document.cookie = "_inqNR=0"; //remember our decision here to keep us from re-logging this event (at least for the session)
			}
			return; //abort forever
		}

		if (initDataFromTS[inqID]) {
			setFrameworkData(initDataFromTS[inqID]);
		} else if (!inu1(initDataFromTS["siteTzOffset"])) {
			log("Received site timezone offset from server: " + initDataFromTS["siteTzOffset"] + "ms");
			setFrameworkData(initDataFromTS);
		} else {
			lmt12(plc1("Framework load aborted due to incorrect initData: deviceType="
				+ getDeviceType() + ";3pc=" + _3pcSupported + ";userAgent=" + navigator.userAgent + ";initData=" + initDataFromTS), LOG_LEVELS.WARN);
			return;
		}
		initData["geoData"] = initDataFromTS["geoData"];
		PM.fireDataReady();
		this.start();
	}


	/**
	 * A callback from our 3PC IFrame proxy "get cookie" routine.
	 * In XD mode only, this is called (back) on every page landing before framework modules
	 * are initialized (to get cookies before without getting them from the server).
	 * @param {String} data Aggregate cookie string (like "document.cookie" from the 3P domain)
	 */
	function IFrameProxyCallback (data) {
		if ((data === "no-cookie" || data === "") && inu1(CM.isPersistentCookiesEnabled)) {
			CM.isPersistentCookiesEnabled = false;

			if (xdAutoSelect
				&& isCacheSolutionEnabled()
				&& (isChrome() || isFF() || isEdge())
				&& CM47.xdPsHelper.is1pcEnabled()
			) {
				/*
				 Cache persistent solution for Chrome & FF start here
				 The condition is 3pc blocked, in self detection mode, on Chrome or FF, and 1pc enabled
				 */
				if (CM47.xdPsHelper.populateDomains2Check()) {
					log("Starting Cache Persistent solution");
					CM47.chatSessionHelper.isEnabled = true;
					CM47.chatSessionHelper.read1SPC(CM47.xdPsHelper.hostFileURLUse);
				} else {
					log("No Sibling domain to use Cache Solution");
				}
			} else if (xdAutoSelect && CM47.xdPsHelper.isUse1pcXdSolutionOnIE()) {
				/*
				 * Use 1pc solution
				 */
				CM47.xdPsHelper.requestSavedXdCookies();
			} else {
				log("3PC blocked and not able to offer a chat");
			}
		} else {
			//In XD mode in IE, if the peristent cookies are allowed, we will get the 'pc' cookie data to
			//IFrameProxyCallback function. If the data is empty that means only session cookies are allowed.
			CM.isPersistentCookiesEnabled = true;
			data = parseCookieData(CM._getCookies(data));
			CM.setXDCookies(data);
			this.agrtyer();
			if (resources['vital']) {
				log("Sync Sale Status: " + resources['vital'].read('_ss'));
			}

			var inqID = this.getID();
			var inqData = {};
			inqData[inqID] = {
				siteID: this.getSiteID(),
				custID: this.getCustID(),
				scheduleTZs: initData["scheduleTZs"]
			};

			// When "from scratch" IJSF init is performed, site timezone offset is requested as part of init request
			if (isTZRequestRequired()) inqData[inqID].tzID = siteTzID;

			var strData = MI8.JSON.stringify(inqData);
			this.callRemote(urls.initFrameworkURL, {
				rid: this.getID(),
				d: strData
			});
		}
	}

	/**
	 * The callback function of Cache persistent solution.
	 * @param {Object} data collected from server side.
	 */
	function IFrameTSCallback (data) {
		CM.isPersistentCookiesEnabled = true;
		var currentCookiesObject = parseCookieData(CM._getCookies(CM47.chatSessionHelper.cookie1pcXdData));
		var serverData = CM47.chatSessionHelper.parseDataFromServer(data);
		if (inu1(serverData)) {
			var currentChat = currentCookiesObject["inqSession"]
				? currentCookiesObject["inqSession"]["chat"] : {};
			logInfoToTagServer(
				"For Cache Persistent Solution chat data wasn't received from server."
				+ " Cookies will be used. Current chat id in cookies "
				+ (currentChat ? currentChat.id : "is absent")
			);

			if (!this.getCustID() &&
				!inu1(CM47.chatSessionHelper.customerId)) {
				//If there is no customer id in cookies set it from server response.
				setParamToObject(
					currentCookiesObject,
					"inqVital.INQ.custID",
					CM47.chatSessionHelper.customerId
				);
				setCustID(CM47.chatSessionHelper.customerId, false);
			}

			CM.setXDCookies(currentCookiesObject);
			this.agrtyer();
		} else {
			logInfoToTagServer(
				"For Cache Persistent Solution chat data was received from server."
				+ " Server data will be merged with cookies for chat restoring."
				+ " Chat id " + serverData.engagementID + " was received from server"
			);
			/*
			 * If there is chat data received from server we should merge them
			 * with current cookie data, and replace customer id according
			 * to server data.
			 */
			data = CM47.chatSessionHelper.buildCookieFromAPI(currentCookiesObject, serverData);
			CM.setXDCookies(data);
			this.agrtyer();
			setCustID(CM47.chatSessionHelper.customerId, false);
		}

		if (resources['vital']) {
			log("Sync Sale Status: " + resources['vital'].read('_ss'));
		}

		var inqID = this.getID();
		var inqData = {};
		inqData[inqID] = {
			siteID: this.getSiteID(),
			custID: this.getCustID(),
		    scheduleTZs: initData["scheduleTZs"]
		};

		// When "from scratch" IJSF init is performed, site timezone offset is requested as part of init request
		if (isTZRequestRequired()) {
			inqData[inqID].tzID = siteTzID;
		}

		var strData = MI8.JSON.stringify(inqData);
		this.callRemote(urls.initFrameworkURL, {
			rid: this.getID(),
			d: strData
		});
	}

	function init () {
		if (this.initialized || !isValidBaseFunctionality()) {
			return;
		}
		var inqData = {};
		var inqID = this.getID();
		PM.addListener(this);
		exposeCustomerApi();
		DM.init();
		PSC.init();
		// Detects Safari on iOS 7 for 1pc persistent solution.
		if (xdAutoSelect) {
			CM.init();
			CM47.firstRequestCookie(); /* see callback at IFrameProxyCallback() */
		} else if (this.xd) {
			initXD();
		} else {
			if (CM47.isSessionCookiesAllowed()) {
				this.load();
				inqData[inqID] = {
					siteID: this.getSiteID(),
					custID: this.getCustID(),
					scheduleTZs: initData["scheduleTZs"]
				};

				// When "from scratch" IJSF init is performed, site timezone offset is requested as part of init request
				if (isTZRequestRequired()) inqData[inqID].tzID = siteTzID;

				var strData = MI8.JSON.stringify(inqData);

				this.callRemote(urls.initFrameworkURL, {
					rid: this.getID(),
					d: strData
				});
			}
		}
	}

	function pd1d (data) {
		if (!data) {
			return data;
		}
		if (typeOf(data) == "array") {
			try {
				if (data.length > 0) {
					var elem = data[0];
					if (elem.key) {
						// map
						var out = Array.prepareMapToSerialize(data);
						return MI8.JSON.stringify(out)
					}

				}
				return MI8.JSON.stringify(data)
			} catch (e) {
				let12(cf21(e));
			}
		}
		return data;
	}

	function main () {
		// If isn't same origin as top then don't load framework
		if (site.sameOriginReferrerFilterRegex()) {
			try {
				// method call will fail and throw an error if cross domain
				var elm = getParentElByIDTFacade("doesNotExist");
			} catch (e) {
				return;
			}
		}
		MI8.prepare(this).im13(MI8.Observable).im13(MI8.FM2);
		this.im13(MI8.Persistable).im13(MI8.XJA3).im13(MI8.RC54);
		this._frameworkModule("INQ");
		this._observable();
		if (getIOSNativeSDKInstance()) {
			getIOSNativeSDKInstance().postMessage(JSON.stringify({ "reqType": "chatprogress" }))
		} else {
			this.init();
		}
		// this.start is called by the agrtyer method
	}

	var c2cPageElementIDs = site.c2cPageElementIDs();
	C2C.setC2CPageElementIDs(c2cPageElementIDs);
	// BEGIN Mgr List - Instantiate exactly one instance of all mgrs

	// it is XD if site's persistence Mode is Xd or Self-Detection
	var PM = X4334rtf.getInstance(site.persistenceMode != 'non-XD');
	var CM = PM.getCookieMgr();
	var SM = new StorageMgr("SM", CM);
	var C2CM = new X43("C2CM", site.c2cMgrData());
	var EVM = new EMT5("EVM");
	var ROM = new RM91("ROM", {});
	var LDM = new LE12("LDM", v3Lander.landingData); // data now resides client-side
	/**
	 * Used to modify ETL fields before logging.
	 * @type {EtlDataBuilder}
	 */
	var EDB = new EtlDataBuilder();

	/** @type {PSC1} */
	var PSC = new PSC1();

	/** @type {af4} */
	var AL;
	if (!isWebSDK) {
		AL = new af4();
	}

	var BusinessRuleActionLists = site.businessRuleActionLists();
	var RuleActionLists = site.ruleActionLists();
	var functionRulesObj;

	if (jsSDKEnabled) {
		functionRulesObj = JSSDK_RENDERER.RenderJsFunctions(jsonAPIData['program-data']['js-functions']);
	} else {
		functionRulesObj = programRulesConfig("js-functions");
	}

	var businessFuncRulesObj = site.JSBusinessFunctions();
	if (businessFuncRulesObj) {
		var prop, hasOwnProp = {}.hasOwnProperty;
		for (prop in businessFuncRulesObj) {
			if (hasOwnProp.call(businessFuncRulesObj, prop))
				functionRulesObj[prop] = businessFuncRulesObj[prop];
		}
	}
	var FM = new FcnMgr(functionRulesObj);
	if (typeof RENDERINGCONTEXT !== 'undefined') {
		//RENDERINGCONTEXT is for JSSDK rendering. SM is needed for resources rendering
		RENDERINGCONTEXT.SM = SM;
	}

	var dfvs = site.xmlData.dfvs();
	var resources = site.resources();
	resources[PERSISTENT_COOKIE_ALLOWED] = new CCD(
		PERSISTENT_COOKIE_ALLOWED,
		COOKIE_PC_NAME,
		site.cookiePath,
		24 * 3600 * 1000,
		site.rootDomain,
		0,
		CM
	);
	resources["state"] = new CCD("state", "inqState", site.cookiePath,  365 * 24 * 3600 * 1000, site.rootDomain, 0, CM);
	resources["vital"] = new CCD("vital", "inqVital", site.cookiePath,  365 * 24 * 3600 * 1000, site.rootDomain, 0, CM);
	resources["session"] = new CCD("session", "inqSession", site.cookiePath,  365 * 24 * 3600 * 1000, site.rootDomain, 0, CM);
	resources["bses"] = new CCD("bses", "inqBSes", site.cookiePath, undefined, site.rootDomain, 0, CM);
	resources["surveyShown"] = new CCD("surveyShown", "tcSrv", site.cookiePath,  365 * 24 * 3600 * 1000, site.rootDomain, 0, CM);
	resources["conversationTokens"] = new CCD("conversationTokens", "inqCT", site.cookiePath, undefined, site.rootDomain, 0, CM);

	var schedules = MI8.mixAbsorber();
	var businessSchedules = site.xmlData.businessSchedules();
	var programSchedules;

	if (jsSDKEnabled) {
		programSchedules = JSSDK_RENDERER.RenderSchedules(jsonAPIData['program-data']['schedules']);
	} else {
		programSchedules = programRulesConfig("schedules");
	}

	schedules.absorb(programSchedules);
	schedules.absorb(businessSchedules);

	var k6ji = Base64();
	var LoadM = new LR45();
	var CommunicationMgr = new NR7();
	var MM = new MM12(site.mediaMgrData());

	var programRulesData;
	if (jsSDKEnabled) {
		programRulesData = JSSDK_RENDERER.RenderRules(jsonAPIData["program-data"]["rules"]);
	} else {
		programRulesData = programRulesConfig("rules");
	}

	if (jsSDKEnabled) {
		var initRulesData = rulesEngineDataStr;
	} else {
		eval("var initRulesData = " + rulesEngineDataStr.toString());
	}

	var reDat = initRulesData(programRulesData);

	var SVYM = new SM19(site.surveySpecs());
	// Create the "CEAPI-Post-Chat-Survey" rule and add it to the brm's rules list. ACIF need to retrieve agent group from rule id.
	if (isCEAPIPostChatSurveyMode()) {
		//ID for this rule reserved in Program Rules
		reDat.rules.push(SVYM.createCEAPIPostChatSurveyRule(401));
	}

	// initialize all loaded mbu rules if any
	for (var i = 0; i < loadedMbuRuleDataFuns.length; i++) {
		if (jsSDKEnabled) {
			var initMbuRules = loadedMbuRuleDataFuns[i];
		} else {
			eval("var initMbuRules = " + loadedMbuRuleDataFuns[i].toString());
		}

		reDat.rules = reDat.rules.append(initMbuRules().rules);
	}

	if (loadedMbuRuleDataFuns.length > 0) {
		// sort rules by its indexes
		reDat.rules.sort(function (a, b) {
			if (inu1(a.ruleIndex) || inu1(b.ruleIndex)) return 0;
			if (a.ruleIndex > b.ruleIndex) return 1;
			if (a.ruleIndex < b.ruleIndex) return -1;
			return 0;
		});
	}

	var BRM = new G3R3("BRM", reDat, site.disableMutationObservation);

	var CHM = GR34.getInstance({
		thankYouShown: site.displayTYImage,
		thankYouEnabled: site.displayTYImage,
		displayTYImage: site.displayTYImage,
		CHAT_TYPES: {
			C2C: "C2C",
			C2CALL: "C2CALL",
			C2VIDEO: "C2VIDEO",
			C2WEBRTC: "C2WEBRTC",
			POPUP: "POPUP",
			POPUP_CALL: "POPUP_CALL",
			PERSISTENT: "PERSISTENT",
			MONITOR: "MONITOR",
			CONVERSIVE: "CONVERSIVE",
			EXTERNAL_CHAT: "EXTERNAL_CHAT",
			EXTERNAL_POPUP_CHAT: "EXTERNAL_POPUP_CHAT"
		}
	});

	if (shouldDetectAdblock()) {
		checkAdBlockersActive();
	}

	/*
	 * TSD4#agrtyer is using data from GR34.
	 * So GR34#agrtyer should be called before agrtyer in
	 * TSD4. Order of calling listeners in agrtyer,
	 * related to order of creating managers, so GR34 should be created
	 * before TSD4.
	 */
	var CONVM = new TSD4();
	/**
	 * This object used to provide mapping of obfuscated IJSF functions to CI.
	 * @type {as17}
	 */
	var as17 = {};

	var FP = new FlashPeer("FP", {});

	var CBM = null;
	if (site.enableCobrowse == true && !isCEAPIPostChatSurveyMode()) {
		var CMBConfigs = site.coBrowseConfigs();
		CBM = new CBMR("CBM", {
			cobrowseMaskingConfig: CMBConfigs.cobrowseMaskingConfig,
			isEmbeddedResource: CMBConfigs.isEmbeddedResource,
			enableCobrowseOnMobile: site.enableCobrowseOnMobile
		});
	} else {
		// Disable cobrowse in CEAPIPostChatSurveyMode. RTDEV-17754
		site.enableCobrowse = false;
	}

	var WDM = WatchDogMgr.getInstance();

	/* EXCVTR is not a manager, but acts the same way as managers when it concerns event handling. */
	var EC = {};
	if (site.EC) {
		MI8.prepare(site.EC).im13(MI8.Observable).im13(MI8.RC54);
		EC = site.EC;
		EC._observable();
	}
	var EH = {};
	if (site.EH) {
		MI8.prepare(site.EH).im13(MI8.Observable);
		EH = site.EH;
		EH._observable();
	}

	var DM = new DME2();

	// END Mgr List
	var DT = new AutomatonDT();

	if (typeof RENDERINGCONTEXT !== 'undefined') {
		//RENDERINGCONTEXT is for JSSDK rendering
		RENDERINGCONTEXT.C2CM = C2CM;
		RENDERINGCONTEXT.PM = PM;
		RENDERINGCONTEXT.CM = CM;
		RENDERINGCONTEXT.SM = SM;
		RENDERINGCONTEXT.EVM = EVM;
		RENDERINGCONTEXT.FM = FM;
		RENDERINGCONTEXT.ROM = ROM;
		RENDERINGCONTEXT.SVYM = SVYM;
		RENDERINGCONTEXT.BRM = BRM;
		RENDERINGCONTEXT.CHM = CHM;
		RENDERINGCONTEXT.LDM = LDM;
		RENDERINGCONTEXT.FP = FP;
		RENDERINGCONTEXT.CONVM = CONVM;
		RENDERINGCONTEXT.resources = resources;
		RENDERINGCONTEXT.getCustGeoData = getCustGeoData;
	}

	var programVarsSource;
	if (jsSDKEnabled) {
		programVarsSource = JSSDK_RENDERER.RenderVariables(jsonAPIData["program-data"]["vars"]);
	} else {
		programVarsSource = programRulesConfig("vars");
	}
	var programVars = VER34.getInstancesFromData(programVarsSource);
	var businessVars = VER34.getInstancesFromData(site.businessVars());
	var businessCustomEvents = site.businessCustomEvents();
	var programCustomEvents;

	if (jsSDKEnabled) {
		programCustomEvents = JSSDK_RENDERER.RenderCustomEvents(jsonAPIData["program-data"]["custom-events"]);
	} else {
		programCustomEvents = programRulesConfig("custom-events");
	}

	var VAM = new VAMgr("VAM", site.vamAttributes);
	var mgrList = [
		// one string for each one new manager to see the latest update
		PM, CM, SM, ROM, BRM, LDM, C2CM, CHM, VAM, MM, SVYM
	];
	if (CBM) {
		mgrList.push(CBM);
	}
	if (!("forceFPCookie" in window)) {
		window.forceFPCookie = false;
	}

	if (typeof RENDERINGCONTEXT !== 'undefined') {
		//RENDERINGCONTEXT is for JSSDK rendering
		RENDERINGCONTEXT.VAM = VAM;
	}

	var rechatInterval = parseInt(site.rechatinterval); // given in days
	var v3framesrc = v3Lander.hostedFileURL || site.v3framesrc;
	var v3C2cPersistent = site.c2cToPersistent;
	var xd = (site.persistenceMode != 'non-XD');
	var xdAutoSelect = (site.persistenceMode == 'Self-Detection');
	var initialized = false;
	var started = false;
	var multiHost = site.multiHost;

	function getVar (varname, ruleID, optDflt) {
		return PM.getVar(varname, BRM.rb41(ruleID)).z0();
	}

	/**
	 * Returns address of hosted file e.g. http://touchcommerce.com/TouchCommercetop.html
	 * Used as a location for proxy IFrames and other purposes.
	 * Please note: window.location.hostname is the host's name without the port number,
	 *              not window.location.host.  Please see the correct methodology of building the path from
	 *              cookie manager GR34.prototype.againPopoutChat
	 */
	function getHostedFileUrl () {
		return window.location.protocol + "//" + window.location.hostname +
			((window.location.port == "") ? "" : ":" + window.location.port) + v3framesrc;
	}

	/**
	 * Returns "click to persistent" flag value
	 */
	function isC2cPersistent () {
		return v3C2cPersistent;
	}

	/**
	 * Loads javascript from server.
	 * @param server server to use
	 * @param urlClean url to use when obfuscation is disabled
	 * @param urlObfuscated url to use when obfuscation is enabled
	 * @param initFunction function to call once script is loaded
	 * @param errorFunction function to call if script load error occurs
	 */
	function loadScript (server, urlClean, urlObfuscated, initFunction, parameters, errorFunction) {
		var srctag = document.createElement("SC" + "RIPT");
		srctag.src = secureProtocol(server) + (site.JSDebugMode ? urlClean : urlObfuscated);
		srctag.type = "text/javascript";
		srctag.charset = "utf-8";
		srctag.language = "javascript";
		srctag._parameters = parameters;
		srctag._function = initFunction;
		srctag._errFunction = errorFunction;
		srctag.onload = function () {
			// We can have a ready state change for both complete and loaded, and we only want one call to the initFunction
			this.onreadystatechange = null;
			this.onload = null;
			this._function(this._parameters);
		};
		srctag.onreadystatechange = function () {// workaround for IE only
			if (this.readyState == 'complete' || this.readyState == 'loaded') {
				// We can have a ready state change for both complete and loaded, and we only want one call to the initFunction
				this.onreadystatechange = null;
				this.onload = null;
				this._function(this._parameters);
			}
		};
		srctag.onerror = function (msg) {
			this.onreadystatechange = null;
			this.onload = null;
			if (typeof this._errFunction == 'function') {
				this._errFunction(msg);
			}
		};
		document.body.appendChild(srctag);
	}

	/**
	 * Decide whether we should detect adblockers
	 * This was added because a client wanted the ability to disable loading the ad-blocker detection script because that
	 * script gets loaded from our nuance tagserver and they did not allow js script injections onto their sites from
	 * one of our servers.
	 * @returns {boolean}
	 */
	function shouldDetectAdblock () {
		if (isWebSDK) {
			return false;
		}

		return site.detectAdblock;
	}

    function getThemeName() {
        return CHM.chat.chatSpec.chatTheme.fn.replace(/\.(mxml|zip)$/, "");
    }

    function getSkinRootUrl() {
        return site.noJSHosting ? site.clientStaticUrl + "/" : urls.skinURL;
    }

	/**
	 * Method to verify whether ad blockers / antitrackers are enabled on the current page.
	 * Needed as enabled adblockers block javascript XHR requests from reaching server-side endpoints,
	 * which prevents web chat from correct functioning.
	 */
	function checkAdBlockersActive () {
		// Check if BlockingDetector already e9.
		if (typeof top.blockingDetector !== 'undefined' || typeof top.BlockingDetector !== 'undefined') {
			// Instance e9 before we init possible identity fake by adblocker. Considering adblock is active
			CHM.setAdblockOn();
		} else {
			// Otherwise, you import the BlockingDetector script
			var filePath = "/js/ads-blocking-detector";
			loadScript(
				urls.baseURL,
				filePath + ".js",
				filePath + ".min.js",
				function () {
					try {
						// If all goes well, we configure blockingDetector detection events
						top.blockingDetector.onDetected(function () {
							CHM.setAdblockOn();
						});
						top.blockingDetector.onNotDetected(function () {
							CHM.setAdblockOff();
						});
						top.blockingDetector.check(true);
					} catch (e) {
						log("ERROR: " + e.message);
						top.blockingDetector = undefined;
						CHM.setAdblockOn();
					}
				},
				"",
				function () {
					// If the script does not load (blocked, integrity error, ...)
					// Then a detection is triggered
					CHM.setAdblockOn();
				}
			);
		}
	}

	function isInitialized () {
		return isInqInitialized;
	}

	/**
	 * Makes the updating of data from the opener window context.
	 */
	function updateDataFromOpener () {
		openerData.page = openerCall("getPage");
	}

	/**
	 * Clears the data got from the opener window when they can be outdated.
	 */
	function clearDataFromOpener () {
		openerData = {};
	}

	/**
	 * @typedef {Object} Data
	 * @property {String} siteID - id of site
	 * @property {String} customerID - id of customer
	 * @property {String} persistentCustomerID - ID used for async chat data filtering, stringified JSON
	 * @property {String} user_object - object for async customer validation, stringified JSON
	 * @returns {Data} base body object which required for async chat data requests to TagServer.
	 */
	function prepareBaseBodyForAsyncChatDataRequest () {
		var data = { "siteID": getSiteID(), "customerID": Inq.getCustID() };
		if (getAuthUser()) {
			data.authenticatedUser = JSON.stringify(getAuthUser());
		}
		if (getPersistCustID()) {
			data.persistentCustomerID = JSON.stringify(getPersistCustID());
		}
		if (getUserObject()) {
			data.user_object = JSON.stringify(getUserObject());
		}
		return data;
	}

	/**
	 * Calls eval or throws an error if using eval is forbidden
	 * because of security concerns.
	 *
	 * @param {string} string - code for eval
	 * @param {window=} contextWindow - context where eval should be called
	 */
	function evaluateLegacySettings (string, contextWindow) {
		if (typeof site.evaluateLegacySettings === "function") {
			return site.evaluateLegacySettings(string, contextWindow);
		} else {
			/*
			 * If site.evaluateLegacySettings is null it means that eval use
			 * is disabled in settings.
			 * If site.evaluateLegacySettings absent, it means that tcFramework
			 * and site default has different code base and they are incompatible
			 */
			if (site.evaluateLegacySettings === null) {
				var errorMessage = "evaluateLegacySettings in tcFramework " +
					"can't be used, because it was disabled in settings";
				var error = new Error(errorMessage);
				var errorWithStackTrace = errorMessage;
				// IE doesn't support stack
				if (error.stack) {
					errorWithStackTrace += error.stack;
				}
				let12(errorWithStackTrace, true);
				throw error;
			} else if (!jsSDKEnabled && evaluateLegacySettingsWarnNeeded) {
				evaluateLegacySettingsWarnNeeded = false;
				lwt12(
					"Incompatible version of tcFramework and site default,"
					+ " probably this happened because of cache."
				);
				contextWindow = contextWindow || window;
				return contextWindow.eval(string);
			}
		}
	}

	function isResolvePageServiceEnabled() {
		return site.useResolvePageWSDomain;
	}

	return {
		xd: xd,
		siteID: siteID,
		main: main,
		agrtyer: agrtyer,
		onRemoteCallback: onRemoteCallback,
		isFrameworkReady: isFrameworkReady,
		isDataReady: isDataReady,
		init: init,
		initXD: initXD,
		IFrameProxyCallback: IFrameProxyCallback,
		IFrameTSCallback: IFrameTSCallback,
		isThirdPartyCookiesEnabled: isThirdPartyCookiesEnabled,
		start: start,
		save: save,
		load: load,
		getID: getID,
		getCustID: getCustID,
		getCustIP: getCustIP,
		getSiteID: getSiteID,
		tryue: tryue,
		unblockService: unblockService,
		blockServices: blockServices,
		unblockServices: unblockServices,
		isServiceBlocked: isServiceBlocked,
		Drag: isWebSDK ? null : new Drag(),
		Resize: isWebSDK ? null : new Resize(),
		Rule: Rule,
		log: log,
		getLocalizedMessage: getLocalizedMessage,
		v3C2cPersistent: v3C2cPersistent,
		v3framesrc: v3framesrc,
		multiHost: multiHost,
		rechatInterval: rechatInterval,
		isSameOrigin: isSameOrigin,
		doBusinessRuleActionList: doBusinessRuleActionList,
		doRuleActionList: doRuleActionList,
		createHiddenIFrame: createHiddenIFrame,
		createFloatingDiv: createFloatingDiv,
		wasSaleAction: wasSaleAction,
		JSON: MI8.JSON,
		getEnableHighlight: getEnableHighlight,
		getCobrowseEnableMinimizeRestore: getCobrowseEnableMinimizeRestore,
		isCEAPIPostChatSurveyMode: isCEAPIPostChatSurveyMode,
		getFullBrowserInfo: getFullBrowserInfo,

		urls: MI8.clonize(urls).clone(),
		EVM: EVM,		 				// Event Mgr
		CM: CM,          				// Cookie mgr
		LoadM: LoadM,                   // Load mgr
		PM: PM,			 				// Persistence Mgr
		ROM: ROM,       				// Remote Operation Mgr
		BRM: BRM,						// Business Rules Mgr
		LDM: LDM,						// Landing Mgr
		C2CM: C2CM,						// Click2Chat Mgr
		C2C: C2C,
		CHM: CHM,
		GR34: CHM,					// Chat Mgr
		CBM: CBM,				        // Co-Browse Manager
		SVYM: SVYM,                     // Survey Manager
		reinitChat: reinitChat,  		// CUSTOMER API
		launchChatNow: launchChatNow,	// CUSTOMER API
		launchChatNowByPageID: launchChatNowByPageID,	// CUSTOMER API
		setChatSuppressedForSession: setChatSuppressedForSession, // CUSTOMER API
		FlashPeer: FP,   				// Flash Peer
		WDM: WDM,                       // WatchDogManager
		DT: DT,							// AutomatonDT
		EC: EC,							// EXCVTR object
		EH: EH,							// ExitHook object

		// Getters for Inq object
		get custIP() {
			return getCustIP();
		},

		get custID() {
			return getCustID();
		}
	};
})(v3Lander.inqSiteDataFun, v3Lander.inqRulesEngineFun, v3Lander.loadedMbuRuleDataFuns, v3Lander.programRulesConfig);

Inq.main();

